
/home/vagrant/nbench-byte-2.2.3/nbench:     file format elf64-x86-64


Disassembly of section .init:

0000000000400df0 <_init>:
  400df0:	48 83 ec 08          	sub    $0x8,%rsp
  400df4:	48 8b 05 fd f1 20 00 	mov    0x20f1fd(%rip),%rax        # 60fff8 <_DYNAMIC+0x1e0>
  400dfb:	48 85 c0             	test   %rax,%rax
  400dfe:	74 05                	je     400e05 <_init+0x15>
  400e00:	e8 bb 02 00 00       	callq  4010c0 <__sprintf_chk@plt+0x10>
  400e05:	48 83 c4 08          	add    $0x8,%rsp
  400e09:	c3                   	retq   

Disassembly of section .plt:

0000000000400e10 <__ctype_toupper_loc@plt-0x10>:
  400e10:	ff 35 f2 f1 20 00    	pushq  0x20f1f2(%rip)        # 610008 <_GLOBAL_OFFSET_TABLE_+0x8>
  400e16:	ff 25 f4 f1 20 00    	jmpq   *0x20f1f4(%rip)        # 610010 <_GLOBAL_OFFSET_TABLE_+0x10>
  400e1c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400e20 <__ctype_toupper_loc@plt>:
  400e20:	ff 25 f2 f1 20 00    	jmpq   *0x20f1f2(%rip)        # 610018 <_GLOBAL_OFFSET_TABLE_+0x18>
  400e26:	68 00 00 00 00       	pushq  $0x0
  400e2b:	e9 e0 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e30 <free@plt>:
  400e30:	ff 25 ea f1 20 00    	jmpq   *0x20f1ea(%rip)        # 610020 <_GLOBAL_OFFSET_TABLE_+0x20>
  400e36:	68 01 00 00 00       	pushq  $0x1
  400e3b:	e9 d0 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e40 <putchar@plt>:
  400e40:	ff 25 e2 f1 20 00    	jmpq   *0x20f1e2(%rip)        # 610028 <_GLOBAL_OFFSET_TABLE_+0x28>
  400e46:	68 02 00 00 00       	pushq  $0x2
  400e4b:	e9 c0 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e50 <localtime@plt>:
  400e50:	ff 25 da f1 20 00    	jmpq   *0x20f1da(%rip)        # 610030 <_GLOBAL_OFFSET_TABLE_+0x30>
  400e56:	68 03 00 00 00       	pushq  $0x3
  400e5b:	e9 b0 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e60 <strncmp@plt>:
  400e60:	ff 25 d2 f1 20 00    	jmpq   *0x20f1d2(%rip)        # 610038 <_GLOBAL_OFFSET_TABLE_+0x38>
  400e66:	68 04 00 00 00       	pushq  $0x4
  400e6b:	e9 a0 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e70 <strcpy@plt>:
  400e70:	ff 25 ca f1 20 00    	jmpq   *0x20f1ca(%rip)        # 610040 <_GLOBAL_OFFSET_TABLE_+0x40>
  400e76:	68 05 00 00 00       	pushq  $0x5
  400e7b:	e9 90 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e80 <__isoc99_fscanf@plt>:
  400e80:	ff 25 c2 f1 20 00    	jmpq   *0x20f1c2(%rip)        # 610048 <_GLOBAL_OFFSET_TABLE_+0x48>
  400e86:	68 06 00 00 00       	pushq  $0x6
  400e8b:	e9 80 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400e90 <puts@plt>:
  400e90:	ff 25 ba f1 20 00    	jmpq   *0x20f1ba(%rip)        # 610050 <_GLOBAL_OFFSET_TABLE_+0x50>
  400e96:	68 07 00 00 00       	pushq  $0x7
  400e9b:	e9 70 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400ea0 <fread@plt>:
  400ea0:	ff 25 b2 f1 20 00    	jmpq   *0x20f1b2(%rip)        # 610058 <_GLOBAL_OFFSET_TABLE_+0x58>
  400ea6:	68 08 00 00 00       	pushq  $0x8
  400eab:	e9 60 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400eb0 <strtod@plt>:
  400eb0:	ff 25 aa f1 20 00    	jmpq   *0x20f1aa(%rip)        # 610060 <_GLOBAL_OFFSET_TABLE_+0x60>
  400eb6:	68 09 00 00 00       	pushq  $0x9
  400ebb:	e9 50 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400ec0 <exp@plt>:
  400ec0:	ff 25 a2 f1 20 00    	jmpq   *0x20f1a2(%rip)        # 610068 <_GLOBAL_OFFSET_TABLE_+0x68>
  400ec6:	68 0a 00 00 00       	pushq  $0xa
  400ecb:	e9 40 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400ed0 <clock@plt>:
  400ed0:	ff 25 9a f1 20 00    	jmpq   *0x20f19a(%rip)        # 610070 <_GLOBAL_OFFSET_TABLE_+0x70>
  400ed6:	68 0b 00 00 00       	pushq  $0xb
  400edb:	e9 30 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400ee0 <fclose@plt>:
  400ee0:	ff 25 92 f1 20 00    	jmpq   *0x20f192(%rip)        # 610078 <_GLOBAL_OFFSET_TABLE_+0x78>
  400ee6:	68 0c 00 00 00       	pushq  $0xc
  400eeb:	e9 20 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400ef0 <strlen@plt>:
  400ef0:	ff 25 8a f1 20 00    	jmpq   *0x20f18a(%rip)        # 610080 <_GLOBAL_OFFSET_TABLE_+0x80>
  400ef6:	68 0d 00 00 00       	pushq  $0xd
  400efb:	e9 10 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f00 <__stack_chk_fail@plt>:
  400f00:	ff 25 82 f1 20 00    	jmpq   *0x20f182(%rip)        # 610088 <_GLOBAL_OFFSET_TABLE_+0x88>
  400f06:	68 0e 00 00 00       	pushq  $0xe
  400f0b:	e9 00 ff ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f10 <asctime@plt>:
  400f10:	ff 25 7a f1 20 00    	jmpq   *0x20f17a(%rip)        # 610090 <_GLOBAL_OFFSET_TABLE_+0x90>
  400f16:	68 0f 00 00 00       	pushq  $0xf
  400f1b:	e9 f0 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f20 <strchr@plt>:
  400f20:	ff 25 72 f1 20 00    	jmpq   *0x20f172(%rip)        # 610098 <_GLOBAL_OFFSET_TABLE_+0x98>
  400f26:	68 10 00 00 00       	pushq  $0x10
  400f2b:	e9 e0 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f30 <pclose@plt>:
  400f30:	ff 25 6a f1 20 00    	jmpq   *0x20f16a(%rip)        # 6100a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
  400f36:	68 11 00 00 00       	pushq  $0x11
  400f3b:	e9 d0 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f40 <fputs@plt>:
  400f40:	ff 25 62 f1 20 00    	jmpq   *0x20f162(%rip)        # 6100a8 <_GLOBAL_OFFSET_TABLE_+0xa8>
  400f46:	68 12 00 00 00       	pushq  $0x12
  400f4b:	e9 c0 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f50 <pow@plt>:
  400f50:	ff 25 5a f1 20 00    	jmpq   *0x20f15a(%rip)        # 6100b0 <_GLOBAL_OFFSET_TABLE_+0xb0>
  400f56:	68 13 00 00 00       	pushq  $0x13
  400f5b:	e9 b0 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f60 <sincos@plt>:
  400f60:	ff 25 52 f1 20 00    	jmpq   *0x20f152(%rip)        # 6100b8 <_GLOBAL_OFFSET_TABLE_+0xb8>
  400f66:	68 14 00 00 00       	pushq  $0x14
  400f6b:	e9 a0 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f70 <cos@plt>:
  400f70:	ff 25 4a f1 20 00    	jmpq   *0x20f14a(%rip)        # 6100c0 <_GLOBAL_OFFSET_TABLE_+0xc0>
  400f76:	68 15 00 00 00       	pushq  $0x15
  400f7b:	e9 90 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f80 <fputc@plt>:
  400f80:	ff 25 42 f1 20 00    	jmpq   *0x20f142(%rip)        # 6100c8 <_GLOBAL_OFFSET_TABLE_+0xc8>
  400f86:	68 16 00 00 00       	pushq  $0x16
  400f8b:	e9 80 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400f90 <__libc_start_main@plt>:
  400f90:	ff 25 3a f1 20 00    	jmpq   *0x20f13a(%rip)        # 6100d0 <_GLOBAL_OFFSET_TABLE_+0xd0>
  400f96:	68 17 00 00 00       	pushq  $0x17
  400f9b:	e9 70 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400fa0 <fgets@plt>:
  400fa0:	ff 25 32 f1 20 00    	jmpq   *0x20f132(%rip)        # 6100d8 <_GLOBAL_OFFSET_TABLE_+0xd8>
  400fa6:	68 18 00 00 00       	pushq  $0x18
  400fab:	e9 60 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400fb0 <strcmp@plt>:
  400fb0:	ff 25 2a f1 20 00    	jmpq   *0x20f12a(%rip)        # 6100e0 <_GLOBAL_OFFSET_TABLE_+0xe0>
  400fb6:	68 19 00 00 00       	pushq  $0x19
  400fbb:	e9 50 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400fc0 <strtol@plt>:
  400fc0:	ff 25 22 f1 20 00    	jmpq   *0x20f122(%rip)        # 6100e8 <_GLOBAL_OFFSET_TABLE_+0xe8>
  400fc6:	68 1a 00 00 00       	pushq  $0x1a
  400fcb:	e9 40 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400fd0 <time@plt>:
  400fd0:	ff 25 1a f1 20 00    	jmpq   *0x20f11a(%rip)        # 6100f0 <_GLOBAL_OFFSET_TABLE_+0xf0>
  400fd6:	68 1b 00 00 00       	pushq  $0x1b
  400fdb:	e9 30 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400fe0 <malloc@plt>:
  400fe0:	ff 25 12 f1 20 00    	jmpq   *0x20f112(%rip)        # 6100f8 <_GLOBAL_OFFSET_TABLE_+0xf8>
  400fe6:	68 1c 00 00 00       	pushq  $0x1c
  400feb:	e9 20 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000400ff0 <fseek@plt>:
  400ff0:	ff 25 0a f1 20 00    	jmpq   *0x20f10a(%rip)        # 610100 <_GLOBAL_OFFSET_TABLE_+0x100>
  400ff6:	68 1d 00 00 00       	pushq  $0x1d
  400ffb:	e9 10 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000401000 <__strcpy_chk@plt>:
  401000:	ff 25 02 f1 20 00    	jmpq   *0x20f102(%rip)        # 610108 <_GLOBAL_OFFSET_TABLE_+0x108>
  401006:	68 1e 00 00 00       	pushq  $0x1e
  40100b:	e9 00 fe ff ff       	jmpq   400e10 <_init+0x20>

0000000000401010 <__printf_chk@plt>:
  401010:	ff 25 fa f0 20 00    	jmpq   *0x20f0fa(%rip)        # 610110 <_GLOBAL_OFFSET_TABLE_+0x110>
  401016:	68 1f 00 00 00       	pushq  $0x1f
  40101b:	e9 f0 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401020 <memmove@plt>:
  401020:	ff 25 f2 f0 20 00    	jmpq   *0x20f0f2(%rip)        # 610118 <_GLOBAL_OFFSET_TABLE_+0x118>
  401026:	68 20 00 00 00       	pushq  $0x20
  40102b:	e9 e0 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401030 <popen@plt>:
  401030:	ff 25 ea f0 20 00    	jmpq   *0x20f0ea(%rip)        # 610120 <_GLOBAL_OFFSET_TABLE_+0x120>
  401036:	68 21 00 00 00       	pushq  $0x21
  40103b:	e9 d0 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401040 <fopen@plt>:
  401040:	ff 25 e2 f0 20 00    	jmpq   *0x20f0e2(%rip)        # 610128 <_GLOBAL_OFFSET_TABLE_+0x128>
  401046:	68 22 00 00 00       	pushq  $0x22
  40104b:	e9 c0 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401050 <sin@plt>:
  401050:	ff 25 da f0 20 00    	jmpq   *0x20f0da(%rip)        # 610130 <_GLOBAL_OFFSET_TABLE_+0x130>
  401056:	68 23 00 00 00       	pushq  $0x23
  40105b:	e9 b0 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401060 <exit@plt>:
  401060:	ff 25 d2 f0 20 00    	jmpq   *0x20f0d2(%rip)        # 610138 <_GLOBAL_OFFSET_TABLE_+0x138>
  401066:	68 24 00 00 00       	pushq  $0x24
  40106b:	e9 a0 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401070 <fwrite@plt>:
  401070:	ff 25 ca f0 20 00    	jmpq   *0x20f0ca(%rip)        # 610140 <_GLOBAL_OFFSET_TABLE_+0x140>
  401076:	68 25 00 00 00       	pushq  $0x25
  40107b:	e9 90 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401080 <__fprintf_chk@plt>:
  401080:	ff 25 c2 f0 20 00    	jmpq   *0x20f0c2(%rip)        # 610148 <_GLOBAL_OFFSET_TABLE_+0x148>
  401086:	68 26 00 00 00       	pushq  $0x26
  40108b:	e9 80 fd ff ff       	jmpq   400e10 <_init+0x20>

0000000000401090 <sqrt@plt>:
  401090:	ff 25 ba f0 20 00    	jmpq   *0x20f0ba(%rip)        # 610150 <_GLOBAL_OFFSET_TABLE_+0x150>
  401096:	68 27 00 00 00       	pushq  $0x27
  40109b:	e9 70 fd ff ff       	jmpq   400e10 <_init+0x20>

00000000004010a0 <strstr@plt>:
  4010a0:	ff 25 b2 f0 20 00    	jmpq   *0x20f0b2(%rip)        # 610158 <_GLOBAL_OFFSET_TABLE_+0x158>
  4010a6:	68 28 00 00 00       	pushq  $0x28
  4010ab:	e9 60 fd ff ff       	jmpq   400e10 <_init+0x20>

00000000004010b0 <__sprintf_chk@plt>:
  4010b0:	ff 25 aa f0 20 00    	jmpq   *0x20f0aa(%rip)        # 610160 <_GLOBAL_OFFSET_TABLE_+0x160>
  4010b6:	68 29 00 00 00       	pushq  $0x29
  4010bb:	e9 50 fd ff ff       	jmpq   400e10 <_init+0x20>

Disassembly of section .plt.got:

00000000004010c0 <.plt.got>:
  4010c0:	ff 25 32 ef 20 00    	jmpq   *0x20ef32(%rip)        # 60fff8 <_DYNAMIC+0x1e0>
  4010c6:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

00000000004010d0 <main>:
#ifdef MAC
void main(void)
#else
int main(int argc, char *argv[])
#endif
{
  4010d0:	41 57                	push   %r15
  4010d2:	41 56                	push   %r14
  4010d4:	41 55                	push   %r13
  4010d6:	41 54                	push   %r12
  4010d8:	55                   	push   %rbp
  4010d9:	53                   	push   %rbx
  4010da:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
#endif

/*
** Set global parameters to default.
*/
global_min_ticks=MINIMUM_TICKS;
  4010e1:	48 c7 05 d4 f5 20 00 	movq   $0x3c,0x20f5d4(%rip)        # 6106c0 <global_min_ticks>
  4010e8:	3c 00 00 00 
global_min_seconds=MINIMUM_SECONDS;
  4010ec:	48 c7 05 71 fc 20 00 	movq   $0x5,0x20fc71(%rip)        # 610d68 <global_min_seconds>
  4010f3:	05 00 00 00 
/*
** We presume all tests will be run unless told
** otherwise
*/
for(i=0;i<NUMTESTS;i++)
        tests_to_do[i]=1;
  4010f7:	66 0f 6f 05 b1 cc 00 	movdqa 0xccb1(%rip),%xmm0        # 40ddb0 <jtable.3055+0x1020>
  4010fe:	00 
#ifdef MAC
void main(void)
#else
int main(int argc, char *argv[])
#endif
{
  4010ff:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401106:	00 00 
  401108:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
  40110f:	00 
  401110:	31 c0                	xor    %eax,%eax
#endif

/*
** Handle any command-line arguments.
*/
if(argc>1)
  401112:	83 ff 01             	cmp    $0x1,%edi
#ifdef MAC
void main(void)
#else
int main(int argc, char *argv[])
#endif
{
  401115:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
/*
** Set global parameters to default.
*/
global_min_ticks=MINIMUM_TICKS;
global_min_seconds=MINIMUM_SECONDS;
global_allstats=0;
  40111a:	c7 05 5c fb 20 00 00 	movl   $0x0,0x20fb5c(%rip)        # 610c80 <global_allstats>
  401121:	00 00 00 
global_custrun=0;
  401124:	c7 05 12 f6 20 00 00 	movl   $0x0,0x20f612(%rip)        # 610740 <global_custrun>
  40112b:	00 00 00 
global_align=8;
  40112e:	c7 05 ac fb 20 00 08 	movl   $0x8,0x20fbac(%rip)        # 610ce4 <global_align>
  401135:	00 00 00 
write_to_file=0;
  401138:	c7 05 c6 f6 20 00 00 	movl   $0x0,0x20f6c6(%rip)        # 610808 <write_to_file>
  40113f:	00 00 00 
lx_memindex=(double)1.0;        /* set for geometric mean computations */
lx_intindex=(double)1.0;
lx_fpindex=(double)1.0;
intindex=(double)1.0;
fpindex=(double)1.0;
mem_array_ents=0;               /* Nothing in mem array */
  401142:	c7 05 94 fb 20 00 00 	movl   $0x0,0x20fb94(%rip)        # 610ce0 <mem_array_ents>
  401149:	00 00 00 
/*
** We presume all tests will be run unless told
** otherwise
*/
for(i=0;i<NUMTESTS;i++)
        tests_to_do[i]=1;
  40114c:	0f 29 05 8d f5 20 00 	movaps %xmm0,0x20f58d(%rip)        # 6106e0 <tests_to_do>
  401153:	c7 05 a3 f5 20 00 01 	movl   $0x1,0x20f5a3(%rip)        # 610700 <tests_to_do+0x20>
  40115a:	00 00 00 
  40115d:	c7 05 9d f5 20 00 01 	movl   $0x1,0x20f59d(%rip)        # 610704 <tests_to_do+0x24>
  401164:	00 00 00 
  401167:	0f 29 05 82 f5 20 00 	movaps %xmm0,0x20f582(%rip)        # 6106f0 <tests_to_do+0x10>
** user redefines global_min_secs in the command file.
*/
static void set_request_secs(void)
{

global_numsortstruct.request_secs=global_min_seconds;
  40116e:	48 c7 05 cf fb 20 00 	movq   $0x5,0x20fbcf(%rip)        # 610d48 <global_numsortstruct+0x8>
  401175:	05 00 00 00 
global_strsortstruct.request_secs=global_min_seconds;
  401179:	48 c7 05 a4 f6 20 00 	movq   $0x5,0x20f6a4(%rip)        # 610828 <global_strsortstruct+0x8>
  401180:	05 00 00 00 
global_bitopstruct.request_secs=global_min_seconds;
  401184:	48 c7 05 59 f6 20 00 	movq   $0x5,0x20f659(%rip)        # 6107e8 <global_bitopstruct+0x8>
  40118b:	05 00 00 00 
global_emfloatstruct.request_secs=global_min_seconds;
  40118f:	48 c7 05 6e fb 20 00 	movq   $0x5,0x20fb6e(%rip)        # 610d08 <global_emfloatstruct+0x8>
  401196:	05 00 00 00 
global_fourierstruct.request_secs=global_min_seconds;
  40119a:	48 c7 05 03 fb 20 00 	movq   $0x5,0x20fb03(%rip)        # 610ca8 <global_fourierstruct+0x8>
  4011a1:	05 00 00 00 
global_assignstruct.request_secs=global_min_seconds;
  4011a5:	48 c7 05 b8 f6 20 00 	movq   $0x5,0x20f6b8(%rip)        # 610868 <global_assignstruct+0x8>
  4011ac:	05 00 00 00 
global_ideastruct.request_secs=global_min_seconds;
  4011b0:	48 c7 05 ed f5 20 00 	movq   $0x5,0x20f5ed(%rip)        # 6107a8 <global_ideastruct+0x8>
  4011b7:	05 00 00 00 
global_huffstruct.request_secs=global_min_seconds;
  4011bb:	48 c7 05 a2 f5 20 00 	movq   $0x5,0x20f5a2(%rip)        # 610768 <global_huffstruct+0x8>
  4011c2:	05 00 00 00 
global_nnetstruct.request_secs=global_min_seconds;
  4011c6:	48 c7 05 f7 fa 20 00 	movq   $0x5,0x20faf7(%rip)        # 610cc8 <global_nnetstruct+0x8>
  4011cd:	05 00 00 00 
global_lustruct.request_secs=global_min_seconds;
  4011d1:	48 c7 05 4c f5 20 00 	movq   $0x5,0x20f54c(%rip)        # 610728 <global_lustruct+0x8>
  4011d8:	05 00 00 00 
/*
** Initialize test data structures to default
** values.
*/
set_request_secs();     /* Set all request_secs fields */
global_numsortstruct.adjust=0;
  4011dc:	c7 05 5a fb 20 00 00 	movl   $0x0,0x20fb5a(%rip)        # 610d40 <global_numsortstruct>
  4011e3:	00 00 00 
global_numsortstruct.arraysize=NUMARRAYSIZE;
  4011e6:	48 c7 05 6f fb 20 00 	movq   $0x1faf,0x20fb6f(%rip)        # 610d60 <global_numsortstruct+0x20>
  4011ed:	af 1f 00 00 

global_strsortstruct.adjust=0;
  4011f1:	c7 05 25 f6 20 00 00 	movl   $0x0,0x20f625(%rip)        # 610820 <global_strsortstruct>
  4011f8:	00 00 00 
global_strsortstruct.arraysize=STRINGARRAYSIZE;
  4011fb:	48 c7 05 3a f6 20 00 	movq   $0x1faf,0x20f63a(%rip)        # 610840 <global_strsortstruct+0x20>
  401202:	af 1f 00 00 

global_bitopstruct.adjust=0;
  401206:	c7 05 d0 f5 20 00 00 	movl   $0x0,0x20f5d0(%rip)        # 6107e0 <global_bitopstruct>
  40120d:	00 00 00 
global_bitopstruct.bitfieldarraysize=BITFARRAYSIZE;
  401210:	48 c7 05 e5 f5 20 00 	movq   $0x4000,0x20f5e5(%rip)        # 610800 <global_bitopstruct+0x20>
  401217:	00 40 00 00 

global_emfloatstruct.adjust=0;
  40121b:	c7 05 db fa 20 00 00 	movl   $0x0,0x20fadb(%rip)        # 610d00 <global_emfloatstruct>
  401222:	00 00 00 
global_emfloatstruct.arraysize=EMFARRAYSIZE;
  401225:	48 c7 05 e0 fa 20 00 	movq   $0xbb8,0x20fae0(%rip)        # 610d10 <global_emfloatstruct+0x10>
  40122c:	b8 0b 00 00 

global_fourierstruct.adjust=0;
  401230:	c7 05 66 fa 20 00 00 	movl   $0x0,0x20fa66(%rip)        # 610ca0 <global_fourierstruct>
  401237:	00 00 00 

global_assignstruct.adjust=0;
  40123a:	c7 05 1c f6 20 00 00 	movl   $0x0,0x20f61c(%rip)        # 610860 <global_assignstruct>
  401241:	00 00 00 

global_ideastruct.adjust=0;
  401244:	c7 05 52 f5 20 00 00 	movl   $0x0,0x20f552(%rip)        # 6107a0 <global_ideastruct>
  40124b:	00 00 00 
global_ideastruct.arraysize=IDEAARRAYSIZE;
  40124e:	48 c7 05 57 f5 20 00 	movq   $0xfa0,0x20f557(%rip)        # 6107b0 <global_ideastruct+0x10>
  401255:	a0 0f 00 00 

global_huffstruct.adjust=0;
  401259:	c7 05 fd f4 20 00 00 	movl   $0x0,0x20f4fd(%rip)        # 610760 <global_huffstruct>
  401260:	00 00 00 
global_huffstruct.arraysize=HUFFARRAYSIZE;
  401263:	48 c7 05 02 f5 20 00 	movq   $0x1388,0x20f502(%rip)        # 610770 <global_huffstruct+0x10>
  40126a:	88 13 00 00 

global_nnetstruct.adjust=0;
  40126e:	c7 05 48 fa 20 00 00 	movl   $0x0,0x20fa48(%rip)        # 610cc0 <global_nnetstruct>
  401275:	00 00 00 

global_lustruct.adjust=0;
  401278:	c7 05 9e f4 20 00 00 	movl   $0x0,0x20f49e(%rip)        # 610720 <global_lustruct>
  40127f:	00 00 00 
#endif

/*
** Handle any command-line arguments.
*/
if(argc>1)
  401282:	0f 8e a4 00 00 00    	jle    40132c <main+0x25c>
  401288:	48 89 f0             	mov    %rsi,%rax
  40128b:	48 8d 6c 24 50       	lea    0x50(%rsp),%rbp
  401290:	48 83 c0 08          	add    $0x8,%rax
  401294:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  401299:	8d 47 fe             	lea    -0x2(%rdi),%eax
  40129c:	48 8d 44 c6 10       	lea    0x10(%rsi,%rax,8),%rax
  4012a1:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  4012a6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  4012ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        for(i=1;i<argc;i++)
                if(parse_arg(argv[i])==-1)
  4012b0:	4c 8b 20             	mov    (%rax),%r12
FILE *cfile;    /* Command file identifier */

/*
** First character has got to be a hyphen.
*/
if(*argptr++!='-') return(-1);
  4012b3:	41 80 3c 24 2d       	cmpb   $0x2d,(%r12)
  4012b8:	4d 8d 7c 24 01       	lea    0x1(%r12),%r15
  4012bd:	0f 85 d5 02 00 00    	jne    401598 <main+0x4c8>
  4012c3:	45 31 f6             	xor    %r14d,%r14d
  4012c6:	eb 21                	jmp    4012e9 <main+0x219>
  4012c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4012cf:	00 
/*
** Convert the rest of the argument to upper case
** so there's little chance of confusion.
*/
for(i=0;i<strlen(argptr);i++)
        argptr[i]=(char)toupper((int)argptr[i]);
  4012d0:	4b 0f be 5c 34 01    	movsbq 0x1(%r12,%r14,1),%rbx
}

__extern_inline int
__NTH (toupper (int __c))
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
  4012d6:	e8 45 fb ff ff       	callq  400e20 <__ctype_toupper_loc@plt>
  4012db:	48 8b 00             	mov    (%rax),%rax
  4012de:	8b 04 98             	mov    (%rax,%rbx,4),%eax
  4012e1:	43 88 44 34 01       	mov    %al,0x1(%r12,%r14,1)
  4012e6:	4d 89 ee             	mov    %r13,%r14

/*
** Convert the rest of the argument to upper case
** so there's little chance of confusion.
*/
for(i=0;i<strlen(argptr);i++)
  4012e9:	4c 89 ff             	mov    %r15,%rdi
  4012ec:	4d 8d 6e 01          	lea    0x1(%r14),%r13
  4012f0:	e8 fb fb ff ff       	callq  400ef0 <strlen@plt>
  4012f5:	4c 39 f0             	cmp    %r14,%rax
  4012f8:	77 d6                	ja     4012d0 <main+0x200>
        argptr[i]=(char)toupper((int)argptr[i]);

/*
** Next character picks the action.
*/
switch(*argptr++)
  4012fa:	41 0f b6 44 24 01    	movzbl 0x1(%r12),%eax
  401300:	3c 43                	cmp    $0x43,%al
  401302:	0f 84 c8 02 00 00    	je     4015d0 <main+0x500>
  401308:	3c 56                	cmp    $0x56,%al
  40130a:	0f 85 88 02 00 00    	jne    401598 <main+0x4c8>
{
        case '?':       return(-1);     /* Will display help */

        case 'V': global_allstats=1; return(0); /* verbose mode */
  401310:	c7 05 66 f9 20 00 01 	movl   $0x1,0x20f966(%rip)        # 610c80 <global_allstats>
  401317:	00 00 00 
  40131a:	48 83 44 24 08 08    	addq   $0x8,0x8(%rsp)
  401320:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

/*
** Handle any command-line arguments.
*/
if(argc>1)
        for(i=1;i<argc;i++)
  401325:	48 3b 44 24 18       	cmp    0x18(%rsp),%rax
  40132a:	75 84                	jne    4012b0 <main+0x1e0>
                }
/*
** Output header
*/
#ifdef LINUX
output_string("\nBYTEmark* Native Mode Benchmark ver. 2 (10/95)\n");
  40132c:	bf 10 d3 40 00       	mov    $0x40d310,%edi
  401331:	e8 0a 35 00 00       	callq  404840 <output_string>
output_string("Index-split by Andrew D. Balsa (11/97)\n");
  401336:	bf 48 d3 40 00       	mov    $0x40d348,%edi
  40133b:	e8 00 35 00 00       	callq  404840 <output_string>
output_string("Linux/Unix* port by Uwe F. Mayer (12/96,11/97)\n");
  401340:	bf 70 d3 40 00       	mov    $0x40d370,%edi
  401345:	e8 f6 34 00 00       	callq  404840 <output_string>
#endif
/*
** See if the user wants all stats.  Output heading info
** if so.
*/
if(global_allstats)
  40134a:	83 3d 2f f9 20 00 00 	cmpl   $0x0,0x20f92f(%rip)        # 610c80 <global_allstats>
  401351:	0f 85 82 0b 00 00    	jne    401ed9 <main+0xe09>

/*
** Execute the tests.
*/
#ifdef LINUX
output_string("\nTEST                : Iterations/sec.  : Old Index   : New Index\n");
  401357:	bf b0 d5 40 00       	mov    $0x40d5b0,%edi
output_string("                    :                  : Pentium 90* : AMD K6/233*\n");
output_string("--------------------:------------------:-------------:------------\n");
  40135c:	31 db                	xor    %ebx,%ebx

/*
** Execute the tests.
*/
#ifdef LINUX
output_string("\nTEST                : Iterations/sec.  : Old Index   : New Index\n");
  40135e:	e8 dd 34 00 00       	callq  404840 <output_string>
output_string("                    :                  : Pentium 90* : AMD K6/233*\n");
  401363:	bf f8 d5 40 00       	mov    $0x40d5f8,%edi
  401368:	e8 d3 34 00 00       	callq  404840 <output_string>
output_string("--------------------:------------------:-------------:------------\n");
  40136d:	bf 40 d6 40 00       	mov    $0x40d640,%edi
  401372:	e8 c9 34 00 00       	callq  404840 <output_string>
write_to_file=0;
lx_memindex=(double)1.0;        /* set for geometric mean computations */
lx_intindex=(double)1.0;
lx_fpindex=(double)1.0;
intindex=(double)1.0;
fpindex=(double)1.0;
  401377:	f2 0f 10 1d f1 c9 00 	movsd  0xc9f1(%rip),%xmm3        # 40dd70 <jtable.3055+0xfe0>
  40137e:	00 
  40137f:	f2 0f 11 5c 24 18    	movsd  %xmm3,0x18(%rsp)
global_align=8;
write_to_file=0;
lx_memindex=(double)1.0;        /* set for geometric mean computations */
lx_intindex=(double)1.0;
lx_fpindex=(double)1.0;
intindex=(double)1.0;
  401385:	f2 0f 11 5c 24 10    	movsd  %xmm3,0x10(%rsp)
global_custrun=0;
global_align=8;
write_to_file=0;
lx_memindex=(double)1.0;        /* set for geometric mean computations */
lx_intindex=(double)1.0;
lx_fpindex=(double)1.0;
  40138b:	f2 0f 11 5c 24 08    	movsd  %xmm3,0x8(%rsp)
global_allstats=0;
global_custrun=0;
global_align=8;
write_to_file=0;
lx_memindex=(double)1.0;        /* set for geometric mean computations */
lx_intindex=(double)1.0;
  401391:	f2 0f 11 5c 24 28    	movsd  %xmm3,0x28(%rsp)
global_min_seconds=MINIMUM_SECONDS;
global_allstats=0;
global_custrun=0;
global_align=8;
write_to_file=0;
lx_memindex=(double)1.0;        /* set for geometric mean computations */
  401397:	f2 0f 11 5c 24 20    	movsd  %xmm3,0x20(%rsp)
  40139d:	eb 0f                	jmp    4013ae <main+0x2de>
  40139f:	90                   	nop
  4013a0:	48 83 c3 01          	add    $0x1,%rbx
output_string("\nTEST                : Iterations/sec.  : Old Index   : New Index\n");
output_string("                    :                  : Pentium 90* : AMD K6/233*\n");
output_string("--------------------:------------------:-------------:------------\n");
#endif

for(i=0;i<NUMTESTS;i++)
  4013a4:	48 83 fb 0a          	cmp    $0xa,%rbx
  4013a8:	0f 84 b7 03 00 00    	je     401765 <main+0x695>
{
        if(tests_to_do[i])
  4013ae:	8b 34 9d e0 06 61 00 	mov    0x6106e0(,%rbx,4),%esi
  4013b5:	89 dd                	mov    %ebx,%ebp
  4013b7:	85 f6                	test   %esi,%esi
  4013b9:	74 e5                	je     4013a0 <main+0x2d0>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  4013bb:	4c 8b 04 dd 80 04 61 	mov    0x610480(,%rbx,8),%r8
  4013c2:	00 
  4013c3:	b9 fe cd 40 00       	mov    $0x40cdfe,%ecx
  4013c8:	ba 00 04 00 00       	mov    $0x400,%edx
  4013cd:	be 01 00 00 00       	mov    $0x1,%esi
  4013d2:	bf 80 08 61 00       	mov    $0x610880,%edi
  4013d7:	31 c0                	xor    %eax,%eax
  4013d9:	e8 d2 fc ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4013de:	31 c0                	xor    %eax,%eax
  4013e0:	ba 80 08 61 00       	mov    $0x610880,%edx
  4013e5:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  4013ea:	bf 01 00 00 00       	mov    $0x1,%edi
  4013ef:	e8 1c fc ff ff       	callq  401010 <__printf_chk@plt>
*/
static void output_string(char *buffer)
{

printf("%s",buffer);
if(write_to_file!=0)
  4013f4:	8b 0d 0e f4 20 00    	mov    0x20f40e(%rip),%ecx        # 610808 <write_to_file>
  4013fa:	85 c9                	test   %ecx,%ecx
  4013fc:	74 11                	je     40140f <main+0x33f>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  4013fe:	48 8b 35 43 f4 20 00 	mov    0x20f443(%rip),%rsi        # 610848 <global_ofile>
  401405:	bf 80 08 61 00       	mov    $0x610880,%edi
  40140a:	e8 31 fb ff ff       	callq  400f40 <fputs@plt>
for(i=0;i<NUMTESTS;i++)
{
        if(tests_to_do[i])
        {       sprintf(buffer,"%s    :",ftestnames[i]);
                                output_string(buffer);
                if (0!=bench_with_confidence(i,
  40140f:	48 8d 4c 24 48       	lea    0x48(%rsp),%rcx
  401414:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
  401419:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
  40141e:	89 ef                	mov    %ebp,%edi
  401420:	e8 5b 34 00 00       	callq  404880 <bench_with_confidence>
  401425:	85 c0                	test   %eax,%eax
  401427:	0f 85 dc 04 00 00    	jne    401909 <main+0x839>
		  output_string("\n** WARNING: The current test result is NOT 95 % statistically certain.\n");
		  output_string("** WARNING: The variation among the individual results is too large.\n");
		  output_string("                    :");
		}
#ifdef LINUX
                sprintf(buffer," %15.5g  :  %9.2f  :  %9.2f\n",
  40142d:	f2 0f 10 44 24 38    	movsd  0x38(%rsp),%xmm0

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  401433:	b9 1c ce 40 00       	mov    $0x40ce1c,%ecx
  401438:	ba 00 04 00 00       	mov    $0x400,%edx
  40143d:	be 01 00 00 00       	mov    $0x1,%esi
  401442:	bf 80 08 61 00       	mov    $0x610880,%edi
  401447:	b8 03 00 00 00       	mov    $0x3,%eax
  40144c:	66 0f 28 d0          	movapd %xmm0,%xmm2
  401450:	66 0f 28 c8          	movapd %xmm0,%xmm1
  401454:	f2 0f 5e 14 dd c0 03 	divsd  0x6103c0(,%rbx,8),%xmm2
  40145b:	61 00 
  40145d:	f2 0f 5e 0c dd 20 04 	divsd  0x610420(,%rbx,8),%xmm1
  401464:	61 00 
  401466:	e8 45 fc ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40146b:	ba 80 08 61 00       	mov    $0x610880,%edx
  401470:	31 c0                	xor    %eax,%eax
  401472:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  401477:	bf 01 00 00 00       	mov    $0x1,%edi
  40147c:	e8 8f fb ff ff       	callq  401010 <__printf_chk@plt>
*/
static void output_string(char *buffer)
{

printf("%s",buffer);
if(write_to_file!=0)
  401481:	8b 15 81 f3 20 00    	mov    0x20f381(%rip),%edx        # 610808 <write_to_file>
  401487:	85 d2                	test   %edx,%edx
  401489:	74 11                	je     40149c <main+0x3cc>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40148b:	48 8b 35 b6 f3 20 00 	mov    0x20f3b6(%rip),%rsi        # 610848 <global_ofile>
  401492:	bf 80 08 61 00       	mov    $0x610880,%edi
  401497:	e8 a4 fa ff ff       	callq  400f40 <fputs@plt>
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
		}
		else{
		  /* Integer index */
		  intindex=intindex*(bmean/bindex[i]);
  40149c:	f2 0f 10 44 24 38    	movsd  0x38(%rsp),%xmm0
#endif
                output_string(buffer);
		/*
		** Gather integer or FP indexes
		*/
		if((i==4)||(i==8)||(i==9)){
  4014a2:	8d 43 f8             	lea    -0x8(%rbx),%eax
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
		}
		else{
		  /* Integer index */
		  intindex=intindex*(bmean/bindex[i]);
  4014a5:	66 0f 28 c8          	movapd %xmm0,%xmm1
#endif
                output_string(buffer);
		/*
		** Gather integer or FP indexes
		*/
		if((i==4)||(i==8)||(i==9)){
  4014a9:	83 f8 01             	cmp    $0x1,%eax
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
		}
		else{
		  /* Integer index */
		  intindex=intindex*(bmean/bindex[i]);
  4014ac:	f2 0f 5e 0c dd 20 04 	divsd  0x610420(,%rbx,8),%xmm1
  4014b3:	61 00 
#endif
                output_string(buffer);
		/*
		** Gather integer or FP indexes
		*/
		if((i==4)||(i==8)||(i==9)){
  4014b5:	0f 86 76 02 00 00    	jbe    401731 <main+0x661>
  4014bb:	83 fd 04             	cmp    $0x4,%ebp
  4014be:	0f 84 6d 02 00 00    	je     401731 <main+0x661>
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
		}
		else{
		  /* Integer index */
		  intindex=intindex*(bmean/bindex[i]);
		  if((i==0)||(i==3)||(i==6)||(i==7))
  4014c4:	b8 c9 00 00 00       	mov    $0xc9,%eax
  4014c9:	48 0f a3 e8          	bt     %rbp,%rax
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
		}
		else{
		  /* Integer index */
		  intindex=intindex*(bmean/bindex[i]);
  4014cd:	f2 0f 59 4c 24 10    	mulsd  0x10(%rsp),%xmm1
		  if((i==0)||(i==3)||(i==6)||(i==7))
		    /* Linux integer index */
		    lx_intindex=lx_intindex*(bmean/lx_bindex[i]);
  4014d3:	f2 0f 5e 04 dd c0 03 	divsd  0x6103c0(,%rbx,8),%xmm0
  4014da:	61 00 
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
		}
		else{
		  /* Integer index */
		  intindex=intindex*(bmean/bindex[i]);
  4014dc:	f2 0f 11 4c 24 10    	movsd  %xmm1,0x10(%rsp)
		  if((i==0)||(i==3)||(i==6)||(i==7))
  4014e2:	0f 83 e0 09 00 00    	jae    401ec8 <main+0xdf8>
		    /* Linux integer index */
		    lx_intindex=lx_intindex*(bmean/lx_bindex[i]);
  4014e8:	f2 0f 59 44 24 28    	mulsd  0x28(%rsp),%xmm0
  4014ee:	f2 0f 11 44 24 28    	movsd  %xmm0,0x28(%rsp)
		  else
		    /* Linux memory index */
		    lx_memindex=lx_memindex*(bmean/lx_bindex[i]);
		}

                if(global_allstats)
  4014f4:	8b 05 86 f7 20 00    	mov    0x20f786(%rip),%eax        # 610c80 <global_allstats>
  4014fa:	85 c0                	test   %eax,%eax
  4014fc:	0f 84 9e fe ff ff    	je     4013a0 <main+0x2d0>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  401502:	f2 0f 10 44 24 40    	movsd  0x40(%rsp),%xmm0
  401508:	b9 20 d7 40 00       	mov    $0x40d720,%ecx
  40150d:	ba 00 04 00 00       	mov    $0x400,%edx
  401512:	be 01 00 00 00       	mov    $0x1,%esi
  401517:	bf 80 08 61 00       	mov    $0x610880,%edi
  40151c:	b8 01 00 00 00       	mov    $0x1,%eax
  401521:	e8 8a fb ff ff       	callq  4010b0 <__sprintf_chk@plt>
                {
                        sprintf(buffer,"  Absolute standard deviation: %g\n",bstdev);
                        output_string(buffer);
  401526:	bf 80 08 61 00       	mov    $0x610880,%edi
  40152b:	e8 10 33 00 00       	callq  404840 <output_string>
			if (bmean>(double)1e-100){
  401530:	f2 0f 10 4c 24 38    	movsd  0x38(%rsp),%xmm1
  401536:	66 0f 2e 0d 3a c8 00 	ucomisd 0xc83a(%rip),%xmm1        # 40dd78 <jtable.3055+0xfe8>
  40153d:	00 
  40153e:	0f 87 c0 0a 00 00    	ja     402004 <main+0xf34>
  401544:	4c 8b 44 24 48       	mov    0x48(%rsp),%r8
  401549:	b9 39 ce 40 00       	mov    $0x40ce39,%ecx
  40154e:	ba 00 04 00 00       	mov    $0x400,%edx
  401553:	be 01 00 00 00       	mov    $0x1,%esi
  401558:	bf 80 08 61 00       	mov    $0x610880,%edi
  40155d:	31 c0                	xor    %eax,%eax
*/
static void show_stats (int bid)
{
char buffer[80];        /* Display buffer */

switch(bid)
  40155f:	83 ed 01             	sub    $0x1,%ebp
  401562:	e8 49 fb ff ff       	callq  4010b0 <__sprintf_chk@plt>
			  sprintf(buffer,"  Relative standard deviation: %g %%\n",
				  (double)100*bstdev/bmean);
			  output_string(buffer);
			}
                        sprintf(buffer,"  Number of runs: %lu\n",bnumrun);
                        output_string(buffer);
  401567:	bf 80 08 61 00       	mov    $0x610880,%edi
  40156c:	e8 cf 32 00 00       	callq  404840 <output_string>
*/
static void show_stats (int bid)
{
char buffer[80];        /* Display buffer */

switch(bid)
  401571:	83 fd 08             	cmp    $0x8,%ebp
  401574:	0f 87 b3 0c 00 00    	ja     40222d <main+0x115d>
  40157a:	ff 24 ed d0 db 40 00 	jmpq   *0x40dbd0(,%rbp,8)
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  401581:	4c 89 e2             	mov    %r12,%rdx
  401584:	be e2 cd 40 00       	mov    $0x40cde2,%esi
  401589:	bf 01 00 00 00       	mov    $0x1,%edi
  40158e:	31 c0                	xor    %eax,%eax
  401590:	e8 7b fa ff ff       	callq  401010 <__printf_chk@plt>
  401595:	0f 1f 00             	nopl   (%rax)
  401598:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40159d:	be 74 cf 40 00       	mov    $0x40cf74,%esi
  4015a2:	bf 01 00 00 00       	mov    $0x1,%edi
  4015a7:	48 8b 10             	mov    (%rax),%rdx
  4015aa:	31 c0                	xor    %eax,%eax
  4015ac:	e8 5f fa ff ff       	callq  401010 <__printf_chk@plt>
  4015b1:	bf 8f cf 40 00       	mov    $0x40cf8f,%edi
  4015b6:	e8 d5 f8 ff ff       	callq  400e90 <puts@plt>
  4015bb:	bf 90 d9 40 00       	mov    $0x40d990,%edi
  4015c0:	e8 cb f8 ff ff       	callq  400e90 <puts@plt>
void display_help(char *progname)
{
        printf("Usage: %s [-v] [-c<FILE>]\n",progname);
        printf(" -v = verbose\n");
        printf(" -c = input parameters thru command file <FILE>\n");
        exit(0);
  4015c5:	31 ff                	xor    %edi,%edi
  4015c7:	e8 94 fa ff ff       	callq  401060 <exit@plt>
  4015cc:	0f 1f 40 00          	nopl   0x0(%rax)
        argptr[i]=(char)toupper((int)argptr[i]);

/*
** Next character picks the action.
*/
switch(*argptr++)
  4015d0:	49 83 c4 02          	add    $0x2,%r12

        case 'C':                       /* Command file name */
                /*
                ** First try to open the file for reading.
                */
                cfile=fopen(argptr,"r");
  4015d4:	be 05 e0 40 00       	mov    $0x40e005,%esi
  4015d9:	4c 89 e7             	mov    %r12,%rdi
  4015dc:	e8 5f fa ff ff       	callq  401040 <fopen@plt>
                if(cfile==(FILE *)NULL)
  4015e1:	48 85 c0             	test   %rax,%rax

        case 'C':                       /* Command file name */
                /*
                ** First try to open the file for reading.
                */
                cfile=fopen(argptr,"r");
  4015e4:	49 89 c5             	mov    %rax,%r13
                if(cfile==(FILE *)NULL)
  4015e7:	74 98                	je     401581 <main+0x4b1>
  4015e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
  4015f0:	4c 89 ea             	mov    %r13,%rdx
  4015f3:	be 27 00 00 00       	mov    $0x27,%esi
  4015f8:	48 89 ef             	mov    %rbp,%rdi
  4015fb:	e8 a0 f9 ff ff       	callq  400fa0 <fgets@plt>

/*
** Sit in a big loop, reading a line from the file at each
** pass.  Terminate on EOF.
*/
while(fgets(inbuf,39,cfile)!=(char *)NULL)
  401600:	48 85 c0             	test   %rax,%rax
  401603:	0f 84 ff 00 00 00    	je     401708 <main+0x638>
{
        /* Overwrite the CR character */
        if(strlen(inbuf)>0)
  401609:	80 7c 24 50 00       	cmpb   $0x0,0x50(%rsp)
  40160e:	74 3f                	je     40164f <main+0x57f>
                inbuf[strlen(inbuf)-1]='\0';
  401610:	48 89 ea             	mov    %rbp,%rdx
  401613:	8b 0a                	mov    (%rdx),%ecx
  401615:	48 83 c2 04          	add    $0x4,%rdx
  401619:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40161f:	f7 d1                	not    %ecx
  401621:	21 c8                	and    %ecx,%eax
  401623:	25 80 80 80 80       	and    $0x80808080,%eax
  401628:	74 e9                	je     401613 <main+0x543>
  40162a:	89 c1                	mov    %eax,%ecx
  40162c:	c1 e9 10             	shr    $0x10,%ecx
  40162f:	a9 80 80 00 00       	test   $0x8080,%eax
  401634:	0f 44 c1             	cmove  %ecx,%eax
  401637:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40163b:	48 0f 44 d1          	cmove  %rcx,%rdx
  40163f:	89 c1                	mov    %eax,%ecx
  401641:	00 c1                	add    %al,%cl
  401643:	48 83 da 03          	sbb    $0x3,%rdx
  401647:	48 29 ea             	sub    %rbp,%rdx
  40164a:	c6 44 14 4f 00       	movb   $0x0,0x4f(%rsp,%rdx,1)

        /*
        ** Parse up to the "=" sign.  If we don't find an
        ** "=", then flag an error.
        */
        if((eptr=strchr(inbuf,(int)'='))==(char *)NULL)
  40164f:	be 3d 00 00 00       	mov    $0x3d,%esi
  401654:	48 89 ef             	mov    %rbp,%rdi
  401657:	e8 c4 f8 ff ff       	callq  400f20 <strchr@plt>
  40165c:	48 85 c0             	test   %rax,%rax
  40165f:	49 89 c4             	mov    %rax,%r12
  401662:	0f 84 b0 00 00 00    	je     401718 <main+0x648>
        /*
        ** Insert a null where the "=" was, then convert
        ** the substring to uppercase.  That will enable
        ** us to perform the match.
        */
        *eptr++='\0';
  401668:	48 8d 40 01          	lea    0x1(%rax),%rax
  40166c:	41 c6 04 24 00       	movb   $0x0,(%r12)
  401671:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  401676:	e8 a5 f7 ff ff       	callq  400e20 <__ctype_toupper_loc@plt>
  40167b:	48 8b 18             	mov    (%rax),%rbx
  40167e:	48 0f be 44 24 50    	movsbq 0x50(%rsp),%rax
  401684:	48 89 ea             	mov    %rbp,%rdx
  401687:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40168e:	00 00 
/*
** Oddly enough, the following line did not work under THINK C.
** So, I modified it....hmmmm. --RG
        *s++=(char)toupper((int)*s);
*/
        *s=(char)toupper((int)*s);
  401690:	8b 04 83             	mov    (%rbx,%rax,4),%eax
        s++;
  401693:	48 83 c2 01          	add    $0x1,%rdx
/*
** Oddly enough, the following line did not work under THINK C.
** So, I modified it....hmmmm. --RG
        *s++=(char)toupper((int)*s);
*/
        *s=(char)toupper((int)*s);
  401697:	88 42 ff             	mov    %al,-0x1(%rdx)
        s++;
} while(*s!=(char)'\0');
  40169a:	48 0f be 02          	movsbq (%rdx),%rax
  40169e:	84 c0                	test   %al,%al
  4016a0:	75 ee                	jne    401690 <main+0x5c0>
  4016a2:	41 bf a8 03 61 00    	mov    $0x6103a8,%r15d
  4016a8:	41 be 29 00 00 00    	mov    $0x29,%r14d
  4016ae:	eb 0e                	jmp    4016be <main+0x5ee>
        strtoupper((char *)&inbuf[0]);
        i=MAXPARAM;
        do {
                if(strcmp(inbuf,paramnames[i])==0)
                        break;
        } while(--i>=0);
  4016b0:	41 83 ee 01          	sub    $0x1,%r14d
  4016b4:	49 83 ef 08          	sub    $0x8,%r15
  4016b8:	41 83 fe ff          	cmp    $0xffffffff,%r14d
  4016bc:	74 2a                	je     4016e8 <main+0x618>
        */
        *eptr++='\0';
        strtoupper((char *)&inbuf[0]);
        i=MAXPARAM;
        do {
                if(strcmp(inbuf,paramnames[i])==0)
  4016be:	49 8b 37             	mov    (%r15),%rsi
  4016c1:	48 89 ef             	mov    %rbp,%rdi
  4016c4:	e8 e7 f8 ff ff       	callq  400fb0 <strcmp@plt>
  4016c9:	85 c0                	test   %eax,%eax
  4016cb:	75 e3                	jne    4016b0 <main+0x5e0>

        /*
        ** Advance eptr to the next field...which should be
        ** the value assigned to the parameter.
        */
        switch(i)
  4016cd:	41 83 fe 29          	cmp    $0x29,%r14d
  4016d1:	0f 87 b8 07 00 00    	ja     401e8f <main+0xdbf>
  4016d7:	44 89 f2             	mov    %r14d,%edx
  4016da:	ff 24 d5 18 dc 40 00 	jmpq   *0x40dc18(,%rdx,8)
  4016e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4016e8:	48 89 ea             	mov    %rbp,%rdx
  4016eb:	be 60 d9 40 00       	mov    $0x40d960,%esi
  4016f0:	bf 01 00 00 00       	mov    $0x1,%edi
  4016f5:	31 c0                	xor    %eax,%eax
  4016f7:	e8 14 f9 ff ff       	callq  401010 <__printf_chk@plt>
  4016fc:	e9 ef fe ff ff       	jmpq   4015f0 <main+0x520>
  401701:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                if(cfile==(FILE *)NULL)
                {       printf("**Error opening file: %s\n",argptr);
                        return(-1);
                }
                read_comfile(cfile);    /* Read commands */
                fclose(cfile);
  401708:	4c 89 ef             	mov    %r13,%rdi
  40170b:	e8 d0 f7 ff ff       	callq  400ee0 <fclose@plt>
  401710:	e9 05 fc ff ff       	jmpq   40131a <main+0x24a>
  401715:	0f 1f 00             	nopl   (%rax)
  401718:	48 89 ea             	mov    %rbp,%rdx
  40171b:	be c0 d2 40 00       	mov    $0x40d2c0,%esi
  401720:	bf 01 00 00 00       	mov    $0x1,%edi
  401725:	31 c0                	xor    %eax,%eax
  401727:	e8 e4 f8 ff ff       	callq  401010 <__printf_chk@plt>
  40172c:	e9 bf fe ff ff       	jmpq   4015f0 <main+0x520>
		*/
		if((i==4)||(i==8)||(i==9)){
		  /* FP index */
		  fpindex=fpindex*(bmean/bindex[i]);
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
  401731:	f2 0f 5e 04 dd c0 03 	divsd  0x6103c0(,%rbx,8),%xmm0
  401738:	61 00 
		  else
		    /* Linux memory index */
		    lx_memindex=lx_memindex*(bmean/lx_bindex[i]);
		}

                if(global_allstats)
  40173a:	8b 05 40 f5 20 00    	mov    0x20f540(%rip),%eax        # 610c80 <global_allstats>
  401740:	85 c0                	test   %eax,%eax
		/*
		** Gather integer or FP indexes
		*/
		if((i==4)||(i==8)||(i==9)){
		  /* FP index */
		  fpindex=fpindex*(bmean/bindex[i]);
  401742:	f2 0f 59 4c 24 18    	mulsd  0x18(%rsp),%xmm1
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
  401748:	f2 0f 59 44 24 08    	mulsd  0x8(%rsp),%xmm0
		/*
		** Gather integer or FP indexes
		*/
		if((i==4)||(i==8)||(i==9)){
		  /* FP index */
		  fpindex=fpindex*(bmean/bindex[i]);
  40174e:	f2 0f 11 4c 24 18    	movsd  %xmm1,0x18(%rsp)
		  /* Linux FP index */
		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
  401754:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
		  else
		    /* Linux memory index */
		    lx_memindex=lx_memindex*(bmean/lx_bindex[i]);
		}

                if(global_allstats)
  40175a:	0f 84 40 fc ff ff    	je     4013a0 <main+0x2d0>
  401760:	e9 9d fd ff ff       	jmpq   401502 <main+0x432>
/* printf("...done...\n"); */

/*
** Output the total indexes
*/
if(global_custrun==0)
  401765:	83 3d d4 ef 20 00 00 	cmpl   $0x0,0x20efd4(%rip)        # 610740 <global_custrun>
  40176c:	0f 85 53 fe ff ff    	jne    4015c5 <main+0x4f5>
{
        output_string("==========================ORIGINAL BYTEMARK RESULTS==========================\n");
  401772:	bf 90 d7 40 00       	mov    $0x40d790,%edi

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  401777:	bb 80 08 61 00       	mov    $0x610880,%ebx
  40177c:	e8 bf 30 00 00       	callq  404840 <output_string>
        sprintf(buffer,"INTEGER INDEX       : %.3f\n",
  401781:	f2 0f 10 0d ff c5 00 	movsd  0xc5ff(%rip),%xmm1        # 40dd88 <jtable.3055+0xff8>
  401788:	00 
  401789:	f2 0f 10 44 24 10    	movsd  0x10(%rsp),%xmm0
  40178f:	e8 bc f7 ff ff       	callq  400f50 <pow@plt>
  401794:	b9 08 cf 40 00       	mov    $0x40cf08,%ecx
  401799:	ba 00 04 00 00       	mov    $0x400,%edx
  40179e:	be 01 00 00 00       	mov    $0x1,%esi
  4017a3:	bf 80 08 61 00       	mov    $0x610880,%edi
  4017a8:	b8 01 00 00 00       	mov    $0x1,%eax
  4017ad:	e8 fe f8 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                       pow(intindex,(double).142857));
        output_string(buffer);
  4017b2:	bf 80 08 61 00       	mov    $0x610880,%edi
  4017b7:	e8 84 30 00 00       	callq  404840 <output_string>
        sprintf(buffer,"FLOATING-POINT INDEX: %.3f\n",
  4017bc:	f2 0f 10 0d cc c5 00 	movsd  0xc5cc(%rip),%xmm1        # 40dd90 <jtable.3055+0x1000>
  4017c3:	00 
  4017c4:	f2 0f 10 44 24 18    	movsd  0x18(%rsp),%xmm0
  4017ca:	e8 81 f7 ff ff       	callq  400f50 <pow@plt>
  4017cf:	ba 00 04 00 00       	mov    $0x400,%edx
  4017d4:	b9 24 cf 40 00       	mov    $0x40cf24,%ecx
  4017d9:	be 01 00 00 00       	mov    $0x1,%esi
  4017de:	bf 80 08 61 00       	mov    $0x610880,%edi
  4017e3:	b8 01 00 00 00       	mov    $0x1,%eax
  4017e8:	e8 c3 f8 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                        pow(fpindex,(double).33333));
        output_string(buffer);
  4017ed:	bf 80 08 61 00       	mov    $0x610880,%edi
  4017f2:	e8 49 30 00 00       	callq  404840 <output_string>
        output_string("Baseline (MSDOS*)   : Pentium* 90, 256 KB L2-cache, Watcom* compiler 10.0\n");
  4017f7:	bf e0 d7 40 00       	mov    $0x40d7e0,%edi
  4017fc:	e8 3f 30 00 00       	callq  404840 <output_string>
#ifdef LINUX
        output_string("==============================LINUX DATA BELOW===============================\n");
  401801:	bf 30 d8 40 00       	mov    $0x40d830,%edi
  401806:	e8 35 30 00 00       	callq  404840 <output_string>
	hardware(write_to_file, global_ofile);
  40180b:	48 8b 35 36 f0 20 00 	mov    0x20f036(%rip),%rsi        # 610848 <global_ofile>
  401812:	8b 3d f0 ef 20 00    	mov    0x20eff0(%rip),%edi        # 610808 <write_to_file>
  401818:	e8 23 aa 00 00       	callq  40c240 <hardware>
  40181d:	48 89 df             	mov    %rbx,%rdi
  401820:	be 80 d8 40 00       	mov    $0x40d880,%esi
  401825:	b9 15 00 00 00       	mov    $0x15,%ecx
  40182a:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
sprintf(buffer,"C compiler          : gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12) \n");
output_string(buffer);
  40182c:	48 89 df             	mov    %rbx,%rdi
  40182f:	e8 0c 30 00 00       	callq  404840 <output_string>
  401834:	48 89 df             	mov    %rbx,%rdi
  401837:	be 40 cf 40 00       	mov    $0x40cf40,%esi
  40183c:	b9 06 00 00 00       	mov    $0x6,%ecx
  401841:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
sprintf(buffer,"libc                : \n");
output_string(buffer);
  401843:	48 89 df             	mov    %rbx,%rdi
  401846:	e8 f5 2f 00 00       	callq  404840 <output_string>
#include "sysinfoc.c"
        sprintf(buffer,"MEMORY INDEX        : %.3f\n",
  40184b:	f2 0f 10 0d 45 c5 00 	movsd  0xc545(%rip),%xmm1        # 40dd98 <jtable.3055+0x1008>
  401852:	00 
  401853:	f2 0f 10 44 24 20    	movsd  0x20(%rsp),%xmm0
  401859:	e8 f2 f6 ff ff       	callq  400f50 <pow@plt>
  40185e:	b9 58 cf 40 00       	mov    $0x40cf58,%ecx
  401863:	ba 00 04 00 00       	mov    $0x400,%edx
  401868:	be 01 00 00 00       	mov    $0x1,%esi
  40186d:	48 89 df             	mov    %rbx,%rdi
  401870:	b8 01 00 00 00       	mov    $0x1,%eax
  401875:	e8 36 f8 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                       pow(lx_memindex,(double).3333333333));
        output_string(buffer);
  40187a:	48 89 df             	mov    %rbx,%rdi
  40187d:	e8 be 2f 00 00       	callq  404840 <output_string>
        sprintf(buffer,"INTEGER INDEX       : %.3f\n",
  401882:	f2 0f 10 0d 16 c5 00 	movsd  0xc516(%rip),%xmm1        # 40dda0 <jtable.3055+0x1010>
  401889:	00 
  40188a:	f2 0f 10 44 24 28    	movsd  0x28(%rsp),%xmm0
  401890:	e8 bb f6 ff ff       	callq  400f50 <pow@plt>
  401895:	b9 08 cf 40 00       	mov    $0x40cf08,%ecx
  40189a:	ba 00 04 00 00       	mov    $0x400,%edx
  40189f:	be 01 00 00 00       	mov    $0x1,%esi
  4018a4:	48 89 df             	mov    %rbx,%rdi
  4018a7:	b8 01 00 00 00       	mov    $0x1,%eax
  4018ac:	e8 ff f7 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                       pow(lx_intindex,(double).25));
        output_string(buffer);
  4018b1:	48 89 df             	mov    %rbx,%rdi
  4018b4:	e8 87 2f 00 00       	callq  404840 <output_string>
        sprintf(buffer,"FLOATING-POINT INDEX: %.3f\n",
  4018b9:	f2 0f 10 0d d7 c4 00 	movsd  0xc4d7(%rip),%xmm1        # 40dd98 <jtable.3055+0x1008>
  4018c0:	00 
  4018c1:	f2 0f 10 44 24 08    	movsd  0x8(%rsp),%xmm0
  4018c7:	e8 84 f6 ff ff       	callq  400f50 <pow@plt>
  4018cc:	b9 24 cf 40 00       	mov    $0x40cf24,%ecx
  4018d1:	ba 00 04 00 00       	mov    $0x400,%edx
  4018d6:	be 01 00 00 00       	mov    $0x1,%esi
  4018db:	48 89 df             	mov    %rbx,%rdi
  4018de:	b8 01 00 00 00       	mov    $0x1,%eax
  4018e3:	e8 c8 f7 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                        pow(lx_fpindex,(double).3333333333));
        output_string(buffer);
  4018e8:	48 89 df             	mov    %rbx,%rdi
  4018eb:	e8 50 2f 00 00       	callq  404840 <output_string>
        output_string("Baseline (LINUX)    : AMD K6/233*, 512 KB L2-cache, gcc 2.7.2.3, libc-5.4.38\n");
  4018f0:	bf d8 d8 40 00       	mov    $0x40d8d8,%edi
  4018f5:	e8 46 2f 00 00       	callq  404840 <output_string>
#endif
output_string("* Trademarks are property of their respective holder.\n");
  4018fa:	bf 28 d9 40 00       	mov    $0x40d928,%edi
  4018ff:	e8 3c 2f 00 00       	callq  404840 <output_string>
  401904:	e9 bc fc ff ff       	jmpq   4015c5 <main+0x4f5>
                                output_string(buffer);
                if (0!=bench_with_confidence(i,
                        &bmean,
                        &bstdev,
                        &bnumrun)){
		  output_string("\n** WARNING: The current test result is NOT 95 % statistically certain.\n");
  401909:	bf 88 d6 40 00       	mov    $0x40d688,%edi
  40190e:	e8 2d 2f 00 00       	callq  404840 <output_string>
		  output_string("** WARNING: The variation among the individual results is too large.\n");
  401913:	bf d8 d6 40 00       	mov    $0x40d6d8,%edi
  401918:	e8 23 2f 00 00       	callq  404840 <output_string>
		  output_string("                    :");
  40191d:	bf 06 ce 40 00       	mov    $0x40ce06,%edi
  401922:	e8 19 2f 00 00       	callq  404840 <output_string>
  401927:	e9 01 fb ff ff       	jmpq   40142d <main+0x35d>
  return (int) strtol (__nptr, (char **) NULL, 10);
}
__extern_inline long int
__NTH (atol (const char *__nptr))
{
  return strtol (__nptr, (char **) NULL, 10);
  40192c:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401931:	ba 0a 00 00 00       	mov    $0xa,%edx
  401936:	31 f6                	xor    %esi,%esi
  401938:	e8 83 f6 ff ff       	callq  400fc0 <strtol@plt>
                                (ulong)atol(eptr);
                        global_lustruct.adjust=1;
                        break;

                case PF_LUMINS: /* LUMINSECONDS */
                        global_lustruct.request_secs=
  40193d:	48 89 05 e4 ed 20 00 	mov    %rax,0x20ede4(%rip)        # 610728 <global_lustruct+0x8>
  401944:	e9 a7 fc ff ff       	jmpq   4015f0 <main+0x520>
  401949:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  40194e:	ba 0a 00 00 00       	mov    $0xa,%edx
  401953:	31 f6                	xor    %esi,%esi
  401955:	e8 66 f6 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_LUNARRAYS:      /* LUNUMARRAYS */
                        global_lustruct.numarrays=
                                (ulong)atol(eptr);
                        global_lustruct.adjust=1;
  40195a:	c7 05 bc ed 20 00 01 	movl   $0x1,0x20edbc(%rip)        # 610720 <global_lustruct>
  401961:	00 00 00 
                case PF_DOLU:           /* DOLU */
                        tests_to_do[TF_LU]=getflag(eptr);
                        break;

                case PF_LUNARRAYS:      /* LUNUMARRAYS */
                        global_lustruct.numarrays=
  401964:	48 89 05 c5 ed 20 00 	mov    %rax,0x20edc5(%rip)        # 610730 <global_lustruct+0x10>
  40196b:	e9 80 fc ff ff       	jmpq   4015f0 <main+0x520>
  401970:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_nnetstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOLU:           /* DOLU */
                        tests_to_do[TF_LU]=getflag(eptr);
  401976:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  40197a:	0f 94 c0             	sete   %al
  40197d:	0f b6 c0             	movzbl %al,%eax
  401980:	89 05 7e ed 20 00    	mov    %eax,0x20ed7e(%rip)        # 610704 <tests_to_do+0x24>
  401986:	e9 65 fc ff ff       	jmpq   4015f0 <main+0x520>
  40198b:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401990:	ba 0a 00 00 00       	mov    $0xa,%edx
  401995:	31 f6                	xor    %esi,%esi
  401997:	e8 24 f6 ff ff       	callq  400fc0 <strtol@plt>
                                (ulong)atol(eptr);
                        global_nnetstruct.adjust=1;
                        break;

                case PF_NNETMINS:       /* NNETMINSECONDS */
                        global_nnetstruct.request_secs=
  40199c:	48 89 05 25 f3 20 00 	mov    %rax,0x20f325(%rip)        # 610cc8 <global_nnetstruct+0x8>
  4019a3:	e9 48 fc ff ff       	jmpq   4015f0 <main+0x520>
  4019a8:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  4019ad:	ba 0a 00 00 00       	mov    $0xa,%edx
  4019b2:	31 f6                	xor    %esi,%esi
  4019b4:	e8 07 f6 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_NNETLOOPS:      /* NNETLOOPS */
                        global_nnetstruct.loops=
                                (ulong)atol(eptr);
                        global_nnetstruct.adjust=1;
  4019b9:	c7 05 fd f2 20 00 01 	movl   $0x1,0x20f2fd(%rip)        # 610cc0 <global_nnetstruct>
  4019c0:	00 00 00 
                case PF_DONNET: /* DONNET */
                        tests_to_do[TF_NNET]=getflag(eptr);
                        break;

                case PF_NNETLOOPS:      /* NNETLOOPS */
                        global_nnetstruct.loops=
  4019c3:	48 89 05 06 f3 20 00 	mov    %rax,0x20f306(%rip)        # 610cd0 <global_nnetstruct+0x10>
  4019ca:	e9 21 fc ff ff       	jmpq   4015f0 <main+0x520>
  4019cf:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_huffstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DONNET: /* DONNET */
                        tests_to_do[TF_NNET]=getflag(eptr);
  4019d5:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  4019d9:	0f 94 c0             	sete   %al
  4019dc:	0f b6 c0             	movzbl %al,%eax
  4019df:	89 05 1b ed 20 00    	mov    %eax,0x20ed1b(%rip)        # 610700 <tests_to_do+0x20>
  4019e5:	e9 06 fc ff ff       	jmpq   4015f0 <main+0x520>
  4019ea:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  4019ef:	ba 0a 00 00 00       	mov    $0xa,%edx
  4019f4:	31 f6                	xor    %esi,%esi
  4019f6:	e8 c5 f5 ff ff       	callq  400fc0 <strtol@plt>
                                (ulong)atol(eptr);
                        global_huffstruct.adjust=1;
                        break;

                case PF_HUFFMINS:       /* HUFFMINSECONDS */
                        global_huffstruct.request_secs=
  4019fb:	48 89 05 66 ed 20 00 	mov    %rax,0x20ed66(%rip)        # 610768 <global_huffstruct+0x8>
  401a02:	e9 e9 fb ff ff       	jmpq   4015f0 <main+0x520>
  401a07:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401a0c:	ba 0a 00 00 00       	mov    $0xa,%edx
  401a11:	31 f6                	xor    %esi,%esi
  401a13:	e8 a8 f5 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_HUFFLOOPS:      /* HUFFLOOPS */
                        global_huffstruct.loops=
                                (ulong)atol(eptr);
                        global_huffstruct.adjust=1;
  401a18:	c7 05 3e ed 20 00 01 	movl   $0x1,0x20ed3e(%rip)        # 610760 <global_huffstruct>
  401a1f:	00 00 00 
                        global_huffstruct.arraysize=
                                (ulong)atol(eptr);
                        break;

                case PF_HUFFLOOPS:      /* HUFFLOOPS */
                        global_huffstruct.loops=
  401a22:	48 89 05 4f ed 20 00 	mov    %rax,0x20ed4f(%rip)        # 610778 <global_huffstruct+0x18>
  401a29:	e9 c2 fb ff ff       	jmpq   4015f0 <main+0x520>
  401a2e:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401a33:	ba 0a 00 00 00       	mov    $0xa,%edx
  401a38:	31 f6                	xor    %esi,%esi
  401a3a:	e8 81 f5 ff ff       	callq  400fc0 <strtol@plt>
                case PF_DOHUFF: /* DOHUFF */
                        tests_to_do[TF_HUFF]=getflag(eptr);
                        break;

                case PF_HUFFASIZE:      /* HUFFARRAYSIZE */
                        global_huffstruct.arraysize=
  401a3f:	48 89 05 2a ed 20 00 	mov    %rax,0x20ed2a(%rip)        # 610770 <global_huffstruct+0x10>
  401a46:	e9 a5 fb ff ff       	jmpq   4015f0 <main+0x520>
  401a4b:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_ideastruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOHUFF: /* DOHUFF */
                        tests_to_do[TF_HUFF]=getflag(eptr);
  401a51:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401a55:	0f 94 c0             	sete   %al
  401a58:	0f b6 c0             	movzbl %al,%eax
  401a5b:	89 05 9b ec 20 00    	mov    %eax,0x20ec9b(%rip)        # 6106fc <tests_to_do+0x1c>
  401a61:	e9 8a fb ff ff       	jmpq   4015f0 <main+0x520>
  401a66:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401a6b:	ba 0a 00 00 00       	mov    $0xa,%edx
  401a70:	31 f6                	xor    %esi,%esi
  401a72:	e8 49 f5 ff ff       	callq  400fc0 <strtol@plt>
                        global_ideastruct.loops=
                                (ulong)atol(eptr);
                        break;

                case PF_IDEAMINS:       /* IDEAMINSECONDS */
                        global_ideastruct.request_secs=
  401a77:	48 89 05 2a ed 20 00 	mov    %rax,0x20ed2a(%rip)        # 6107a8 <global_ideastruct+0x8>
  401a7e:	e9 6d fb ff ff       	jmpq   4015f0 <main+0x520>
  401a83:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401a88:	ba 0a 00 00 00       	mov    $0xa,%edx
  401a8d:	31 f6                	xor    %esi,%esi
  401a8f:	e8 2c f5 ff ff       	callq  400fc0 <strtol@plt>
                        global_ideastruct.arraysize=
                                (ulong)atol(eptr);
                        break;

                case PF_IDEALOOPS:      /* IDEALOOPS */
                        global_ideastruct.loops=
  401a94:	48 89 05 1d ed 20 00 	mov    %rax,0x20ed1d(%rip)        # 6107b8 <global_ideastruct+0x18>
  401a9b:	e9 50 fb ff ff       	jmpq   4015f0 <main+0x520>
  401aa0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401aa5:	ba 0a 00 00 00       	mov    $0xa,%edx
  401aaa:	31 f6                	xor    %esi,%esi
  401aac:	e8 0f f5 ff ff       	callq  400fc0 <strtol@plt>
                case PF_DOIDEA: /* DOIDEA */
                        tests_to_do[TF_IDEA]=getflag(eptr);
                        break;

                case PF_IDEAASIZE:      /* IDEAARRAYSIZE */
                        global_ideastruct.arraysize=
  401ab1:	48 89 05 f8 ec 20 00 	mov    %rax,0x20ecf8(%rip)        # 6107b0 <global_ideastruct+0x10>
  401ab8:	e9 33 fb ff ff       	jmpq   4015f0 <main+0x520>
  401abd:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_assignstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOIDEA: /* DOIDEA */
                        tests_to_do[TF_IDEA]=getflag(eptr);
  401ac3:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401ac7:	0f 94 c0             	sete   %al
  401aca:	0f b6 c0             	movzbl %al,%eax
  401acd:	89 05 25 ec 20 00    	mov    %eax,0x20ec25(%rip)        # 6106f8 <tests_to_do+0x18>
  401ad3:	e9 18 fb ff ff       	jmpq   4015f0 <main+0x520>
  401ad8:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401add:	ba 0a 00 00 00       	mov    $0xa,%edx
  401ae2:	31 f6                	xor    %esi,%esi
  401ae4:	e8 d7 f4 ff ff       	callq  400fc0 <strtol@plt>
                        global_assignstruct.numarrays=
                                (ulong)atol(eptr);
                        break;

                case PF_ASSIGNMINS:     /* ASSIGNMINSECONDS */
                        global_assignstruct.request_secs=
  401ae9:	48 89 05 78 ed 20 00 	mov    %rax,0x20ed78(%rip)        # 610868 <global_assignstruct+0x8>
  401af0:	e9 fb fa ff ff       	jmpq   4015f0 <main+0x520>
  401af5:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401afa:	ba 0a 00 00 00       	mov    $0xa,%edx
  401aff:	31 f6                	xor    %esi,%esi
  401b01:	e8 ba f4 ff ff       	callq  400fc0 <strtol@plt>
                case PF_DOASSIGN:       /* DOASSIGN */
                        tests_to_do[TF_ASSIGN]=getflag(eptr);
                        break;

                case PF_AARRAYS:        /* ASSIGNARRAYS */
                        global_assignstruct.numarrays=
  401b06:	48 89 05 63 ed 20 00 	mov    %rax,0x20ed63(%rip)        # 610870 <global_assignstruct+0x10>
  401b0d:	e9 de fa ff ff       	jmpq   4015f0 <main+0x520>
  401b12:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_fourierstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOASSIGN:       /* DOASSIGN */
                        tests_to_do[TF_ASSIGN]=getflag(eptr);
  401b18:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401b1c:	0f 94 c0             	sete   %al
  401b1f:	0f b6 c0             	movzbl %al,%eax
  401b22:	89 05 cc eb 20 00    	mov    %eax,0x20ebcc(%rip)        # 6106f4 <tests_to_do+0x14>
  401b28:	e9 c3 fa ff ff       	jmpq   4015f0 <main+0x520>
  401b2d:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401b32:	ba 0a 00 00 00       	mov    $0xa,%edx
  401b37:	31 f6                	xor    %esi,%esi
  401b39:	e8 82 f4 ff ff       	callq  400fc0 <strtol@plt>
                                (ulong)atol(eptr);
                        global_fourierstruct.adjust=1;
                        break;

                case PF_FOURMINS:       /* FOURMINSECONDS */
                        global_fourierstruct.request_secs=
  401b3e:	48 89 05 63 f1 20 00 	mov    %rax,0x20f163(%rip)        # 610ca8 <global_fourierstruct+0x8>
  401b45:	e9 a6 fa ff ff       	jmpq   4015f0 <main+0x520>
  401b4a:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401b4f:	ba 0a 00 00 00       	mov    $0xa,%edx
  401b54:	31 f6                	xor    %esi,%esi
  401b56:	e8 65 f4 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_FOURASIZE:      /* FOURASIZE */
                        global_fourierstruct.arraysize=
                                (ulong)atol(eptr);
                        global_fourierstruct.adjust=1;
  401b5b:	c7 05 3b f1 20 00 01 	movl   $0x1,0x20f13b(%rip)        # 610ca0 <global_fourierstruct>
  401b62:	00 00 00 
                case PF_DOFOUR: /* DOFOUR */
                        tests_to_do[TF_FFPU]=getflag(eptr);
                        break;

                case PF_FOURASIZE:      /* FOURASIZE */
                        global_fourierstruct.arraysize=
  401b65:	48 89 05 44 f1 20 00 	mov    %rax,0x20f144(%rip)        # 610cb0 <global_fourierstruct+0x10>
  401b6c:	e9 7f fa ff ff       	jmpq   4015f0 <main+0x520>
  401b71:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_emfloatstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOFOUR: /* DOFOUR */
                        tests_to_do[TF_FFPU]=getflag(eptr);
  401b77:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401b7b:	0f 94 c0             	sete   %al
  401b7e:	0f b6 c0             	movzbl %al,%eax
  401b81:	89 05 69 eb 20 00    	mov    %eax,0x20eb69(%rip)        # 6106f0 <tests_to_do+0x10>
  401b87:	e9 64 fa ff ff       	jmpq   4015f0 <main+0x520>
  401b8c:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401b91:	ba 0a 00 00 00       	mov    $0xa,%edx
  401b96:	31 f6                	xor    %esi,%esi
  401b98:	e8 23 f4 ff ff       	callq  400fc0 <strtol@plt>
                        global_emfloatstruct.loops=
                                (ulong)atol(eptr);
                        break;

                case PF_EMFMINS:        /* EMFMINSECOND */
                        global_emfloatstruct.request_secs=
  401b9d:	48 89 05 64 f1 20 00 	mov    %rax,0x20f164(%rip)        # 610d08 <global_emfloatstruct+0x8>
  401ba4:	e9 47 fa ff ff       	jmpq   4015f0 <main+0x520>
  401ba9:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401bae:	ba 0a 00 00 00       	mov    $0xa,%edx
  401bb3:	31 f6                	xor    %esi,%esi
  401bb5:	e8 06 f4 ff ff       	callq  400fc0 <strtol@plt>
                        global_emfloatstruct.arraysize=
                                (ulong)atol(eptr);
                        break;

                case PF_EMFLOOPS:       /* EMFLOOPS */
                        global_emfloatstruct.loops=
  401bba:	48 89 05 57 f1 20 00 	mov    %rax,0x20f157(%rip)        # 610d18 <global_emfloatstruct+0x18>
  401bc1:	e9 2a fa ff ff       	jmpq   4015f0 <main+0x520>
  401bc6:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401bcb:	ba 0a 00 00 00       	mov    $0xa,%edx
  401bd0:	31 f6                	xor    %esi,%esi
  401bd2:	e8 e9 f3 ff ff       	callq  400fc0 <strtol@plt>
                case PF_DOEMF:          /* DOEMF */
                        tests_to_do[TF_FPEMU]=getflag(eptr);
                        break;

                case PF_EMFASIZE:       /* EMFARRAYSIZE */
                        global_emfloatstruct.arraysize=
  401bd7:	48 89 05 32 f1 20 00 	mov    %rax,0x20f132(%rip)        # 610d10 <global_emfloatstruct+0x10>
  401bde:	e9 0d fa ff ff       	jmpq   4015f0 <main+0x520>
  401be3:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_bitopstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOEMF:          /* DOEMF */
                        tests_to_do[TF_FPEMU]=getflag(eptr);
  401be9:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401bed:	0f 94 c0             	sete   %al
  401bf0:	0f b6 c0             	movzbl %al,%eax
  401bf3:	89 05 f3 ea 20 00    	mov    %eax,0x20eaf3(%rip)        # 6106ec <tests_to_do+0xc>
  401bf9:	e9 f2 f9 ff ff       	jmpq   4015f0 <main+0x520>
  401bfe:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401c03:	ba 0a 00 00 00       	mov    $0xa,%edx
  401c08:	31 f6                	xor    %esi,%esi
  401c0a:	e8 b1 f3 ff ff       	callq  400fc0 <strtol@plt>
                        global_bitopstruct.bitfieldarraysize=
                                (ulong)atol(eptr);
                        break;

                case PF_BITMINS:        /* BITMINSECONDS */
                        global_bitopstruct.request_secs=
  401c0f:	48 89 05 d2 eb 20 00 	mov    %rax,0x20ebd2(%rip)        # 6107e8 <global_bitopstruct+0x8>
  401c16:	e9 d5 f9 ff ff       	jmpq   4015f0 <main+0x520>
  401c1b:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401c20:	ba 0a 00 00 00       	mov    $0xa,%edx
  401c25:	31 f6                	xor    %esi,%esi
  401c27:	e8 94 f3 ff ff       	callq  400fc0 <strtol@plt>
                                (ulong)atol(eptr);
                        global_bitopstruct.adjust=1;
                        break;

                case PF_BITFSIZE:       /* BITFIELDSIZE */
                        global_bitopstruct.bitfieldarraysize=
  401c2c:	48 89 05 cd eb 20 00 	mov    %rax,0x20ebcd(%rip)        # 610800 <global_bitopstruct+0x20>
  401c33:	e9 b8 f9 ff ff       	jmpq   4015f0 <main+0x520>
  401c38:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401c3d:	ba 0a 00 00 00       	mov    $0xa,%edx
  401c42:	31 f6                	xor    %esi,%esi
  401c44:	e8 77 f3 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_NUMBITOPS:      /* NUMBITOPS */
                        global_bitopstruct.bitoparraysize=
                                (ulong)atol(eptr);
                        global_bitopstruct.adjust=1;
  401c49:	c7 05 8d eb 20 00 01 	movl   $0x1,0x20eb8d(%rip)        # 6107e0 <global_bitopstruct>
  401c50:	00 00 00 
                case PF_DOBITF: /* DOBITFIELD */
                        tests_to_do[TF_BITOP]=getflag(eptr);
                        break;

                case PF_NUMBITOPS:      /* NUMBITOPS */
                        global_bitopstruct.bitoparraysize=
  401c53:	48 89 05 9e eb 20 00 	mov    %rax,0x20eb9e(%rip)        # 6107f8 <global_bitopstruct+0x18>
  401c5a:	e9 91 f9 ff ff       	jmpq   4015f0 <main+0x520>
  401c5f:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_strsortstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOBITF: /* DOBITFIELD */
                        tests_to_do[TF_BITOP]=getflag(eptr);
  401c65:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401c69:	0f 94 c0             	sete   %al
  401c6c:	0f b6 c0             	movzbl %al,%eax
  401c6f:	89 05 73 ea 20 00    	mov    %eax,0x20ea73(%rip)        # 6106e8 <tests_to_do+0x8>
  401c75:	e9 76 f9 ff ff       	jmpq   4015f0 <main+0x520>
  401c7a:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401c7f:	ba 0a 00 00 00       	mov    $0xa,%edx
  401c84:	31 f6                	xor    %esi,%esi
  401c86:	e8 35 f3 ff ff       	callq  400fc0 <strtol@plt>
                                (ushort)atoi(eptr);
                        global_strsortstruct.adjust=1;
                        break;

                case PF_STRMINS:        /* STRMINSECONDS */
                        global_strsortstruct.request_secs=
  401c8b:	48 89 05 96 eb 20 00 	mov    %rax,0x20eb96(%rip)        # 610828 <global_strsortstruct+0x8>
  401c92:	e9 59 f9 ff ff       	jmpq   4015f0 <main+0x520>
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline int
__NTH (atoi (const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
  401c97:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401c9c:	ba 0a 00 00 00       	mov    $0xa,%edx
  401ca1:	31 f6                	xor    %esi,%esi
  401ca3:	e8 18 f3 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_NUMSTRA:        /* NUMSTRARRAYS */
                        global_strsortstruct.numarrays=
                                (ushort)atoi(eptr);
                        global_strsortstruct.adjust=1;
  401ca8:	c7 05 6e eb 20 00 01 	movl   $0x1,0x20eb6e(%rip)        # 610820 <global_strsortstruct>
  401caf:	00 00 00 
                        global_strsortstruct.arraysize=
                                (ulong)atol(eptr);
                        break;

                case PF_NUMSTRA:        /* NUMSTRARRAYS */
                        global_strsortstruct.numarrays=
  401cb2:	66 89 05 7f eb 20 00 	mov    %ax,0x20eb7f(%rip)        # 610838 <global_strsortstruct+0x18>
  401cb9:	e9 32 f9 ff ff       	jmpq   4015f0 <main+0x520>
}
__extern_inline long int
__NTH (atol (const char *__nptr))
{
  return strtol (__nptr, (char **) NULL, 10);
  401cbe:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401cc3:	ba 0a 00 00 00       	mov    $0xa,%edx
  401cc8:	31 f6                	xor    %esi,%esi
  401cca:	e8 f1 f2 ff ff       	callq  400fc0 <strtol@plt>
                case PF_DOSTR:          /* DOSTRINGSORT */
                        tests_to_do[TF_SSORT]=getflag(eptr);
                        break;

                case PF_STRASIZE:       /* STRARRAYSIZE */
                        global_strsortstruct.arraysize=
  401ccf:	48 89 05 6a eb 20 00 	mov    %rax,0x20eb6a(%rip)        # 610840 <global_strsortstruct+0x20>
  401cd6:	e9 15 f9 ff ff       	jmpq   4015f0 <main+0x520>
  401cdb:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_numsortstruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                case PF_DOSTR:          /* DOSTRINGSORT */
                        tests_to_do[TF_SSORT]=getflag(eptr);
  401ce1:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401ce5:	0f 94 c0             	sete   %al
  401ce8:	0f b6 c0             	movzbl %al,%eax
  401ceb:	89 05 f3 e9 20 00    	mov    %eax,0x20e9f3(%rip)        # 6106e4 <tests_to_do+0x4>
  401cf1:	e9 fa f8 ff ff       	jmpq   4015f0 <main+0x520>
  401cf6:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401cfb:	ba 0a 00 00 00       	mov    $0xa,%edx
  401d00:	31 f6                	xor    %esi,%esi
  401d02:	e8 b9 f2 ff ff       	callq  400fc0 <strtol@plt>
                        global_numsortstruct.arraysize=
                                (ulong)atol(eptr);
                        break;

                case PF_NUMMINS:        /* NUMMINSECONDS */
                        global_numsortstruct.request_secs=
  401d07:	48 89 05 3a f0 20 00 	mov    %rax,0x20f03a(%rip)        # 610d48 <global_numsortstruct+0x8>
  401d0e:	e9 dd f8 ff ff       	jmpq   4015f0 <main+0x520>
  401d13:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d18:	ba 0a 00 00 00       	mov    $0xa,%edx
  401d1d:	31 f6                	xor    %esi,%esi
  401d1f:	e8 9c f2 ff ff       	callq  400fc0 <strtol@plt>
                                (ushort)atoi(eptr);
                        global_numsortstruct.adjust=1;
                        break;

                case PF_NUMASIZE:       /* NUMARRAYSIZE */
                        global_numsortstruct.arraysize=
  401d24:	48 89 05 35 f0 20 00 	mov    %rax,0x20f035(%rip)        # 610d60 <global_numsortstruct+0x20>
  401d2b:	e9 c0 f8 ff ff       	jmpq   4015f0 <main+0x520>
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline int
__NTH (atoi (const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
  401d30:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d35:	ba 0a 00 00 00       	mov    $0xa,%edx
  401d3a:	31 f6                	xor    %esi,%esi
  401d3c:	e8 7f f2 ff ff       	callq  400fc0 <strtol@plt>
                        break;

                case PF_NUMNUMA:        /* NUMNUMARRAYS */
                        global_numsortstruct.numarrays=
                                (ushort)atoi(eptr);
                        global_numsortstruct.adjust=1;
  401d41:	c7 05 f5 ef 20 00 01 	movl   $0x1,0x20eff5(%rip)        # 610d40 <global_numsortstruct>
  401d48:	00 00 00 
                case PF_DONUM:          /* DONUMSORT */
                        tests_to_do[TF_NUMSORT]=getflag(eptr);
                        break;

                case PF_NUMNUMA:        /* NUMNUMARRAYS */
                        global_numsortstruct.numarrays=
  401d4b:	66 89 05 06 f0 20 00 	mov    %ax,0x20f006(%rip)        # 610d58 <global_numsortstruct+0x18>
  401d52:	e9 99 f8 ff ff       	jmpq   4015f0 <main+0x520>
  401d57:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        for(i=0;i<NUMTESTS;i++)
                                tests_to_do[i]=1-global_custrun;
                        break;

                case PF_DONUM:          /* DONUMSORT */
                        tests_to_do[TF_NUMSORT]=getflag(eptr);
  401d5d:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401d61:	0f 94 c0             	sete   %al
  401d64:	0f b6 c0             	movzbl %al,%eax
  401d67:	89 05 73 e9 20 00    	mov    %eax,0x20e973(%rip)        # 6106e0 <tests_to_do>
  401d6d:	e9 7e f8 ff ff       	jmpq   4015f0 <main+0x520>
  401d72:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
*************
** Return 1 if cptr points to "T"; 0 otherwise.
*/
static int getflag(char *cptr)
{
        if(toupper((int)*cptr)=='T') return(1);
  401d78:	31 d2                	xor    %edx,%edx
  401d7a:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
                        break;

                case PF_CUSTOMRUN:      /* CUSTOMRUN */
                        global_custrun=getflag(eptr);
                        for(i=0;i<NUMTESTS;i++)
                                tests_to_do[i]=1-global_custrun;
  401d7e:	b8 01 00 00 00       	mov    $0x1,%eax
*************
** Return 1 if cptr points to "T"; 0 otherwise.
*/
static int getflag(char *cptr)
{
        if(toupper((int)*cptr)=='T') return(1);
  401d83:	0f 94 c2             	sete   %dl
                        break;

                case PF_CUSTOMRUN:      /* CUSTOMRUN */
                        global_custrun=getflag(eptr);
                        for(i=0;i<NUMTESTS;i++)
                                tests_to_do[i]=1-global_custrun;
  401d86:	29 d0                	sub    %edx,%eax
                        }
                        write_to_file=-1;
                        break;

                case PF_CUSTOMRUN:      /* CUSTOMRUN */
                        global_custrun=getflag(eptr);
  401d88:	89 15 b2 e9 20 00    	mov    %edx,0x20e9b2(%rip)        # 610740 <global_custrun>
                        for(i=0;i<NUMTESTS;i++)
                                tests_to_do[i]=1-global_custrun;
  401d8e:	89 05 4c e9 20 00    	mov    %eax,0x20e94c(%rip)        # 6106e0 <tests_to_do>
  401d94:	89 05 4a e9 20 00    	mov    %eax,0x20e94a(%rip)        # 6106e4 <tests_to_do+0x4>
  401d9a:	89 05 48 e9 20 00    	mov    %eax,0x20e948(%rip)        # 6106e8 <tests_to_do+0x8>
  401da0:	89 05 46 e9 20 00    	mov    %eax,0x20e946(%rip)        # 6106ec <tests_to_do+0xc>
  401da6:	89 05 44 e9 20 00    	mov    %eax,0x20e944(%rip)        # 6106f0 <tests_to_do+0x10>
  401dac:	89 05 42 e9 20 00    	mov    %eax,0x20e942(%rip)        # 6106f4 <tests_to_do+0x14>
  401db2:	89 05 40 e9 20 00    	mov    %eax,0x20e940(%rip)        # 6106f8 <tests_to_do+0x18>
  401db8:	89 05 3e e9 20 00    	mov    %eax,0x20e93e(%rip)        # 6106fc <tests_to_do+0x1c>
  401dbe:	89 05 3c e9 20 00    	mov    %eax,0x20e93c(%rip)        # 610700 <tests_to_do+0x20>
  401dc4:	89 05 3a e9 20 00    	mov    %eax,0x20e93a(%rip)        # 610704 <tests_to_do+0x24>
  401dca:	e9 21 f8 ff ff       	jmpq   4015f0 <main+0x520>
#endif

__fortify_function char *
__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  401dcf:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  401dd4:	ba 00 04 00 00       	mov    $0x400,%edx
  401dd9:	bf c0 0e 61 00       	mov    $0x610ec0,%edi
  401dde:	e8 1d f2 ff ff       	callq  401000 <__strcpy_chk@plt>
                        global_allstats=getflag(eptr);
                        break;

                case PF_OUTFILE:        /* OUTFILE */
                        strcpy(global_ofile_name,eptr);
                        global_ofile=fopen(global_ofile_name,"a");
  401de3:	be fc cd 40 00       	mov    $0x40cdfc,%esi
  401de8:	bf c0 0e 61 00       	mov    $0x610ec0,%edi
  401ded:	e8 4e f2 ff ff       	callq  401040 <fopen@plt>
                        /*
                        ** Open the output file.
                        */
                        if(global_ofile==(FILE *)NULL)
  401df2:	48 85 c0             	test   %rax,%rax
                        global_allstats=getflag(eptr);
                        break;

                case PF_OUTFILE:        /* OUTFILE */
                        strcpy(global_ofile_name,eptr);
                        global_ofile=fopen(global_ofile_name,"a");
  401df5:	48 89 05 4c ea 20 00 	mov    %rax,0x20ea4c(%rip)        # 610848 <global_ofile>
                        /*
                        ** Open the output file.
                        */
                        if(global_ofile==(FILE *)NULL)
  401dfc:	0f 84 73 05 00 00    	je     402375 <main+0x12a5>
                        {       printf("**Error opening output file: %s\n",
                                        global_ofile_name);
                                ErrorExit();
                        }
                        write_to_file=-1;
  401e02:	c7 05 fc e9 20 00 ff 	movl   $0xffffffff,0x20e9fc(%rip)        # 610808 <write_to_file>
  401e09:	ff ff ff 
  401e0c:	e9 df f7 ff ff       	jmpq   4015f0 <main+0x520>
  401e11:	49 0f be 44 24 01    	movsbq 0x1(%r12),%rax
                        global_min_seconds=(ulong)atol(eptr);
                        set_request_secs();
                        break;

                case PF_ALLSTATS:       /* ALLSTATS */
                        global_allstats=getflag(eptr);
  401e17:	83 3c 83 54          	cmpl   $0x54,(%rbx,%rax,4)
  401e1b:	0f 94 c0             	sete   %al
  401e1e:	0f b6 c0             	movzbl %al,%eax
  401e21:	89 05 59 ee 20 00    	mov    %eax,0x20ee59(%rip)        # 610c80 <global_allstats>
  401e27:	e9 c4 f7 ff ff       	jmpq   4015f0 <main+0x520>
}
__extern_inline long int
__NTH (atol (const char *__nptr))
{
  return strtol (__nptr, (char **) NULL, 10);
  401e2c:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401e31:	ba 0a 00 00 00       	mov    $0xa,%edx
  401e36:	31 f6                	xor    %esi,%esi
  401e38:	e8 83 f1 ff ff       	callq  400fc0 <strtol@plt>
                case PF_GMTICKS:        /* GLOBALMINTICKS */
                        global_min_ticks=(ulong)atol(eptr);
                        break;

                case PF_MINSECONDS:     /* MINSECONDS */
                        global_min_seconds=(ulong)atol(eptr);
  401e3d:	48 89 05 24 ef 20 00 	mov    %rax,0x20ef24(%rip)        # 610d68 <global_min_seconds>
** user redefines global_min_secs in the command file.
*/
static void set_request_secs(void)
{

global_numsortstruct.request_secs=global_min_seconds;
  401e44:	48 89 05 fd ee 20 00 	mov    %rax,0x20eefd(%rip)        # 610d48 <global_numsortstruct+0x8>
global_strsortstruct.request_secs=global_min_seconds;
  401e4b:	48 89 05 d6 e9 20 00 	mov    %rax,0x20e9d6(%rip)        # 610828 <global_strsortstruct+0x8>
global_bitopstruct.request_secs=global_min_seconds;
  401e52:	48 89 05 8f e9 20 00 	mov    %rax,0x20e98f(%rip)        # 6107e8 <global_bitopstruct+0x8>
global_emfloatstruct.request_secs=global_min_seconds;
  401e59:	48 89 05 a8 ee 20 00 	mov    %rax,0x20eea8(%rip)        # 610d08 <global_emfloatstruct+0x8>
global_fourierstruct.request_secs=global_min_seconds;
  401e60:	48 89 05 41 ee 20 00 	mov    %rax,0x20ee41(%rip)        # 610ca8 <global_fourierstruct+0x8>
global_assignstruct.request_secs=global_min_seconds;
  401e67:	48 89 05 fa e9 20 00 	mov    %rax,0x20e9fa(%rip)        # 610868 <global_assignstruct+0x8>
global_ideastruct.request_secs=global_min_seconds;
  401e6e:	48 89 05 33 e9 20 00 	mov    %rax,0x20e933(%rip)        # 6107a8 <global_ideastruct+0x8>
global_huffstruct.request_secs=global_min_seconds;
  401e75:	48 89 05 ec e8 20 00 	mov    %rax,0x20e8ec(%rip)        # 610768 <global_huffstruct+0x8>
global_nnetstruct.request_secs=global_min_seconds;
  401e7c:	48 89 05 45 ee 20 00 	mov    %rax,0x20ee45(%rip)        # 610cc8 <global_nnetstruct+0x8>
global_lustruct.request_secs=global_min_seconds;
  401e83:	48 89 05 9e e8 20 00 	mov    %rax,0x20e89e(%rip)        # 610728 <global_lustruct+0x8>
  401e8a:	e9 61 f7 ff ff       	jmpq   4015f0 <main+0x520>
  401e8f:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401e94:	ba 0a 00 00 00       	mov    $0xa,%edx
  401e99:	31 f6                	xor    %esi,%esi
  401e9b:	e8 20 f1 ff ff       	callq  400fc0 <strtol@plt>
        ** the value assigned to the parameter.
        */
        switch(i)
        {
                case PF_GMTICKS:        /* GLOBALMINTICKS */
                        global_min_ticks=(ulong)atol(eptr);
  401ea0:	48 89 05 19 e8 20 00 	mov    %rax,0x20e819(%rip)        # 6106c0 <global_min_ticks>
  401ea7:	e9 44 f7 ff ff       	jmpq   4015f0 <main+0x520>
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline int
__NTH (atoi (const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
  401eac:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401eb1:	ba 0a 00 00 00       	mov    $0xa,%edx
  401eb6:	31 f6                	xor    %esi,%esi
  401eb8:	e8 03 f1 ff ff       	callq  400fc0 <strtol@plt>
                        global_lustruct.request_secs=
                                (ulong)atol(eptr);
                        break;

                                case PF_ALIGN:          /* ALIGN */
                                                global_align=atoi(eptr);
  401ebd:	89 05 21 ee 20 00    	mov    %eax,0x20ee21(%rip)        # 610ce4 <global_align>
  401ec3:	e9 28 f7 ff ff       	jmpq   4015f0 <main+0x520>
		  if((i==0)||(i==3)||(i==6)||(i==7))
		    /* Linux integer index */
		    lx_intindex=lx_intindex*(bmean/lx_bindex[i]);
		  else
		    /* Linux memory index */
		    lx_memindex=lx_memindex*(bmean/lx_bindex[i]);
  401ec8:	f2 0f 59 44 24 20    	mulsd  0x20(%rsp),%xmm0
  401ece:	f2 0f 11 44 24 20    	movsd  %xmm0,0x20(%rsp)
  401ed4:	e9 1b f6 ff ff       	jmpq   4014f4 <main+0x424>
** See if the user wants all stats.  Output heading info
** if so.
*/
if(global_allstats)
{
                output_string("\n");
  401ed9:	bf 06 cf 40 00       	mov    $0x40cf06,%edi
  401ede:	bb 80 08 61 00       	mov    $0x610880,%ebx
  401ee3:	e8 58 29 00 00       	callq  404840 <output_string>
                output_string("============================== ALL STATISTICS ===============================\n");
  401ee8:	bf a0 d3 40 00       	mov    $0x40d3a0,%edi
  401eed:	e8 4e 29 00 00       	callq  404840 <output_string>
        time(&time_and_date);
  401ef2:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  401ef7:	e8 d4 f0 ff ff       	callq  400fd0 <time@plt>
        loctime=localtime(&time_and_date);
  401efc:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  401f01:	e8 4a ef ff ff       	callq  400e50 <localtime@plt>
        sprintf(buffer,"**Date and time of benchmark run: %s",asctime(loctime));
  401f06:	48 89 c7             	mov    %rax,%rdi
  401f09:	e8 02 f0 ff ff       	callq  400f10 <asctime@plt>
  401f0e:	b9 f0 d3 40 00       	mov    $0x40d3f0,%ecx
  401f13:	49 89 c0             	mov    %rax,%r8
  401f16:	ba 00 04 00 00       	mov    $0x400,%edx
  401f1b:	be 01 00 00 00       	mov    $0x1,%esi
  401f20:	bf 80 08 61 00       	mov    $0x610880,%edi
  401f25:	31 c0                	xor    %eax,%eax
  401f27:	e8 84 f1 ff ff       	callq  4010b0 <__sprintf_chk@plt>
        output_string(buffer);
  401f2c:	bf 80 08 61 00       	mov    $0x610880,%edi
  401f31:	e8 0a 29 00 00       	callq  404840 <output_string>
  401f36:	6a 04                	pushq  $0x4
  401f38:	6a 04                	pushq  $0x4
  401f3a:	41 b9 02 00 00 00    	mov    $0x2,%r9d
  401f40:	6a 02                	pushq  $0x2
  401f42:	6a 01                	pushq  $0x1
  401f44:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  401f4a:	6a 08                	pushq  $0x8
  401f4c:	6a 04                	pushq  $0x4
  401f4e:	ba 00 04 00 00       	mov    $0x400,%edx
  401f53:	b9 18 d4 40 00       	mov    $0x40d418,%ecx
  401f58:	be 01 00 00 00       	mov    $0x1,%esi
  401f5d:	bf 80 08 61 00       	mov    $0x610880,%edi
  401f62:	31 c0                	xor    %eax,%eax
  401f64:	e8 47 f1 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                (unsigned int)sizeof(long),
                (unsigned int)sizeof(u8),
                (unsigned int)sizeof(u16),
                (unsigned int)sizeof(u32),
                (unsigned int)sizeof(int32));
        output_string(buffer);
  401f69:	48 83 c4 30          	add    $0x30,%rsp
  401f6d:	bf 80 08 61 00       	mov    $0x610880,%edi
  401f72:	e8 c9 28 00 00       	callq  404840 <output_string>
  401f77:	48 89 df             	mov    %rbx,%rdi
  401f7a:	be 60 d4 40 00       	mov    $0x40d460,%esi
  401f7f:	b9 08 00 00 00       	mov    $0x8,%ecx
  401f84:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
sprintf(buffer,"**System used for compilation:\n");
output_string(buffer);
  401f86:	48 89 df             	mov    %rbx,%rdi
  401f89:	e8 b2 28 00 00       	callq  404840 <output_string>
  401f8e:	48 89 df             	mov    %rbx,%rdi
  401f91:	be 80 d4 40 00       	mov    $0x40d480,%esi
  401f96:	b9 52 00 00 00       	mov    $0x52,%ecx
  401f9b:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
sprintf(buffer,"**Linux ubuntu-xenial 4.4.0-170-generic #199-Ubuntu SMP Thu Nov 14 01:45:04 UTC \n");
output_string(buffer);
  401f9d:	48 89 df             	mov    %rbx,%rdi
  401fa0:	e8 9b 28 00 00       	callq  404840 <output_string>
  401fa5:	48 89 df             	mov    %rbx,%rdi
  401fa8:	be d8 d4 40 00       	mov    $0x40d4d8,%esi
  401fad:	b9 13 00 00 00       	mov    $0x13,%ecx
  401fb2:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
sprintf(buffer,"**C compiler: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12) \n");
output_string(buffer);
  401fb4:	48 89 df             	mov    %rbx,%rdi
  401fb7:	e8 84 28 00 00       	callq  404840 <output_string>
  401fbc:	48 b8 2a 2a 6c 69 62 	movabs $0x203a6362696c2a2a,%rax
  401fc3:	63 3a 20 
sprintf(buffer,"**libc: \n");
output_string(buffer);
  401fc6:	48 89 df             	mov    %rbx,%rdi
  401fc9:	66 c7 05 b6 e8 20 00 	movw   $0xa,0x20e8b6(%rip)        # 610888 <buffer+0x8>
  401fd0:	0a 00 
  401fd2:	48 89 05 a7 e8 20 00 	mov    %rax,0x20e8a7(%rip)        # 610880 <buffer>
  401fd9:	e8 62 28 00 00       	callq  404840 <output_string>
  401fde:	48 89 df             	mov    %rbx,%rdi
  401fe1:	be 28 d5 40 00       	mov    $0x40d528,%esi
  401fe6:	b9 35 00 00 00       	mov    $0x35,%ecx
  401feb:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
sprintf(buffer,"**Date of compilation: Thu Jun 25 23:22:32 UTC 2020\n");
output_string(buffer);
  401fed:	48 89 df             	mov    %rbx,%rdi
  401ff0:	e8 4b 28 00 00       	callq  404840 <output_string>
        sprintf(buffer,"**%s\n",compilername);
        output_string(buffer);
        sprintf(buffer,"**%s\n",compilerversion);
        output_string(buffer);
#endif
                output_string("=============================================================================\n");
  401ff5:	bf 60 d5 40 00       	mov    $0x40d560,%edi
  401ffa:	e8 41 28 00 00       	callq  404840 <output_string>
  401fff:	e9 53 f3 ff ff       	jmpq   401357 <main+0x287>
  402004:	f2 0f 10 05 74 bd 00 	movsd  0xbd74(%rip),%xmm0        # 40dd80 <jtable.3055+0xff0>
  40200b:	00 
  40200c:	b9 48 d7 40 00       	mov    $0x40d748,%ecx
  402011:	ba 00 04 00 00       	mov    $0x400,%edx
  402016:	be 01 00 00 00       	mov    $0x1,%esi
  40201b:	bf 80 08 61 00       	mov    $0x610880,%edi
  402020:	f2 0f 59 44 24 40    	mulsd  0x40(%rsp),%xmm0
  402026:	b8 01 00 00 00       	mov    $0x1,%eax
  40202b:	f2 0f 5e c1          	divsd  %xmm1,%xmm0
  40202f:	e8 7c f0 ff ff       	callq  4010b0 <__sprintf_chk@plt>
                        output_string(buffer);
			if (bmean>(double)1e-100){
			  /* avoid division by zero */
			  sprintf(buffer,"  Relative standard deviation: %g %%\n",
				  (double)100*bstdev/bmean);
			  output_string(buffer);
  402034:	bf 80 08 61 00       	mov    $0x610880,%edi
  402039:	e8 02 28 00 00       	callq  404840 <output_string>
  40203e:	e9 01 f5 ff ff       	jmpq   401544 <main+0x474>
  402043:	4c 8b 05 66 e7 20 00 	mov    0x20e766(%rip),%r8        # 6107b0 <global_ideastruct+0x10>
  40204a:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  40204f:	b9 cd ce 40 00       	mov    $0x40cecd,%ecx
  402054:	ba 50 00 00 00       	mov    $0x50,%edx
  402059:	be 01 00 00 00       	mov    $0x1,%esi
  40205e:	31 c0                	xor    %eax,%eax
  402060:	e8 4b f0 ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  402065:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  40206a:	31 c0                	xor    %eax,%eax
  40206c:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  402071:	bf 01 00 00 00       	mov    $0x1,%edi
  402076:	e8 95 ef ff ff       	callq  401010 <__printf_chk@plt>
*/
static void output_string(char *buffer)
{

printf("%s",buffer);
if(write_to_file!=0)
  40207b:	83 3d 86 e7 20 00 00 	cmpl   $0x0,0x20e786(%rip)        # 610808 <write_to_file>
  402082:	0f 85 d7 02 00 00    	jne    40235f <main+0x128f>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  402088:	4c 8b 05 29 e7 20 00 	mov    0x20e729(%rip),%r8        # 6107b8 <global_ideastruct+0x18>
  40208f:	b9 b6 ce 40 00       	mov    $0x40ceb6,%ecx
  402094:	eb 0c                	jmp    4020a2 <main+0xfd2>
  402096:	4c 8b 05 d3 e7 20 00 	mov    0x20e7d3(%rip),%r8        # 610870 <global_assignstruct+0x10>
  40209d:	b9 e0 ce 40 00       	mov    $0x40cee0,%ecx
  4020a2:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  4020a7:	ba 50 00 00 00       	mov    $0x50,%edx
  4020ac:	be 01 00 00 00       	mov    $0x1,%esi
  4020b1:	31 c0                	xor    %eax,%eax
  4020b3:	e8 f8 ef ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4020b8:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  4020bd:	31 c0                	xor    %eax,%eax
  4020bf:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  4020c4:	bf 01 00 00 00       	mov    $0x1,%edi
  4020c9:	e8 42 ef ff ff       	callq  401010 <__printf_chk@plt>
  4020ce:	83 3d 33 e7 20 00 00 	cmpl   $0x0,0x20e733(%rip)        # 610808 <write_to_file>
  4020d5:	74 11                	je     4020e8 <main+0x1018>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  4020d7:	48 8b 35 6a e7 20 00 	mov    0x20e76a(%rip),%rsi        # 610848 <global_ofile>
  4020de:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  4020e3:	e8 58 ee ff ff       	callq  400f40 <fputs@plt>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  4020e8:	4c 8b 04 dd 80 04 61 	mov    0x610480(,%rbx,8),%r8
  4020ef:	00 
  4020f0:	b9 f9 ce 40 00       	mov    $0x40cef9,%ecx
  4020f5:	ba 00 04 00 00       	mov    $0x400,%edx
  4020fa:	be 01 00 00 00       	mov    $0x1,%esi
  4020ff:	bf 80 08 61 00       	mov    $0x610880,%edi
  402104:	31 c0                	xor    %eax,%eax
  402106:	e8 a5 ef ff ff       	callq  4010b0 <__sprintf_chk@plt>
			}
                        sprintf(buffer,"  Number of runs: %lu\n",bnumrun);
                        output_string(buffer);
                        show_stats(i);
                        sprintf(buffer,"Done with %s\n\n",ftestnames[i]);
                        output_string(buffer);
  40210b:	bf 80 08 61 00       	mov    $0x610880,%edi
  402110:	e8 2b 27 00 00       	callq  404840 <output_string>
  402115:	e9 86 f2 ff ff       	jmpq   4013a0 <main+0x2d0>
  40211a:	4c 8b 05 8f eb 20 00 	mov    0x20eb8f(%rip),%r8        # 610cb0 <global_fourierstruct+0x10>
  402121:	b9 70 d7 40 00       	mov    $0x40d770,%ecx
  402126:	e9 77 ff ff ff       	jmpq   4020a2 <main+0xfd2>
  40212b:	4c 8b 05 e6 eb 20 00 	mov    0x20ebe6(%rip),%r8        # 610d18 <global_emfloatstruct+0x18>
  402132:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  402137:	b9 b5 ce 40 00       	mov    $0x40ceb5,%ecx
  40213c:	ba 50 00 00 00       	mov    $0x50,%edx
  402141:	be 01 00 00 00       	mov    $0x1,%esi
  402146:	31 c0                	xor    %eax,%eax
  402148:	e8 63 ef ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40214d:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  402152:	31 c0                	xor    %eax,%eax
  402154:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  402159:	bf 01 00 00 00       	mov    $0x1,%edi
  40215e:	e8 ad ee ff ff       	callq  401010 <__printf_chk@plt>
*/
static void output_string(char *buffer)
{

printf("%s",buffer);
if(write_to_file!=0)
  402163:	83 3d 9e e6 20 00 00 	cmpl   $0x0,0x20e69e(%rip)        # 610808 <write_to_file>
  40216a:	0f 85 d9 01 00 00    	jne    402349 <main+0x1279>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  402170:	4c 8b 05 99 eb 20 00 	mov    0x20eb99(%rip),%r8        # 610d10 <global_emfloatstruct+0x10>
  402177:	b9 cd ce 40 00       	mov    $0x40cecd,%ecx
  40217c:	e9 21 ff ff ff       	jmpq   4020a2 <main+0xfd2>
  402181:	4c 8b 05 e8 e5 20 00 	mov    0x20e5e8(%rip),%r8        # 610770 <global_huffstruct+0x10>
  402188:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  40218d:	b9 cd ce 40 00       	mov    $0x40cecd,%ecx
  402192:	ba 50 00 00 00       	mov    $0x50,%edx
  402197:	be 01 00 00 00       	mov    $0x1,%esi
  40219c:	31 c0                	xor    %eax,%eax
  40219e:	e8 0d ef ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4021a3:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  4021a8:	31 c0                	xor    %eax,%eax
  4021aa:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  4021af:	bf 01 00 00 00       	mov    $0x1,%edi
  4021b4:	e8 57 ee ff ff       	callq  401010 <__printf_chk@plt>
  4021b9:	83 3d 48 e6 20 00 00 	cmpl   $0x0,0x20e648(%rip)        # 610808 <write_to_file>
  4021c0:	0f 85 6d 01 00 00    	jne    402333 <main+0x1263>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  4021c6:	4c 8b 05 ab e5 20 00 	mov    0x20e5ab(%rip),%r8        # 610778 <global_huffstruct+0x18>
  4021cd:	b9 b5 ce 40 00       	mov    $0x40ceb5,%ecx
  4021d2:	e9 cb fe ff ff       	jmpq   4020a2 <main+0xfd2>
  4021d7:	4c 8b 05 1a e6 20 00 	mov    0x20e61a(%rip),%r8        # 6107f8 <global_bitopstruct+0x18>
  4021de:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  4021e3:	b9 7b ce 40 00       	mov    $0x40ce7b,%ecx
  4021e8:	ba 50 00 00 00       	mov    $0x50,%edx
  4021ed:	be 01 00 00 00       	mov    $0x1,%esi
  4021f2:	31 c0                	xor    %eax,%eax
  4021f4:	e8 b7 ee ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4021f9:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  4021fe:	31 c0                	xor    %eax,%eax
  402200:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  402205:	bf 01 00 00 00       	mov    $0x1,%edi
  40220a:	e8 01 ee ff ff       	callq  401010 <__printf_chk@plt>
  40220f:	83 3d f2 e5 20 00 00 	cmpl   $0x0,0x20e5f2(%rip)        # 610808 <write_to_file>
  402216:	0f 85 01 01 00 00    	jne    40231d <main+0x124d>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  40221c:	4c 8b 05 dd e5 20 00 	mov    0x20e5dd(%rip),%r8        # 610800 <global_bitopstruct+0x20>
  402223:	b9 99 ce 40 00       	mov    $0x40ce99,%ecx
  402228:	e9 75 fe ff ff       	jmpq   4020a2 <main+0xfd2>
  40222d:	44 0f b7 05 23 eb 20 	movzwl 0x20eb23(%rip),%r8d        # 610d58 <global_numsortstruct+0x18>
  402234:	00 
  402235:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  40223a:	b9 50 ce 40 00       	mov    $0x40ce50,%ecx
  40223f:	ba 50 00 00 00       	mov    $0x50,%edx
  402244:	be 01 00 00 00       	mov    $0x1,%esi
  402249:	31 c0                	xor    %eax,%eax
  40224b:	e8 60 ee ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  402250:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  402255:	31 c0                	xor    %eax,%eax
  402257:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40225c:	bf 01 00 00 00       	mov    $0x1,%edi
  402261:	e8 aa ed ff ff       	callq  401010 <__printf_chk@plt>
  402266:	83 3d 9b e5 20 00 00 	cmpl   $0x0,0x20e59b(%rip)        # 610808 <write_to_file>
  40226d:	0f 85 94 00 00 00    	jne    402307 <main+0x1237>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  402273:	4c 8b 05 e6 ea 20 00 	mov    0x20eae6(%rip),%r8        # 610d60 <global_numsortstruct+0x20>
  40227a:	b9 68 ce 40 00       	mov    $0x40ce68,%ecx
  40227f:	e9 1e fe ff ff       	jmpq   4020a2 <main+0xfd2>
  402284:	4c 8b 05 45 ea 20 00 	mov    0x20ea45(%rip),%r8        # 610cd0 <global_nnetstruct+0x10>
  40228b:	b9 b5 ce 40 00       	mov    $0x40ceb5,%ecx
  402290:	e9 0d fe ff ff       	jmpq   4020a2 <main+0xfd2>
  402295:	44 0f b7 05 9b e5 20 	movzwl 0x20e59b(%rip),%r8d        # 610838 <global_strsortstruct+0x18>
  40229c:	00 
  40229d:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  4022a2:	b9 50 ce 40 00       	mov    $0x40ce50,%ecx
  4022a7:	ba 50 00 00 00       	mov    $0x50,%edx
  4022ac:	be 01 00 00 00       	mov    $0x1,%esi
  4022b1:	31 c0                	xor    %eax,%eax
  4022b3:	e8 f8 ed ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4022b8:	48 8d 54 24 50       	lea    0x50(%rsp),%rdx
  4022bd:	31 c0                	xor    %eax,%eax
  4022bf:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  4022c4:	bf 01 00 00 00       	mov    $0x1,%edi
  4022c9:	e8 42 ed ff ff       	callq  401010 <__printf_chk@plt>
  4022ce:	83 3d 33 e5 20 00 00 	cmpl   $0x0,0x20e533(%rip)        # 610808 <write_to_file>
  4022d5:	75 1d                	jne    4022f4 <main+0x1224>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  4022d7:	4c 8b 05 62 e5 20 00 	mov    0x20e562(%rip),%r8        # 610840 <global_strsortstruct+0x20>
  4022de:	b9 68 ce 40 00       	mov    $0x40ce68,%ecx
  4022e3:	e9 ba fd ff ff       	jmpq   4020a2 <main+0xfd2>
  4022e8:	4c 8b 05 41 e4 20 00 	mov    0x20e441(%rip),%r8        # 610730 <global_lustruct+0x10>
  4022ef:	e9 a9 fd ff ff       	jmpq   40209d <main+0xfcd>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  4022f4:	48 8b 35 4d e5 20 00 	mov    0x20e54d(%rip),%rsi        # 610848 <global_ofile>
  4022fb:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  402300:	e8 3b ec ff ff       	callq  400f40 <fputs@plt>
  402305:	eb d0                	jmp    4022d7 <main+0x1207>
  402307:	48 8b 35 3a e5 20 00 	mov    0x20e53a(%rip),%rsi        # 610848 <global_ofile>
  40230e:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  402313:	e8 28 ec ff ff       	callq  400f40 <fputs@plt>
  402318:	e9 56 ff ff ff       	jmpq   402273 <main+0x11a3>
  40231d:	48 8b 35 24 e5 20 00 	mov    0x20e524(%rip),%rsi        # 610848 <global_ofile>
  402324:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  402329:	e8 12 ec ff ff       	callq  400f40 <fputs@plt>
  40232e:	e9 e9 fe ff ff       	jmpq   40221c <main+0x114c>
  402333:	48 8b 35 0e e5 20 00 	mov    0x20e50e(%rip),%rsi        # 610848 <global_ofile>
  40233a:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  40233f:	e8 fc eb ff ff       	callq  400f40 <fputs@plt>
  402344:	e9 7d fe ff ff       	jmpq   4021c6 <main+0x10f6>
  402349:	48 8b 35 f8 e4 20 00 	mov    0x20e4f8(%rip),%rsi        # 610848 <global_ofile>
  402350:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  402355:	e8 e6 eb ff ff       	callq  400f40 <fputs@plt>
  40235a:	e9 11 fe ff ff       	jmpq   402170 <main+0x10a0>
  40235f:	48 8b 35 e2 e4 20 00 	mov    0x20e4e2(%rip),%rsi        # 610848 <global_ofile>
  402366:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
  40236b:	e8 d0 eb ff ff       	callq  400f40 <fputs@plt>
  402370:	e9 13 fd ff ff       	jmpq   402088 <main+0xfb8>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  402375:	ba c0 0e 61 00       	mov    $0x610ec0,%edx
  40237a:	be e8 d2 40 00       	mov    $0x40d2e8,%esi
  40237f:	bf 01 00 00 00       	mov    $0x1,%edi
  402384:	e8 87 ec ff ff       	callq  401010 <__printf_chk@plt>
                        ** Open the output file.
                        */
                        if(global_ofile==(FILE *)NULL)
                        {       printf("**Error opening output file: %s\n",
                                        global_ofile_name);
                                ErrorExit();
  402389:	e8 12 9e 00 00       	callq  40c1a0 <ErrorExit>
  40238e:	e9 6f fa ff ff       	jmpq   401e02 <main+0xd32>
  402393:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40239a:	00 00 00 
  40239d:	0f 1f 00             	nopl   (%rax)

00000000004023a0 <_start>:
  4023a0:	31 ed                	xor    %ebp,%ebp
  4023a2:	49 89 d1             	mov    %rdx,%r9
  4023a5:	5e                   	pop    %rsi
  4023a6:	48 89 e2             	mov    %rsp,%rdx
  4023a9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4023ad:	50                   	push   %rax
  4023ae:	54                   	push   %rsp
  4023af:	49 c7 c0 f0 ca 40 00 	mov    $0x40caf0,%r8
  4023b6:	48 c7 c1 80 ca 40 00 	mov    $0x40ca80,%rcx
  4023bd:	48 c7 c7 d0 10 40 00 	mov    $0x4010d0,%rdi
  4023c4:	e8 c7 eb ff ff       	callq  400f90 <__libc_start_main@plt>
  4023c9:	f4                   	hlt    
  4023ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004023d0 <deregister_tm_clones>:
  4023d0:	b8 9f 06 61 00       	mov    $0x61069f,%eax
  4023d5:	55                   	push   %rbp
  4023d6:	48 2d 98 06 61 00    	sub    $0x610698,%rax
  4023dc:	48 83 f8 0e          	cmp    $0xe,%rax
  4023e0:	48 89 e5             	mov    %rsp,%rbp
  4023e3:	76 1b                	jbe    402400 <deregister_tm_clones+0x30>
  4023e5:	b8 00 00 00 00       	mov    $0x0,%eax
  4023ea:	48 85 c0             	test   %rax,%rax
  4023ed:	74 11                	je     402400 <deregister_tm_clones+0x30>
  4023ef:	5d                   	pop    %rbp
  4023f0:	bf 98 06 61 00       	mov    $0x610698,%edi
  4023f5:	ff e0                	jmpq   *%rax
  4023f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4023fe:	00 00 
  402400:	5d                   	pop    %rbp
  402401:	c3                   	retq   
  402402:	0f 1f 40 00          	nopl   0x0(%rax)
  402406:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40240d:	00 00 00 

0000000000402410 <register_tm_clones>:
  402410:	be 98 06 61 00       	mov    $0x610698,%esi
  402415:	55                   	push   %rbp
  402416:	48 81 ee 98 06 61 00 	sub    $0x610698,%rsi
  40241d:	48 c1 fe 03          	sar    $0x3,%rsi
  402421:	48 89 e5             	mov    %rsp,%rbp
  402424:	48 89 f0             	mov    %rsi,%rax
  402427:	48 c1 e8 3f          	shr    $0x3f,%rax
  40242b:	48 01 c6             	add    %rax,%rsi
  40242e:	48 d1 fe             	sar    %rsi
  402431:	74 15                	je     402448 <register_tm_clones+0x38>
  402433:	b8 00 00 00 00       	mov    $0x0,%eax
  402438:	48 85 c0             	test   %rax,%rax
  40243b:	74 0b                	je     402448 <register_tm_clones+0x38>
  40243d:	5d                   	pop    %rbp
  40243e:	bf 98 06 61 00       	mov    $0x610698,%edi
  402443:	ff e0                	jmpq   *%rax
  402445:	0f 1f 00             	nopl   (%rax)
  402448:	5d                   	pop    %rbp
  402449:	c3                   	retq   
  40244a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000402450 <__do_global_dtors_aux>:
  402450:	80 3d 49 e2 20 00 00 	cmpb   $0x0,0x20e249(%rip)        # 6106a0 <completed.7594>
  402457:	75 11                	jne    40246a <__do_global_dtors_aux+0x1a>
  402459:	55                   	push   %rbp
  40245a:	48 89 e5             	mov    %rsp,%rbp
  40245d:	e8 6e ff ff ff       	callq  4023d0 <deregister_tm_clones>
  402462:	5d                   	pop    %rbp
  402463:	c6 05 36 e2 20 00 01 	movb   $0x1,0x20e236(%rip)        # 6106a0 <completed.7594>
  40246a:	f3 c3                	repz retq 
  40246c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000402470 <frame_dummy>:
  402470:	bf 10 fe 60 00       	mov    $0x60fe10,%edi
  402475:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  402479:	75 05                	jne    402480 <frame_dummy+0x10>
  40247b:	eb 93                	jmp    402410 <register_tm_clones>
  40247d:	0f 1f 00             	nopl   (%rax)
  402480:	b8 00 00 00 00       	mov    $0x0,%eax
  402485:	48 85 c0             	test   %rax,%rax
  402488:	74 f1                	je     40247b <frame_dummy+0xb>
  40248a:	55                   	push   %rbp
  40248b:	48 89 e5             	mov    %rsp,%rbp
  40248e:	ff d0                	callq  *%rax
  402490:	5d                   	pop    %rbp
  402491:	e9 7a ff ff ff       	jmpq   402410 <register_tm_clones>
  402496:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40249d:	00 00 00 

00000000004024a0 <DivideInternalFPF>:
** Divide internal FPF number x by y.  Return result in z.
*/
static void DivideInternalFPF(InternalFPF *x,
                        InternalFPF *y,
                        InternalFPF *z)
{
  4024a0:	41 57                	push   %r15
  4024a2:	41 56                	push   %r14
  4024a4:	48 89 f0             	mov    %rsi,%rax
  4024a7:	41 55                	push   %r13
  4024a9:	41 54                	push   %r12
  4024ab:	55                   	push   %rbp
  4024ac:	53                   	push   %rbx
  4024ad:	48 89 d3             	mov    %rdx,%rbx
  4024b0:	48 83 ec 48          	sub    $0x48,%rsp
/*
** As with preceding function, the following switch
** statement selects among the various possible
** operands.
*/
switch ((x->type * IFPF_TYPE_COUNT) + y->type)
  4024b4:	0f b6 17             	movzbl (%rdi),%edx
** Divide internal FPF number x by y.  Return result in z.
*/
static void DivideInternalFPF(InternalFPF *x,
                        InternalFPF *y,
                        InternalFPF *z)
{
  4024b7:	64 48 8b 34 25 28 00 	mov    %fs:0x28,%rsi
  4024be:	00 00 
  4024c0:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  4024c5:	31 f6                	xor    %esi,%esi
/*
** As with preceding function, the following switch
** statement selects among the various possible
** operands.
*/
switch ((x->type * IFPF_TYPE_COUNT) + y->type)
  4024c7:	8d 0c 92             	lea    (%rdx,%rdx,4),%ecx
  4024ca:	41 89 d0             	mov    %edx,%r8d
  4024cd:	0f b6 10             	movzbl (%rax),%edx
  4024d0:	01 ca                	add    %ecx,%edx
  4024d2:	83 fa 18             	cmp    $0x18,%edx
  4024d5:	0f 87 05 01 00 00    	ja     4025e0 <DivideInternalFPF+0x140>
  4024db:	ff 24 d5 30 cb 40 00 	jmpq   *0x40cb30(,%rdx,8)
  4024e2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}

__fortify_function void *
__NTH (memmove (void *__dest, const void *__src, size_t __len))
{
  return __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
  4024e8:	48 8b 0f             	mov    (%rdi),%rcx
  4024eb:	8b 57 08             	mov    0x8(%rdi),%edx
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  4024ee:	48 89 ce             	mov    %rcx,%rsi
  4024f1:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  4024f6:	48 c1 e9 30          	shr    $0x30,%rcx
  4024fa:	48 c1 ee 20          	shr    $0x20,%rsi
  4024fe:	89 54 24 28          	mov    %edx,0x28(%rsp)
  402502:	49 89 f7             	mov    %rsi,%r15
  402505:	89 d6                	mov    %edx,%esi
  402507:	c1 ea 10             	shr    $0x10,%edx
        memmove((void *)&locx,(void *)x,sizeof(InternalFPF));

        /*
        ** Check for unnormal zero arguments
        */
        if (IsMantissaZero(locx.mantissa))
  40250a:	45 89 f9             	mov    %r15d,%r9d
  40250d:	41 09 c9             	or     %ecx,%r9d
  402510:	41 09 f1             	or     %esi,%r9d
  402513:	66 41 09 d1          	or     %dx,%r9w
  402517:	0f 85 83 02 00 00    	jne    4027a0 <DivideInternalFPF+0x300>
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  40251d:	0f b7 50 06          	movzwl 0x6(%rax),%edx
  402521:	66 0b 50 04          	or     0x4(%rax),%dx
  402525:	66 0b 50 08          	or     0x8(%rax),%dx
        /*
        ** Check for unnormal zero arguments
        */
        if (IsMantissaZero(locx.mantissa))
        {
                if (IsMantissaZero(y->mantissa))
  402529:	66 0b 50 0a          	or     0xa(%rax),%dx
  40252d:	0f 85 0d 05 00 00    	jne    402a40 <DivideInternalFPF+0x5a0>
  402533:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
static void SetInternalFPFNaN(InternalFPF *dest)
{
int i;          /* Index */

dest->type=IFPF_IS_NAN;
dest->exp=MAX_EXP;
  402538:	b9 ff 7f 00 00       	mov    $0x7fff,%ecx
dest->sign=1;
dest->mantissa[0]=0x4000;
  40253d:	be 00 40 00 00       	mov    $0x4000,%esi
for(i=1;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  402542:	31 ff                	xor    %edi,%edi
  402544:	45 31 c0             	xor    %r8d,%r8d
  402547:	45 31 c9             	xor    %r9d,%r9d
*/
static void SetInternalFPFNaN(InternalFPF *dest)
{
int i;          /* Index */

dest->type=IFPF_IS_NAN;
  40254a:	c6 03 04             	movb   $0x4,(%rbx)
dest->exp=MAX_EXP;
  40254d:	66 89 4b 02          	mov    %cx,0x2(%rbx)
dest->sign=1;
  402551:	c6 43 01 01          	movb   $0x1,0x1(%rbx)
dest->mantissa[0]=0x4000;
  402555:	66 89 73 04          	mov    %si,0x4(%rbx)
for(i=1;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  402559:	66 89 7b 06          	mov    %di,0x6(%rbx)
  40255d:	66 44 89 43 08       	mov    %r8w,0x8(%rbx)
  402562:	66 44 89 4b 0a       	mov    %r9w,0xa(%rbx)

/*
** Math complete...do rounding
*/
RoundInternalFPF(z);
}
  402567:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  40256c:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  402573:	00 00 
  402575:	0f 85 4b 05 00 00    	jne    402ac6 <DivideInternalFPF+0x626>
  40257b:	48 83 c4 48          	add    $0x48,%rsp
  40257f:	5b                   	pop    %rbx
  402580:	5d                   	pop    %rbp
  402581:	41 5c                	pop    %r12
  402583:	41 5d                	pop    %r13
  402585:	41 5e                	pop    %r14
  402587:	41 5f                	pop    %r15
  402589:	c3                   	retq   
  40258a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  402590:	0f b7 77 04          	movzwl 0x4(%rdi),%esi
  402594:	66 39 70 04          	cmp    %si,0x4(%rax)
  402598:	0f 82 9a 00 00 00    	jb     402638 <DivideInternalFPF+0x198>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  40259e:	77 30                	ja     4025d0 <DivideInternalFPF+0x130>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4025a0:	0f b7 77 06          	movzwl 0x6(%rdi),%esi
  4025a4:	66 39 70 06          	cmp    %si,0x6(%rax)
  4025a8:	0f 82 8a 00 00 00    	jb     402638 <DivideInternalFPF+0x198>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  4025ae:	77 20                	ja     4025d0 <DivideInternalFPF+0x130>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4025b0:	0f b7 77 08          	movzwl 0x8(%rdi),%esi
  4025b4:	66 39 70 08          	cmp    %si,0x8(%rax)
  4025b8:	72 7e                	jb     402638 <DivideInternalFPF+0x198>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  4025ba:	77 14                	ja     4025d0 <DivideInternalFPF+0x130>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4025bc:	0f b7 70 0a          	movzwl 0xa(%rax),%esi
  4025c0:	66 39 77 0a          	cmp    %si,0xa(%rdi)
  4025c4:	77 72                	ja     402638 <DivideInternalFPF+0x198>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  4025c6:	73 70                	jae    402638 <DivideInternalFPF+0x198>
  4025c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4025cf:	00 
  4025d0:	ba 0c 00 00 00       	mov    $0xc,%edx
  4025d5:	48 89 de             	mov    %rbx,%rsi
  4025d8:	48 89 c7             	mov    %rax,%rdi
  4025db:	e8 40 ea ff ff       	callq  401020 <memmove@plt>
  4025e0:	44 0f b6 03          	movzbl (%rbx),%r8d
*/
void RoundInternalFPF(InternalFPF *ptr)
{
/* int i; */

if (ptr->type == IFPF_IS_NORMAL ||
  4025e4:	41 8d 40 ff          	lea    -0x1(%r8),%eax
  4025e8:	3c 01                	cmp    $0x1,%al
  4025ea:	0f 87 77 ff ff ff    	ja     402567 <DivideInternalFPF+0xc7>
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  4025f0:	0f b7 53 04          	movzwl 0x4(%rbx),%edx
  4025f4:	0f b7 4b 06          	movzwl 0x6(%rbx),%ecx
  4025f8:	0f b7 73 08          	movzwl 0x8(%rbx),%esi
  4025fc:	0f b7 7b 0a          	movzwl 0xa(%rbx),%edi
  402600:	89 d0                	mov    %edx,%eax
  402602:	09 c8                	or     %ecx,%eax
  402604:	09 f0                	or     %esi,%eax
static void denormalize(InternalFPF *ptr,
                int minimum_exponent)
{
long exponent_difference;

if (IsMantissaZero(ptr->mantissa))
  402606:	66 09 f8             	or     %di,%ax
  402609:	0f 84 f1 00 00 00    	je     402700 <DivideInternalFPF+0x260>
{
        printf("Error:  zero significand in denormalize\n");
}

exponent_difference = ptr->exp-minimum_exponent;
if (exponent_difference < 0)
  40260f:	66 81 7b 02 00 80    	cmpw   $0x8000,0x2(%rbx)
  402615:	0f 84 7d 04 00 00    	je     402a98 <DivideInternalFPF+0x5f8>

if (ptr->type == IFPF_IS_NORMAL ||
        ptr->type == IFPF_IS_SUBNORMAL)
{
        denormalize(ptr, MIN_EXP);
        if (ptr->type != IFPF_IS_ZERO)
  40261b:	45 84 c0             	test   %r8b,%r8b
  40261e:	0f 84 43 ff ff ff    	je     402567 <DivideInternalFPF+0xc7>
  402624:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
        {

                /* clear the extraneous bits */
                ptr->mantissa[3] &= 0xfff8;
  402628:	83 e0 f8             	and    $0xfffffff8,%eax
  40262b:	66 89 43 0a          	mov    %ax,0xa(%rbx)

/*
** Math complete...do rounding
*/
RoundInternalFPF(z);
}
  40262f:	e9 33 ff ff ff       	jmpq   402567 <DivideInternalFPF+0xc7>
  402634:	0f 1f 40 00          	nopl   0x0(%rax)
  402638:	ba 0c 00 00 00       	mov    $0xc,%edx
  40263d:	48 89 de             	mov    %rbx,%rsi
  402640:	e8 db e9 ff ff       	callq  401020 <memmove@plt>
  402645:	44 0f b6 03          	movzbl (%rbx),%r8d
  402649:	eb 99                	jmp    4025e4 <DivideInternalFPF+0x144>
  40264b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  402650:	0f b7 50 06          	movzwl 0x6(%rax),%edx
  402654:	66 0b 50 04          	or     0x4(%rax),%dx
  402658:	66 0b 50 08          	or     0x8(%rax),%dx
        SetInternalFPFNaN(z);
        break;

case ZERO_SUBNORMAL:
case ZERO_NORMAL:
        if (IsMantissaZero(y->mantissa))
  40265c:	66 0b 50 0a          	or     0xa(%rax),%dx
  402660:	0f 84 d2 fe ff ff    	je     402538 <DivideInternalFPF+0x98>
        }

case ZERO_INFINITY:
case SUBNORMAL_INFINITY:
case NORMAL_INFINITY:
        SetInternalFPFZero(z, x->sign ^ y->sign);
  402666:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
  40266a:	32 50 01             	xor    0x1(%rax),%dl
static void SetInternalFPFZero(InternalFPF *dest,
                        uchar sign)
{
int i;          /* Index */

dest->type=IFPF_IS_ZERO;
  40266d:	c6 03 00             	movb   $0x0,(%rbx)
dest->sign=sign;
  402670:	88 53 01             	mov    %dl,0x1(%rbx)
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
dest->sign=sign;
dest->exp=MIN_EXP;
  402673:	41 b8 01 80 ff ff    	mov    $0xffff8001,%r8d
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  402679:	45 31 c9             	xor    %r9d,%r9d
  40267c:	45 31 d2             	xor    %r10d,%r10d
  40267f:	45 31 db             	xor    %r11d,%r11d
  402682:	31 ed                	xor    %ebp,%ebp
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
dest->sign=sign;
dest->exp=MIN_EXP;
  402684:	66 44 89 43 02       	mov    %r8w,0x2(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  402689:	66 44 89 4b 04       	mov    %r9w,0x4(%rbx)
  40268e:	66 44 89 53 06       	mov    %r10w,0x6(%rbx)
  402693:	66 44 89 5b 08       	mov    %r11w,0x8(%rbx)
  402698:	66 89 6b 0a          	mov    %bp,0xa(%rbx)
  40269c:	e9 c6 fe ff ff       	jmpq   402567 <DivideInternalFPF+0xc7>
  4026a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  4026a8:	0f b7 57 06          	movzwl 0x6(%rdi),%edx
  4026ac:	66 0b 57 04          	or     0x4(%rdi),%dx
  4026b0:	66 0b 57 08          	or     0x8(%rdi),%dx
        SetInternalFPFZero(z, x->sign ^ y->sign);
        break;

case SUBNORMAL_ZERO:
case NORMAL_ZERO:
        if (IsMantissaZero(x->mantissa))
  4026b4:	66 0b 57 0a          	or     0xa(%rdi),%dx
  4026b8:	0f 84 7a fe ff ff    	je     402538 <DivideInternalFPF+0x98>

dest->type=IFPF_IS_INFINITY;
dest->sign=sign;
dest->exp=MIN_EXP;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  4026be:	31 d2                	xor    %edx,%edx
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
dest->sign=sign;
dest->exp=MIN_EXP;
  4026c0:	41 bc 01 80 ff ff    	mov    $0xffff8001,%r12d
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  4026c6:	45 31 ed             	xor    %r13d,%r13d
  4026c9:	45 31 f6             	xor    %r14d,%r14d
  4026cc:	45 31 ff             	xor    %r15d,%r15d
                        uchar sign)
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
dest->sign=sign;
  4026cf:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
static void SetInternalFPFInfinity(InternalFPF *dest,
                        uchar sign)
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
  4026d3:	c6 03 03             	movb   $0x3,(%rbx)
dest->sign=sign;
dest->exp=MIN_EXP;
  4026d6:	66 44 89 63 02       	mov    %r12w,0x2(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  4026db:	66 44 89 6b 04       	mov    %r13w,0x4(%rbx)
  4026e0:	66 44 89 73 06       	mov    %r14w,0x6(%rbx)
  4026e5:	66 44 89 7b 08       	mov    %r15w,0x8(%rbx)
  4026ea:	66 89 53 0a          	mov    %dx,0xa(%rbx)

case INFINITY_ZERO:
case INFINITY_SUBNORMAL:
case INFINITY_NORMAL:
        SetInternalFPFInfinity(z, 0);
        z->sign = x->sign ^ y->sign;
  4026ee:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
  4026f2:	32 50 01             	xor    0x1(%rax),%dl
  4026f5:	88 53 01             	mov    %dl,0x1(%rbx)
        break;
  4026f8:	e9 6a fe ff ff       	jmpq   402567 <DivideInternalFPF+0xc7>
  4026fd:	0f 1f 00             	nopl   (%rax)
  402700:	bf 08 cb 40 00       	mov    $0x40cb08,%edi
  402705:	e8 86 e7 ff ff       	callq  400e90 <puts@plt>
{
        printf("Error:  zero significand in denormalize\n");
}

exponent_difference = ptr->exp-minimum_exponent;
if (exponent_difference < 0)
  40270a:	66 81 7b 02 00 80    	cmpw   $0x8000,0x2(%rbx)
  402710:	44 0f b6 03          	movzbl (%rbx),%r8d
  402714:	0f 85 01 ff ff ff    	jne    40261b <DivideInternalFPF+0x17b>
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  40271a:	ba 01 80 ff ff       	mov    $0xffff8001,%edx
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  40271f:	45 84 c0             	test   %r8b,%r8b
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  402722:	66 89 53 02          	mov    %dx,0x2(%rbx)
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  402726:	0f 84 3b fe ff ff    	je     402567 <DivideInternalFPF+0xc7>
  40272c:	0f b7 73 08          	movzwl 0x8(%rbx),%esi
  402730:	0f b7 4b 06          	movzwl 0x6(%rbx),%ecx
  402734:	0f b7 7b 0a          	movzwl 0xa(%rbx),%edi
  402738:	0f b7 53 04          	movzwl 0x4(%rbx),%edx
  40273c:	0f 1f 40 00          	nopl   0x0(%rax)
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  402740:	89 d0                	mov    %edx,%eax
  402742:	66 d1 e8             	shr    %ax
  402745:	66 89 43 04          	mov    %ax,0x4(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402749:	89 c8                	mov    %ecx,%eax
  40274b:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  40274e:	41 89 c0             	mov    %eax,%r8d
  402751:	66 41 81 c8 00 80    	or     $0x8000,%r8w
  402757:	83 e2 01             	and    $0x1,%edx
  40275a:	41 0f 45 c0          	cmovne %r8d,%eax
        *carry=new_carry;
        mantissa[i]=accum;
  40275e:	66 89 43 06          	mov    %ax,0x6(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402762:	89 f0                	mov    %esi,%eax
  402764:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  402767:	89 c2                	mov    %eax,%edx
  402769:	66 81 ca 00 80       	or     $0x8000,%dx
  40276e:	83 e1 01             	and    $0x1,%ecx
  402771:	0f 45 c2             	cmovne %edx,%eax
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402774:	89 fa                	mov    %edi,%edx
  402776:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  402779:	66 89 43 08          	mov    %ax,0x8(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  40277d:	89 d0                	mov    %edx,%eax
  40277f:	66 0d 00 80          	or     $0x8000,%ax
  402783:	83 e6 01             	and    $0x1,%esi
  402786:	0f 45 d0             	cmovne %eax,%edx
        else
                for(i=0;i<amount;i++)
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  402789:	89 d0                	mov    %edx,%eax
  40278b:	83 c8 01             	or     $0x1,%eax
  40278e:	83 e7 01             	and    $0x1,%edi
  402791:	0f 44 c2             	cmove  %edx,%eax
  402794:	e9 8f fe ff ff       	jmpq   402628 <DivideInternalFPF+0x188>
  402799:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  4027a0:	44 0f b7 48 06       	movzwl 0x6(%rax),%r9d
  4027a5:	66 44 0b 48 04       	or     0x4(%rax),%r9w
  4027aa:	66 44 0b 48 08       	or     0x8(%rax),%r9w
                        SetInternalFPFNaN(z);
                else
                        SetInternalFPFZero(z, 0);
                break;
        }
        if (IsMantissaZero(y->mantissa))
  4027af:	66 44 0b 48 0a       	or     0xa(%rax),%r9w
  4027b4:	0f 84 76 02 00 00    	je     402a30 <DivideInternalFPF+0x590>
        }

        /*
        ** Initialize the result
        */
        z->type = x->type;
  4027ba:	44 88 03             	mov    %r8b,(%rbx)
        z->sign = x->sign ^ y->sign;
  4027bd:	44 0f b6 4f 01       	movzbl 0x1(%rdi),%r9d
  4027c2:	44 32 48 01          	xor    0x1(%rax),%r9b
  4027c6:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  4027cd:	00 00 
  4027cf:	44 0f b7 64 24 14    	movzwl 0x14(%rsp),%r12d
  4027d5:	44 88 44 24 0f       	mov    %r8b,0xf(%rsp)
  4027da:	41 89 f0             	mov    %esi,%r8d
  4027dd:	0f b7 6c 24 12       	movzwl 0x12(%rsp),%ebp
  4027e2:	44 88 4b 01          	mov    %r9b,0x1(%rbx)
        z->exp = x->exp - y->exp +
  4027e6:	44 0f b7 4f 02       	movzwl 0x2(%rdi),%r9d
        {
                z->mantissa[i] = 0;
                extra_bits[i] = 0;
        }

        while ((z->mantissa[0] & 0x8000) == 0)
  4027eb:	31 ff                	xor    %edi,%edi
  4027ed:	66 89 7c 24 02       	mov    %di,0x2(%rsp)
  4027f2:	44 89 e6             	mov    %r12d,%esi
        /*
        ** Initialize the result
        */
        z->type = x->type;
        z->sign = x->sign ^ y->sign;
        z->exp = x->exp - y->exp +
  4027f5:	66 41 83 e9 80       	sub    $0xff80,%r9w
  4027fa:	66 44 2b 48 02       	sub    0x2(%rax),%r9w
  4027ff:	48 c7 43 04 00 00 00 	movq   $0x0,0x4(%rbx)
  402806:	00 
  402807:	0f b7 7b 08          	movzwl 0x8(%rbx),%edi
  40280b:	45 8d 51 ff          	lea    -0x1(%r9),%r10d
  40280f:	66 44 89 4b 02       	mov    %r9w,0x2(%rbx)
  402814:	66 89 7c 24 0a       	mov    %di,0xa(%rsp)
  402819:	0f b7 7b 06          	movzwl 0x6(%rbx),%edi
  40281d:	66 44 89 54 24 08    	mov    %r10w,0x8(%rsp)
  402823:	41 89 fb             	mov    %edi,%r11d
  402826:	0f b7 7b 0a          	movzwl 0xa(%rbx),%edi
  40282a:	45 89 dc             	mov    %r11d,%r12d
  40282d:	66 89 7c 24 06       	mov    %di,0x6(%rsp)
  402832:	0f b7 7c 24 16       	movzwl 0x16(%rsp),%edi
  402837:	66 89 7c 24 04       	mov    %di,0x4(%rsp)
  40283c:	0f b7 7c 24 10       	movzwl 0x10(%rsp),%edi
  402841:	e9 37 01 00 00       	jmpq   40297d <DivideInternalFPF+0x4dd>
  402846:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40284d:	00 00 00 
                ** Time to subtract yet?
                */
                if (carry == 0)
                        for (j=0; j<INTERNAL_FPF_PRECISION; j++)
                        {
                                if (y->mantissa[j] > extra_bits[j])
  402850:	44 0f b7 70 04       	movzwl 0x4(%rax),%r14d
  402855:	66 45 39 ce          	cmp    %r9w,%r14w
  402859:	0f 87 11 02 00 00    	ja     402a70 <DivideInternalFPF+0x5d0>
                                {
                                        carry = 0;
                                        goto no_subtract;
                                }
                                if (y->mantissa[j] < extra_bits[j])
  40285f:	0f 82 41 02 00 00    	jb     402aa6 <DivideInternalFPF+0x606>
                ** Time to subtract yet?
                */
                if (carry == 0)
                        for (j=0; j<INTERNAL_FPF_PRECISION; j++)
                        {
                                if (y->mantissa[j] > extra_bits[j])
  402865:	0f b7 68 06          	movzwl 0x6(%rax),%ebp
  402869:	66 39 d5             	cmp    %dx,%bp
  40286c:	0f 87 fe 01 00 00    	ja     402a70 <DivideInternalFPF+0x5d0>
                                {
                                        carry = 0;
                                        goto no_subtract;
                                }
                                if (y->mantissa[j] < extra_bits[j])
  402872:	0f 82 40 02 00 00    	jb     402ab8 <DivideInternalFPF+0x618>
                ** Time to subtract yet?
                */
                if (carry == 0)
                        for (j=0; j<INTERNAL_FPF_PRECISION; j++)
                        {
                                if (y->mantissa[j] > extra_bits[j])
  402878:	44 0f b7 78 08       	movzwl 0x8(%rax),%r15d
  40287d:	66 41 39 cf          	cmp    %cx,%r15w
  402881:	0f 87 e9 01 00 00    	ja     402a70 <DivideInternalFPF+0x5d0>
  402887:	0f b7 78 0a          	movzwl 0xa(%rax),%edi
                                {
                                        carry = 0;
                                        goto no_subtract;
                                }
                                if (y->mantissa[j] < extra_bits[j])
  40288b:	72 0a                	jb     402897 <DivideInternalFPF+0x3f7>
                ** Time to subtract yet?
                */
                if (carry == 0)
                        for (j=0; j<INTERNAL_FPF_PRECISION; j++)
                        {
                                if (y->mantissa[j] > extra_bits[j])
  40288d:	66 44 39 c7          	cmp    %r8w,%di
  402891:	0f 87 d9 01 00 00    	ja     402a70 <DivideInternalFPF+0x5d0>
                u16 b,
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
  402897:	41 0f b7 f0          	movzwl %r8w,%esi
  40289b:	0f b7 c9             	movzwl %cx,%ecx
  40289e:	0f b7 d2             	movzwl %dx,%edx
accum-=(u32)c;
accum-=(u32)*borrow;
  4028a1:	29 fe                	sub    %edi,%esi
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  4028a3:	44 29 f9             	sub    %r15d,%ecx
  4028a6:	29 ea                	sub    %ebp,%edx
accum-=(u32)*borrow;
  4028a8:	c1 ee 10             	shr    $0x10,%esi
  4028ab:	41 29 f8             	sub    %edi,%r8d
                u16 b,
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
  4028ae:	41 0f b7 f9          	movzwl %r9w,%edi
accum-=(u32)c;
accum-=(u32)*borrow;
  4028b2:	83 e6 01             	and    $0x1,%esi
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  4028b5:	44 29 f7             	sub    %r14d,%edi
  4028b8:	66 44 89 44 24 04    	mov    %r8w,0x4(%rsp)
accum-=(u32)*borrow;
  4028be:	29 f1                	sub    %esi,%ecx
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  4028c0:	89 ce                	mov    %ecx,%esi
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  4028c2:	c1 e9 10             	shr    $0x10,%ecx
  4028c5:	83 e1 01             	and    $0x1,%ecx
  4028c8:	29 ca                	sub    %ecx,%edx
  4028ca:	0f b7 4c 24 06       	movzwl 0x6(%rsp),%ecx
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  4028cf:	89 d5                	mov    %edx,%ebp
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  4028d1:	c1 ea 10             	shr    $0x10,%edx
  4028d4:	83 e2 01             	and    $0x1,%edx
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  4028d7:	29 d7                	sub    %edx,%edi
  4028d9:	41 89 cf             	mov    %ecx,%r15d
for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4028dc:	44 8d 74 09 01       	lea    0x1(%rcx,%rcx,1),%r14d
  4028e1:	66 41 81 e7 00 80    	and    $0x8000,%r15w
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4028e7:	44 0f b7 4c 24 0a    	movzwl 0xa(%rsp),%r9d
        if(*carry)
                accum|=1;               /* Insert previous carry */
        *carry=new_carry;
        mantissa[i]=accum;              /* Return shifted value */
  4028ed:	66 44 89 73 0a       	mov    %r14w,0xa(%rbx)
  4028f2:	66 44 89 74 24 06    	mov    %r14w,0x6(%rsp)
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4028f8:	44 89 c9             	mov    %r9d,%ecx
  4028fb:	8d 14 09             	lea    (%rcx,%rcx,1),%edx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4028fe:	89 d1                	mov    %edx,%ecx
  402900:	83 c9 01             	or     $0x1,%ecx
  402903:	66 45 85 ff          	test   %r15w,%r15w
                                extra_bits[j],
                                y->mantissa[j]);
                carry = 1;      /* 1 shifted into quotient */
        no_subtract:
                ShiftMantLeft1(&carry, z->mantissa);
                z->exp--;
  402907:	44 0f b7 7c 24 08    	movzwl 0x8(%rsp),%r15d
for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
        if(*carry)
                accum|=1;               /* Insert previous carry */
  40290d:	0f 45 d1             	cmovne %ecx,%edx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402910:	43 8d 0c 24          	lea    (%r12,%r12,1),%ecx
        if(*carry)
                accum|=1;               /* Insert previous carry */
        *carry=new_carry;
        mantissa[i]=accum;              /* Return shifted value */
  402914:	66 89 53 08          	mov    %dx,0x8(%rbx)
  402918:	66 89 54 24 0a       	mov    %dx,0xa(%rsp)
for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
        if(*carry)
                accum|=1;               /* Insert previous carry */
  40291d:	41 89 c8             	mov    %ecx,%r8d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402920:	0f b7 54 24 0c       	movzwl 0xc(%rsp),%edx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  402925:	41 83 c8 01          	or     $0x1,%r8d
  402929:	66 45 85 c9          	test   %r9w,%r9w
  40292d:	41 0f 48 c8          	cmovs  %r8d,%ecx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402931:	44 0f b7 44 24 02    	movzwl 0x2(%rsp),%r8d
        if(*carry)
                accum|=1;               /* Insert previous carry */
        *carry=new_carry;
        mantissa[i]=accum;              /* Return shifted value */
  402937:	66 89 4b 06          	mov    %cx,0x6(%rbx)
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  40293b:	45 01 c0             	add    %r8d,%r8d
        if(*carry)
                accum|=1;               /* Insert previous carry */
  40293e:	45 89 c1             	mov    %r8d,%r9d
  402941:	41 83 c9 01          	or     $0x1,%r9d
  402945:	66 45 85 e4          	test   %r12w,%r12w
  402949:	41 89 cc             	mov    %ecx,%r12d
  40294c:	45 0f 48 c1          	cmovs  %r9d,%r8d
                                extra_bits[j],
                                y->mantissa[j]);
                carry = 1;      /* 1 shifted into quotient */
        no_subtract:
                ShiftMantLeft1(&carry, z->mantissa);
                z->exp--;
  402950:	45 89 f9             	mov    %r15d,%r9d
  402953:	41 83 ef 01          	sub    $0x1,%r15d
  402957:	66 44 89 44 24 02    	mov    %r8w,0x2(%rsp)
        {
                z->mantissa[i] = 0;
                extra_bits[i] = 0;
        }

        while ((z->mantissa[0] & 0x8000) == 0)
  40295d:	66 83 7c 24 02 00    	cmpw   $0x0,0x2(%rsp)
  402963:	44 89 e9             	mov    %r13d,%ecx
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
        if(*carry)
                accum|=1;               /* Insert previous carry */
        *carry=new_carry;
        mantissa[i]=accum;              /* Return shifted value */
  402966:	66 44 89 43 04       	mov    %r8w,0x4(%rbx)
  40296b:	66 44 89 7c 24 08    	mov    %r15w,0x8(%rsp)
  402971:	45 89 d8             	mov    %r11d,%r8d
  402974:	45 89 d7             	mov    %r10d,%r15d
        {
                z->mantissa[i] = 0;
                extra_bits[i] = 0;
        }

        while ((z->mantissa[0] & 0x8000) == 0)
  402977:	0f 88 cb 00 00 00    	js     402a48 <DivideInternalFPF+0x5a8>
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  40297d:	47 8d 1c 00          	lea    (%r8,%r8,1),%r11d
  402981:	44 8d 14 12          	lea    (%rdx,%rdx,1),%r10d
  402985:	44 8d 2c 09          	lea    (%rcx,%rcx,1),%r13d
  402989:	44 0f b7 74 24 04    	movzwl 0x4(%rsp),%r14d
        if(*carry)
                accum|=1;               /* Insert previous carry */
  40298f:	45 89 d9             	mov    %r11d,%r9d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402992:	66 44 89 54 24 0c    	mov    %r10w,0xc(%rsp)
  402998:	47 8d 14 3f          	lea    (%r15,%r15,1),%r10d
        if(*carry)
                accum|=1;               /* Insert previous carry */
  40299c:	41 83 c9 01          	or     $0x1,%r9d
  4029a0:	66 85 d2             	test   %dx,%dx
  4029a3:	44 89 ea             	mov    %r13d,%edx
  4029a6:	45 0f 48 d9          	cmovs  %r9d,%r11d
  4029aa:	83 ca 01             	or     $0x1,%edx
  4029ad:	66 45 85 c0          	test   %r8w,%r8w
  4029b1:	44 0f 48 ea          	cmovs  %edx,%r13d
  4029b5:	44 89 d2             	mov    %r10d,%edx
  4029b8:	83 ca 01             	or     $0x1,%edx
  4029bb:	66 85 c9             	test   %cx,%cx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4029be:	44 89 f1             	mov    %r14d,%ecx
  4029c1:	44 8d 04 09          	lea    (%rcx,%rcx,1),%r8d
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4029c5:	44 0f 48 d2          	cmovs  %edx,%r10d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4029c9:	8d 0c 36             	lea    (%rsi,%rsi,1),%ecx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4029cc:	44 89 c2             	mov    %r8d,%edx
  4029cf:	83 ca 01             	or     $0x1,%edx
  4029d2:	66 45 85 ff          	test   %r15w,%r15w
  4029d6:	44 0f 48 c2          	cmovs  %edx,%r8d
  4029da:	89 ca                	mov    %ecx,%edx
  4029dc:	83 ca 01             	or     $0x1,%edx
  4029df:	66 45 85 f6          	test   %r14w,%r14w
  4029e3:	0f 48 ca             	cmovs  %edx,%ecx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4029e6:	8d 54 2d 00          	lea    0x0(%rbp,%rbp,1),%edx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4029ea:	41 89 d1             	mov    %edx,%r9d
  4029ed:	41 83 c9 01          	or     $0x1,%r9d
  4029f1:	66 85 f6             	test   %si,%si
  4029f4:	41 0f 48 d1          	cmovs  %r9d,%edx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4029f8:	44 8d 0c 3f          	lea    (%rdi,%rdi,1),%r9d
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4029fc:	44 89 ce             	mov    %r9d,%esi
  4029ff:	83 ce 01             	or     $0x1,%esi
  402a02:	66 85 ed             	test   %bp,%bp
  402a05:	44 0f 48 ce          	cmovs  %esi,%r9d
                ShiftMantLeft1(&carry, extra_bits);

                /*
                ** Time to subtract yet?
                */
                if (carry == 0)
  402a09:	66 85 ff             	test   %di,%di
  402a0c:	0f 89 3e fe ff ff    	jns    402850 <DivideInternalFPF+0x3b0>
  402a12:	0f b7 78 0a          	movzwl 0xa(%rax),%edi
  402a16:	44 0f b7 78 08       	movzwl 0x8(%rax),%r15d
  402a1b:	0f b7 68 06          	movzwl 0x6(%rax),%ebp
  402a1f:	44 0f b7 70 04       	movzwl 0x4(%rax),%r14d
  402a24:	e9 6e fe ff ff       	jmpq   402897 <DivideInternalFPF+0x3f7>
  402a29:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
static void SetInternalFPFInfinity(InternalFPF *dest,
                        uchar sign)
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
  402a30:	c6 03 03             	movb   $0x3,(%rbx)
dest->sign=sign;
  402a33:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
  402a37:	e9 37 fc ff ff       	jmpq   402673 <DivideInternalFPF+0x1d3>
  402a3c:	0f 1f 40 00          	nopl   0x0(%rax)
static void SetInternalFPFZero(InternalFPF *dest,
                        uchar sign)
{
int i;          /* Index */

dest->type=IFPF_IS_ZERO;
  402a40:	c6 03 00             	movb   $0x0,(%rbx)
  402a43:	eb ee                	jmp    402a33 <DivideInternalFPF+0x593>
  402a45:	0f 1f 00             	nopl   (%rax)
  402a48:	44 0f b6 44 24 0f    	movzbl 0xf(%rsp),%r8d
  402a4e:	66 44 89 4b 02       	mov    %r9w,0x2(%rbx)
  402a53:	66 89 54 24 2a       	mov    %dx,0x2a(%rsp)
  402a58:	66 44 89 5c 24 28    	mov    %r11w,0x28(%rsp)
  402a5e:	66 44 89 6c 24 26    	mov    %r13w,0x26(%rsp)
  402a64:	66 44 89 54 24 24    	mov    %r10w,0x24(%rsp)
  402a6a:	e9 75 fb ff ff       	jmpq   4025e4 <DivideInternalFPF+0x144>
  402a6f:	90                   	nop
  402a70:	44 0f b7 74 24 06    	movzwl 0x6(%rsp),%r14d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402a76:	44 89 cf             	mov    %r9d,%edi
  402a79:	89 d5                	mov    %edx,%ebp
  402a7b:	89 ce                	mov    %ecx,%esi
  402a7d:	66 44 89 44 24 04    	mov    %r8w,0x4(%rsp)
  402a83:	45 89 f7             	mov    %r14d,%r15d
  402a86:	45 01 f6             	add    %r14d,%r14d
  402a89:	66 41 81 e7 00 80    	and    $0x8000,%r15w
  402a8f:	e9 53 fe ff ff       	jmpq   4028e7 <DivideInternalFPF+0x447>
  402a94:	0f 1f 40 00          	nopl   0x0(%rax)
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  402a98:	b8 01 80 ff ff       	mov    $0xffff8001,%eax
  402a9d:	66 89 43 02          	mov    %ax,0x2(%rbx)
  402aa1:	e9 9a fc ff ff       	jmpq   402740 <DivideInternalFPF+0x2a0>
  402aa6:	0f b7 78 0a          	movzwl 0xa(%rax),%edi
  402aaa:	44 0f b7 78 08       	movzwl 0x8(%rax),%r15d
  402aaf:	0f b7 68 06          	movzwl 0x6(%rax),%ebp
  402ab3:	e9 df fd ff ff       	jmpq   402897 <DivideInternalFPF+0x3f7>
  402ab8:	0f b7 78 0a          	movzwl 0xa(%rax),%edi
  402abc:	44 0f b7 78 08       	movzwl 0x8(%rax),%r15d
  402ac1:	e9 d1 fd ff ff       	jmpq   402897 <DivideInternalFPF+0x3f7>

/*
** Math complete...do rounding
*/
RoundInternalFPF(z);
}
  402ac6:	e8 35 e4 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  402acb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000402ad0 <MultiplyInternalFPF>:
** result is returned in z.
*/
static void MultiplyInternalFPF(InternalFPF *x,
                        InternalFPF *y,
                        InternalFPF *z)
{
  402ad0:	41 57                	push   %r15
  402ad2:	41 56                	push   %r14
  402ad4:	41 55                	push   %r13
  402ad6:	41 54                	push   %r12
  402ad8:	55                   	push   %rbp
  402ad9:	53                   	push   %rbx
  402ada:	48 89 d3             	mov    %rdx,%rbx
  402add:	48 83 ec 58          	sub    $0x58,%rsp
/*
** As in the preceding function, this large switch
** statement selects among the many combinations
** of operands.
*/
switch ((x->type * IFPF_TYPE_COUNT) + y->type)
  402ae1:	0f b6 07             	movzbl (%rdi),%eax
** result is returned in z.
*/
static void MultiplyInternalFPF(InternalFPF *x,
                        InternalFPF *y,
                        InternalFPF *z)
{
  402ae4:	64 48 8b 14 25 28 00 	mov    %fs:0x28,%rdx
  402aeb:	00 00 
  402aed:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
  402af2:	31 d2                	xor    %edx,%edx
  402af4:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
/*
** As in the preceding function, this large switch
** statement selects among the many combinations
** of operands.
*/
switch ((x->type * IFPF_TYPE_COUNT) + y->type)
  402af9:	8d 14 80             	lea    (%rax,%rax,4),%edx
  402afc:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  402b00:	0f b6 06             	movzbl (%rsi),%eax
  402b03:	01 d0                	add    %edx,%eax
  402b05:	83 f8 18             	cmp    $0x18,%eax
  402b08:	0f 87 a2 00 00 00    	ja     402bb0 <MultiplyInternalFPF+0xe0>
  402b0e:	48 89 f5             	mov    %rsi,%rbp
  402b11:	ff 24 c5 f8 cb 40 00 	jmpq   *0x40cbf8(,%rax,8)
  402b18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  402b1f:	00 
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  402b20:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  402b25:	0f b7 48 04          	movzwl 0x4(%rax),%ecx
  402b29:	66 39 4e 04          	cmp    %cx,0x4(%rsi)
  402b2d:	72 26                	jb     402b55 <MultiplyInternalFPF+0x85>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  402b2f:	77 6f                	ja     402ba0 <MultiplyInternalFPF+0xd0>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  402b31:	0f b7 50 06          	movzwl 0x6(%rax),%edx
  402b35:	66 39 56 06          	cmp    %dx,0x6(%rsi)
  402b39:	72 1a                	jb     402b55 <MultiplyInternalFPF+0x85>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  402b3b:	77 63                	ja     402ba0 <MultiplyInternalFPF+0xd0>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  402b3d:	0f b7 48 08          	movzwl 0x8(%rax),%ecx
  402b41:	66 39 4e 08          	cmp    %cx,0x8(%rsi)
  402b45:	72 0e                	jb     402b55 <MultiplyInternalFPF+0x85>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  402b47:	77 57                	ja     402ba0 <MultiplyInternalFPF+0xd0>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  402b49:	0f b7 56 0a          	movzwl 0xa(%rsi),%edx
  402b4d:	66 39 50 0a          	cmp    %dx,0xa(%rax)
  402b51:	77 02                	ja     402b55 <MultiplyInternalFPF+0x85>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  402b53:	72 4b                	jb     402ba0 <MultiplyInternalFPF+0xd0>
  402b55:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  402b5a:	ba 0c 00 00 00       	mov    $0xc,%edx
  402b5f:	48 89 de             	mov    %rbx,%rsi
  402b62:	e8 b9 e4 ff ff       	callq  401020 <memmove@plt>
  402b67:	0f b6 03             	movzbl (%rbx),%eax
  402b6a:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  402b6e:	83 e8 01             	sub    $0x1,%eax
*/
void RoundInternalFPF(InternalFPF *ptr)
{
/* int i; */

if (ptr->type == IFPF_IS_NORMAL ||
  402b71:	3c 01                	cmp    $0x1,%al
  402b73:	0f 86 a1 04 00 00    	jbe    40301a <MultiplyInternalFPF+0x54a>
/*
** All math done...do rounding.
*/
RoundInternalFPF(z);
return;
}
  402b79:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
  402b7e:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  402b85:	00 00 
  402b87:	0f 85 60 05 00 00    	jne    4030ed <MultiplyInternalFPF+0x61d>
  402b8d:	48 83 c4 58          	add    $0x58,%rsp
  402b91:	5b                   	pop    %rbx
  402b92:	5d                   	pop    %rbp
  402b93:	41 5c                	pop    %r12
  402b95:	41 5d                	pop    %r13
  402b97:	41 5e                	pop    %r14
  402b99:	41 5f                	pop    %r15
  402b9b:	c3                   	retq   
  402b9c:	0f 1f 40 00          	nopl   0x0(%rax)
  402ba0:	ba 0c 00 00 00       	mov    $0xc,%edx
  402ba5:	48 89 de             	mov    %rbx,%rsi
  402ba8:	48 89 ef             	mov    %rbp,%rdi
  402bab:	e8 70 e4 ff ff       	callq  401020 <memmove@plt>
  402bb0:	0f b6 03             	movzbl (%rbx),%eax
  402bb3:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  402bb7:	83 e8 01             	sub    $0x1,%eax
  402bba:	eb b5                	jmp    402b71 <MultiplyInternalFPF+0xa1>
  402bbc:	0f 1f 40 00          	nopl   0x0(%rax)
  402bc0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  402bc5:	ba 0c 00 00 00       	mov    $0xc,%edx
  402bca:	48 89 de             	mov    %rbx,%rsi
  402bcd:	e8 4e e4 ff ff       	callq  401020 <memmove@plt>
case INFINITY_INFINITY:
case ZERO_ZERO:
case ZERO_SUBNORMAL:
case ZERO_NORMAL:
        memmove((void *)x,(void *)z,sizeof(InternalFPF));
        z->sign ^= y->sign;
  402bd2:	0f b6 45 01          	movzbl 0x1(%rbp),%eax
  402bd6:	30 43 01             	xor    %al,0x1(%rbx)
  402bd9:	0f b6 03             	movzbl (%rbx),%eax
  402bdc:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  402be0:	83 e8 01             	sub    $0x1,%eax
        break;
  402be3:	eb 8c                	jmp    402b71 <MultiplyInternalFPF+0xa1>
  402be5:	0f 1f 00             	nopl   (%rax)
static void SetInternalFPFNaN(InternalFPF *dest)
{
int i;          /* Index */

dest->type=IFPF_IS_NAN;
dest->exp=MAX_EXP;
  402be8:	bf ff 7f 00 00       	mov    $0x7fff,%edi
dest->sign=1;
dest->mantissa[0]=0x4000;
  402bed:	41 b8 00 40 00 00    	mov    $0x4000,%r8d
for(i=1;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  402bf3:	45 31 c9             	xor    %r9d,%r9d
  402bf6:	45 31 d2             	xor    %r10d,%r10d
  402bf9:	45 31 db             	xor    %r11d,%r11d
*/
static void SetInternalFPFNaN(InternalFPF *dest)
{
int i;          /* Index */

dest->type=IFPF_IS_NAN;
  402bfc:	c6 03 04             	movb   $0x4,(%rbx)
dest->exp=MAX_EXP;
  402bff:	66 89 7b 02          	mov    %di,0x2(%rbx)
dest->sign=1;
  402c03:	c6 43 01 01          	movb   $0x1,0x1(%rbx)
dest->mantissa[0]=0x4000;
  402c07:	66 44 89 43 04       	mov    %r8w,0x4(%rbx)
for(i=1;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  402c0c:	66 44 89 4b 06       	mov    %r9w,0x6(%rbx)
  402c11:	66 44 89 53 08       	mov    %r10w,0x8(%rbx)
  402c16:	66 44 89 5b 0a       	mov    %r11w,0xa(%rbx)
  402c1b:	e9 59 ff ff ff       	jmpq   402b79 <MultiplyInternalFPF+0xa9>
  402c20:	ba 0c 00 00 00       	mov    $0xc,%edx
  402c25:	48 89 de             	mov    %rbx,%rsi
  402c28:	48 89 ef             	mov    %rbp,%rdi
  402c2b:	e8 f0 e3 ff ff       	callq  401020 <memmove@plt>
case SUBNORMAL_INFINITY:
case NORMAL_INFINITY:
case SUBNORMAL_ZERO:
case NORMAL_ZERO:
        memmove((void *)y,(void *)z,sizeof(InternalFPF));
        z->sign ^= x->sign;
  402c30:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  402c35:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  402c39:	30 43 01             	xor    %al,0x1(%rbx)
  402c3c:	0f b6 03             	movzbl (%rbx),%eax
  402c3f:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  402c43:	83 e8 01             	sub    $0x1,%eax
        break;
  402c46:	e9 26 ff ff ff       	jmpq   402b71 <MultiplyInternalFPF+0xa1>
  402c4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  402c50:	48 8b 06             	mov    (%rsi),%rax
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  402c53:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  402c58:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  402c5d:	8b 46 08             	mov    0x8(%rsi),%eax
  402c60:	89 44 24 38          	mov    %eax,0x38(%rsp)
  402c64:	0f b7 42 06          	movzwl 0x6(%rdx),%eax
  402c68:	66 0b 42 04          	or     0x4(%rdx),%ax
  402c6c:	66 0b 42 08          	or     0x8(%rdx),%ax
        memmove((void *)&locy,(void *)y,sizeof(InternalFPF));

        /*
        ** Check for unnormal zero arguments
        */
        if (IsMantissaZero(x->mantissa) || IsMantissaZero(y->mantissa))
  402c70:	66 0b 42 0a          	or     0xa(%rdx),%ax
  402c74:	0f 84 6e 02 00 00    	je     402ee8 <MultiplyInternalFPF+0x418>
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  402c7a:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
  402c7e:	66 0b 46 04          	or     0x4(%rsi),%ax
  402c82:	66 0b 46 08          	or     0x8(%rsi),%ax
        memmove((void *)&locy,(void *)y,sizeof(InternalFPF));

        /*
        ** Check for unnormal zero arguments
        */
        if (IsMantissaZero(x->mantissa) || IsMantissaZero(y->mantissa))
  402c86:	66 0b 46 0a          	or     0xa(%rsi),%ax
  402c8a:	0f 84 58 02 00 00    	je     402ee8 <MultiplyInternalFPF+0x418>
                SetInternalFPFInfinity(z, 0);

        /*
        ** Initialize the result
        */
        if (x->type == IFPF_IS_SUBNORMAL ||
  402c90:	80 7c 24 1d 01       	cmpb   $0x1,0x1d(%rsp)
  402c95:	74 14                	je     402cab <MultiplyInternalFPF+0x1db>
            y->type == IFPF_IS_SUBNORMAL)
  402c97:	0f b6 45 00          	movzbl 0x0(%rbp),%eax
  402c9b:	89 c1                	mov    %eax,%ecx
                z->type = IFPF_IS_SUBNORMAL;
        else
                z->type = IFPF_IS_NORMAL;
  402c9d:	3c 01                	cmp    $0x1,%al
  402c9f:	b8 02 00 00 00       	mov    $0x2,%eax
  402ca4:	0f 45 c8             	cmovne %eax,%ecx
  402ca7:	88 4c 24 1d          	mov    %cl,0x1d(%rsp)
  402cab:	0f b6 44 24 1d       	movzbl 0x1d(%rsp),%eax

        z->sign = x->sign ^ y->sign;
  402cb0:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  402cb5:	31 c9                	xor    %ecx,%ecx
  402cb7:	66 89 4c 24 0a       	mov    %cx,0xa(%rsp)
  402cbc:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  402cc3:	00 00 
  402cc5:	45 31 ed             	xor    %r13d,%r13d
  402cc8:	45 31 e4             	xor    %r12d,%r12d
  402ccb:	31 f6                	xor    %esi,%esi
  402ccd:	45 31 db             	xor    %r11d,%r11d
  402cd0:	44 0f b7 7c 24 34    	movzwl 0x34(%rsp),%r15d
  402cd6:	44 0f b7 74 24 36    	movzwl 0x36(%rsp),%r14d
  402cdc:	88 03                	mov    %al,(%rbx)
  402cde:	0f b6 42 01          	movzbl 0x1(%rdx),%eax
  402ce2:	32 45 01             	xor    0x1(%rbp),%al
  402ce5:	0f b7 4c 24 38       	movzwl 0x38(%rsp),%ecx
        z->exp = x->exp + y->exp ;
        for (i=0; i<INTERNAL_FPF_PRECISION; i++)
        {
                z->mantissa[i] = 0;
  402cea:	c7 44 24 18 40 00 00 	movl   $0x40,0x18(%rsp)
  402cf1:	00 
            y->type == IFPF_IS_SUBNORMAL)
                z->type = IFPF_IS_SUBNORMAL;
        else
                z->type = IFPF_IS_NORMAL;

        z->sign = x->sign ^ y->sign;
  402cf2:	88 43 01             	mov    %al,0x1(%rbx)
        z->exp = x->exp + y->exp ;
  402cf5:	0f b7 45 02          	movzwl 0x2(%rbp),%eax
  402cf9:	31 ed                	xor    %ebp,%ebp
  402cfb:	66 03 42 02          	add    0x2(%rdx),%ax
  402cff:	31 d2                	xor    %edx,%edx
  402d01:	48 c7 43 04 00 00 00 	movq   $0x0,0x4(%rbx)
  402d08:	00 
  402d09:	66 89 54 24 0c       	mov    %dx,0xc(%rsp)
  402d0e:	0f b7 54 24 3a       	movzwl 0x3a(%rsp),%edx
  402d13:	66 89 44 24 1e       	mov    %ax,0x1e(%rsp)
  402d18:	66 89 43 02          	mov    %ax,0x2(%rbx)
  402d1c:	31 c0                	xor    %eax,%eax
  402d1e:	e9 59 01 00 00       	jmpq   402e7c <MultiplyInternalFPF+0x3ac>
  402d23:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                        carry = 0;
                        for (j=(INTERNAL_FPF_PRECISION-1); j>=0; j--)
                                Add16Bits(&carry,
                                        &z->mantissa[j],
                                        z->mantissa[j],
                                        x->mantissa[j]);
  402d28:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  402d2d:	0f b7 d6             	movzwl %si,%edx
                        carry = 0;
                        for (j=(INTERNAL_FPF_PRECISION-1); j>=0; j--)
                                Add16Bits(&carry,
                                        &z->mantissa[j],
                                        z->mantissa[j],
                                        x->mantissa[j]);
  402d30:	41 0f b7 4e 0a       	movzwl 0xa(%r14),%ecx
  402d35:	01 ce                	add    %ecx,%esi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  402d37:	01 d1                	add    %edx,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  402d39:	66 89 73 0a          	mov    %si,0xa(%rbx)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  402d3d:	41 0f b7 7e 08       	movzwl 0x8(%r14),%edi
accum+=(u32)*carry;
  402d42:	c1 e9 10             	shr    $0x10,%ecx
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  402d45:	41 01 fb             	add    %edi,%r11d
accum+=(u32)*carry;
  402d48:	41 8d 3c 0b          	lea    (%r11,%rcx,1),%edi
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  402d4c:	66 89 7b 08          	mov    %di,0x8(%rbx)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  402d50:	41 0f b7 56 06       	movzwl 0x6(%r14),%edx
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  402d55:	41 89 fb             	mov    %edi,%r11d
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  402d58:	c1 ef 10             	shr    $0x10,%edi
  402d5b:	83 e7 01             	and    $0x1,%edi
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  402d5e:	01 d0                	add    %edx,%eax
accum+=(u32)*carry;
  402d60:	01 c7                	add    %eax,%edi
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  402d62:	66 89 7b 06          	mov    %di,0x6(%rbx)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  402d66:	41 0f b7 56 04       	movzwl 0x4(%r14),%edx
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  402d6b:	89 f8                	mov    %edi,%eax
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  402d6d:	c1 ef 10             	shr    $0x10,%edi
  402d70:	83 e7 01             	and    $0x1,%edi
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  402d73:	44 01 ea             	add    %r13d,%edx
accum+=(u32)*carry;
  402d76:	44 8d 2c 3a          	lea    (%rdx,%rdi,1),%r13d
  402d7a:	44 89 e9             	mov    %r13d,%ecx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402d7d:	44 89 ef             	mov    %r13d,%edi
  402d80:	83 e1 01             	and    $0x1,%ecx
  402d83:	66 d1 ef             	shr    %di
        if(*carry)
  402d86:	41 81 e5 00 00 01 00 	and    $0x10000,%r13d
  402d8d:	74 05                	je     402d94 <MultiplyInternalFPF+0x2c4>
                accum|=0x8000;
  402d8f:	66 81 cf 00 80       	or     $0x8000,%di
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402d94:	89 c2                	mov    %eax,%edx
  402d96:	45 89 e6             	mov    %r12d,%r14d
  402d99:	41 89 ef             	mov    %ebp,%r15d
  402d9c:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  402d9f:	66 89 7b 04          	mov    %di,0x4(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  402da3:	41 89 d5             	mov    %edx,%r13d
  402da6:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  402dac:	66 85 c9             	test   %cx,%cx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402daf:	44 89 d9             	mov    %r11d,%ecx
        if(*carry)
                accum|=0x8000;
  402db2:	41 0f 45 d5          	cmovne %r13d,%edx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402db6:	66 d1 e9             	shr    %cx
        if(*carry)
                accum|=0x8000;
  402db9:	41 89 cd             	mov    %ecx,%r13d
        *carry=new_carry;
        mantissa[i]=accum;
  402dbc:	66 89 53 06          	mov    %dx,0x6(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  402dc0:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  402dc6:	a8 01                	test   $0x1,%al
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402dc8:	89 f0                	mov    %esi,%eax
        if(*carry)
                accum|=0x8000;
  402dca:	41 0f 45 cd          	cmovne %r13d,%ecx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402dce:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  402dd1:	41 89 c5             	mov    %eax,%r13d
        *carry=new_carry;
        mantissa[i]=accum;
  402dd4:	66 89 4b 08          	mov    %cx,0x8(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  402dd8:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  402dde:	41 83 e3 01          	and    $0x1,%r11d
  402de2:	41 0f 45 c5          	cmovne %r13d,%eax
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402de6:	66 41 d1 ee          	shr    %r14w
  402dea:	44 0f b7 ef          	movzwl %di,%r13d
        if(*carry)
                accum|=0x8000;
  402dee:	45 89 f3             	mov    %r14d,%r11d
        *carry=new_carry;
        mantissa[i]=accum;
  402df1:	66 89 43 0a          	mov    %ax,0xa(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  402df5:	66 41 81 cb 00 80    	or     $0x8000,%r11w
  402dfb:	83 e6 01             	and    $0x1,%esi
  402dfe:	45 0f 45 f3          	cmovne %r11d,%r14d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402e02:	66 41 d1 ef          	shr    %r15w
        if(*carry)
                accum|=0x8000;
  402e06:	44 89 fe             	mov    %r15d,%esi
  402e09:	66 81 ce 00 80       	or     $0x8000,%si
  402e0e:	41 83 e4 01          	and    $0x1,%r12d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402e12:	44 0f b7 64 24 0c    	movzwl 0xc(%rsp),%r12d
        if(*carry)
                accum|=0x8000;
  402e18:	44 0f 45 fe          	cmovne %esi,%r15d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402e1c:	45 89 e3             	mov    %r12d,%r11d
  402e1f:	66 41 d1 eb          	shr    %r11w
        if(*carry)
                accum|=0x8000;
  402e23:	44 89 de             	mov    %r11d,%esi
  402e26:	66 81 ce 00 80       	or     $0x8000,%si
  402e2b:	83 e5 01             	and    $0x1,%ebp
  402e2e:	44 0f 45 de          	cmovne %esi,%r11d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402e32:	0f b7 74 24 0a       	movzwl 0xa(%rsp),%esi
  402e37:	66 44 89 5c 24 0c    	mov    %r11w,0xc(%rsp)
  402e3d:	44 0f b7 d9          	movzwl %cx,%r11d
  402e41:	44 89 c9             	mov    %r9d,%ecx
  402e44:	66 d1 ee             	shr    %si
        if(*carry)
                accum|=0x8000;
  402e47:	89 f5                	mov    %esi,%ebp
  402e49:	66 81 cd 00 80       	or     $0x8000,%bp
  402e4e:	41 83 e4 01          	and    $0x1,%r12d
  402e52:	45 89 f4             	mov    %r14d,%r12d
  402e55:	0f 45 f5             	cmovne %ebp,%esi
        {
                z->mantissa[i] = 0;
                extra_bits[i] = 0;
        }

        for (i=0; i<(INTERNAL_FPF_PRECISION*16); i++)
  402e58:	83 6c 24 18 01       	subl   $0x1,0x18(%rsp)
  402e5d:	44 89 fd             	mov    %r15d,%ebp
  402e60:	66 89 74 24 0a       	mov    %si,0xa(%rsp)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402e65:	44 0f b7 7c 24 0e    	movzwl 0xe(%rsp),%r15d
  402e6b:	89 c6                	mov    %eax,%esi
  402e6d:	45 89 d6             	mov    %r10d,%r14d
  402e70:	0f b7 c2             	movzwl %dx,%eax
  402e73:	44 89 c2             	mov    %r8d,%edx
        {
                z->mantissa[i] = 0;
                extra_bits[i] = 0;
        }

        for (i=0; i<(INTERNAL_FPF_PRECISION*16); i++)
  402e76:	0f 84 94 00 00 00    	je     402f10 <MultiplyInternalFPF+0x440>
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402e7c:	44 89 ff             	mov    %r15d,%edi
  402e7f:	45 89 f2             	mov    %r14d,%r10d
  402e82:	41 89 c9             	mov    %ecx,%r9d
  402e85:	66 d1 ef             	shr    %di
  402e88:	66 41 d1 ea          	shr    %r10w
  402e8c:	41 89 d0             	mov    %edx,%r8d
  402e8f:	66 89 7c 24 0e       	mov    %di,0xe(%rsp)
        if(*carry)
                accum|=0x8000;
  402e94:	44 89 d7             	mov    %r10d,%edi
  402e97:	66 81 cf 00 80       	or     $0x8000,%di
  402e9c:	41 83 e7 01          	and    $0x1,%r15d
  402ea0:	44 0f 45 d7          	cmovne %edi,%r10d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402ea4:	66 41 d1 e9          	shr    %r9w
        if(*carry)
                accum|=0x8000;
  402ea8:	44 89 cf             	mov    %r9d,%edi
  402eab:	66 81 cf 00 80       	or     $0x8000,%di
  402eb0:	41 83 e6 01          	and    $0x1,%r14d
  402eb4:	44 0f 45 cf          	cmovne %edi,%r9d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402eb8:	66 41 d1 e8          	shr    %r8w
        if(*carry)
                accum|=0x8000;
  402ebc:	44 89 c7             	mov    %r8d,%edi
  402ebf:	66 81 cf 00 80       	or     $0x8000,%di
  402ec4:	83 e1 01             	and    $0x1,%ecx
  402ec7:	44 0f 45 c7          	cmovne %edi,%r8d
                /*
                ** Get rightmost bit of the multiplier
                */
                carry = 0;
                ShiftMantRight1(&carry, locy.mantissa);
                if (carry)
  402ecb:	83 e2 01             	and    $0x1,%edx
  402ece:	0f 85 54 fe ff ff    	jne    402d28 <MultiplyInternalFPF+0x258>
  402ed4:	44 89 e9             	mov    %r13d,%ecx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  402ed7:	44 89 ef             	mov    %r13d,%edi
  402eda:	83 e1 01             	and    $0x1,%ecx
  402edd:	66 d1 ef             	shr    %di
  402ee0:	e9 af fe ff ff       	jmpq   402d94 <MultiplyInternalFPF+0x2c4>
  402ee5:	0f 1f 00             	nopl   (%rax)
  402ee8:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
dest->sign=sign;
dest->exp=MIN_EXP;
  402eed:	be 01 80 ff ff       	mov    $0xffff8001,%esi
static void SetInternalFPFInfinity(InternalFPF *dest,
                        uchar sign)
{
int i;          /* Index */

dest->type=IFPF_IS_INFINITY;
  402ef2:	c6 03 03             	movb   $0x3,(%rbx)
dest->sign=sign;
  402ef5:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
dest->exp=MIN_EXP;
  402ef9:	66 89 73 02          	mov    %si,0x2(%rbx)
  402efd:	0f b6 00             	movzbl (%rax),%eax
  402f00:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  402f04:	e9 87 fd ff ff       	jmpq   402c90 <MultiplyInternalFPF+0x1c0>
  402f09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        ** Note that we use a "special" normalization routine
        ** because we need to use the extra bits. (These are
        ** bits that may have been shifted off the bottom that
        ** we want to reclaim...if we can.
        */
        while ((z->mantissa[0] & 0x8000) == 0)
  402f10:	66 85 ff             	test   %di,%di
  402f13:	66 44 89 7c 24 34    	mov    %r15w,0x34(%rsp)
  402f19:	66 44 89 54 24 36    	mov    %r10w,0x36(%rsp)
  402f1f:	66 44 89 4c 24 38    	mov    %r9w,0x38(%rsp)
  402f25:	66 44 89 44 24 3a    	mov    %r8w,0x3a(%rsp)
  402f2b:	0f 88 ab 01 00 00    	js     4030dc <MultiplyInternalFPF+0x60c>
  402f31:	0f b7 54 24 0c       	movzwl 0xc(%rsp),%edx
  402f36:	0f b7 4c 24 0a       	movzwl 0xa(%rsp),%ecx
  402f3b:	41 89 f7             	mov    %esi,%r15d
  402f3e:	44 0f b7 74 24 1e    	movzwl 0x1e(%rsp),%r14d
  402f44:	89 fe                	mov    %edi,%esi
  402f46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402f4d:	00 00 00 
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402f50:	44 8d 2c 12          	lea    (%rdx,%rdx,1),%r13d
  402f54:	44 8d 54 2d 00       	lea    0x0(%rbp,%rbp,1),%r10d
  402f59:	47 8d 0c 3f          	lea    (%r15,%r15,1),%r9d
  402f5d:	47 8d 04 1b          	lea    (%r11,%r11,1),%r8d
        if(*carry)
                accum|=1;               /* Insert previous carry */
  402f61:	44 89 ef             	mov    %r13d,%edi
  402f64:	83 cf 01             	or     $0x1,%edi
  402f67:	66 85 c9             	test   %cx,%cx
  402f6a:	44 0f 48 ef          	cmovs  %edi,%r13d
  402f6e:	44 89 d7             	mov    %r10d,%edi
  402f71:	83 cf 01             	or     $0x1,%edi
  402f74:	66 85 d2             	test   %dx,%dx
  402f77:	44 0f 48 d7          	cmovs  %edi,%r10d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402f7b:	43 8d 3c 24          	lea    (%r12,%r12,1),%edi
        if(*carry)
                accum|=1;               /* Insert previous carry */
  402f7f:	89 fa                	mov    %edi,%edx
  402f81:	83 ca 01             	or     $0x1,%edx
  402f84:	66 85 ed             	test   %bp,%bp
  402f87:	0f 48 fa             	cmovs  %edx,%edi
  402f8a:	44 89 ca             	mov    %r9d,%edx
  402f8d:	83 ca 01             	or     $0x1,%edx
  402f90:	66 45 85 e4          	test   %r12w,%r12w
  402f94:	41 89 fc             	mov    %edi,%r12d
  402f97:	44 0f 48 ca          	cmovs  %edx,%r9d
  402f9b:	44 89 c2             	mov    %r8d,%edx
  402f9e:	83 ca 01             	or     $0x1,%edx
  402fa1:	66 45 85 ff          	test   %r15w,%r15w
  402fa5:	45 89 cf             	mov    %r9d,%r15d
  402fa8:	44 0f 48 c2          	cmovs  %edx,%r8d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402fac:	8d 14 00             	lea    (%rax,%rax,1),%edx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  402faf:	89 d5                	mov    %edx,%ebp
  402fb1:	83 cd 01             	or     $0x1,%ebp
  402fb4:	66 45 85 db          	test   %r11w,%r11w
  402fb8:	0f 48 d5             	cmovs  %ebp,%edx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402fbb:	01 f6                	add    %esi,%esi
  402fbd:	44 89 d5             	mov    %r10d,%ebp
        if(*carry)
                accum|=1;               /* Insert previous carry */
  402fc0:	41 89 f3             	mov    %esi,%r11d
  402fc3:	41 83 cb 01          	or     $0x1,%r11d
  402fc7:	66 85 c0             	test   %ax,%ax
  402fca:	89 d0                	mov    %edx,%eax
  402fcc:	41 0f 48 f3          	cmovs  %r11d,%esi
  402fd0:	41 83 ee 01          	sub    $0x1,%r14d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  402fd4:	01 c9                	add    %ecx,%ecx
        ** Note that we use a "special" normalization routine
        ** because we need to use the extra bits. (These are
        ** bits that may have been shifted off the bottom that
        ** we want to reclaim...if we can.
        */
        while ((z->mantissa[0] & 0x8000) == 0)
  402fd6:	66 85 f6             	test   %si,%si
  402fd9:	45 89 c3             	mov    %r8d,%r11d
  402fdc:	44 89 ea             	mov    %r13d,%edx
  402fdf:	0f 89 6b ff ff ff    	jns    402f50 <MultiplyInternalFPF+0x480>
  402fe5:	89 f7                	mov    %esi,%edi
  402fe7:	66 89 43 06          	mov    %ax,0x6(%rbx)
  402feb:	66 44 89 74 24 1e    	mov    %r14w,0x1e(%rsp)
  402ff1:	66 44 89 4b 0a       	mov    %r9w,0xa(%rbx)
  402ff6:	66 44 89 43 08       	mov    %r8w,0x8(%rbx)
  402ffb:	44 89 c8             	mov    %r9d,%eax
  402ffe:	66 89 7b 04          	mov    %di,0x4(%rbx)
  403002:	66 44 89 73 02       	mov    %r14w,0x2(%rbx)
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  403007:	89 ce                	mov    %ecx,%esi
        }

        /*
        ** Set the sticky bit if any bits set in extra bits.
        */
        if (IsMantissaZero(extra_bits))
  403009:	09 f2                	or     %esi,%edx
  40300b:	09 d5                	or     %edx,%ebp
  40300d:	66 44 09 e5          	or     %r12w,%bp
  403011:	75 07                	jne    40301a <MultiplyInternalFPF+0x54a>
        {
                z->mantissa[INTERNAL_FPF_PRECISION-1] |= 1;
  403013:	83 c8 01             	or     $0x1,%eax
  403016:	66 89 43 0a          	mov    %ax,0xa(%rbx)
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  40301a:	0f b7 43 06          	movzwl 0x6(%rbx),%eax
  40301e:	66 0b 43 04          	or     0x4(%rbx),%ax
  403022:	66 0b 43 08          	or     0x8(%rbx),%ax
static void denormalize(InternalFPF *ptr,
                int minimum_exponent)
{
long exponent_difference;

if (IsMantissaZero(ptr->mantissa))
  403026:	66 0b 43 0a          	or     0xa(%rbx),%ax
  40302a:	74 23                	je     40304f <MultiplyInternalFPF+0x57f>
{
        printf("Error:  zero significand in denormalize\n");
}

exponent_difference = ptr->exp-minimum_exponent;
if (exponent_difference < 0)
  40302c:	66 81 7b 02 00 80    	cmpw   $0x8000,0x2(%rbx)
  403032:	74 2e                	je     403062 <MultiplyInternalFPF+0x592>

if (ptr->type == IFPF_IS_NORMAL ||
        ptr->type == IFPF_IS_SUBNORMAL)
{
        denormalize(ptr, MIN_EXP);
        if (ptr->type != IFPF_IS_ZERO)
  403034:	80 7c 24 1d 00       	cmpb   $0x0,0x1d(%rsp)
  403039:	0f 84 3a fb ff ff    	je     402b79 <MultiplyInternalFPF+0xa9>
  40303f:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
        {

                /* clear the extraneous bits */
                ptr->mantissa[3] &= 0xfff8;
  403043:	83 e0 f8             	and    $0xfffffff8,%eax
  403046:	66 89 43 0a          	mov    %ax,0xa(%rbx)

/*
** All math done...do rounding.
*/
RoundInternalFPF(z);
return;
  40304a:	e9 2a fb ff ff       	jmpq   402b79 <MultiplyInternalFPF+0xa9>
  40304f:	bf 08 cb 40 00       	mov    $0x40cb08,%edi
  403054:	e8 37 de ff ff       	callq  400e90 <puts@plt>
  403059:	0f b6 03             	movzbl (%rbx),%eax
  40305c:	88 44 24 1d          	mov    %al,0x1d(%rsp)
  403060:	eb ca                	jmp    40302c <MultiplyInternalFPF+0x55c>
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  403062:	80 7c 24 1d 00       	cmpb   $0x0,0x1d(%rsp)
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  403067:	b8 01 80 ff ff       	mov    $0xffff8001,%eax
  40306c:	66 89 43 02          	mov    %ax,0x2(%rbx)
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  403070:	0f 84 03 fb ff ff    	je     402b79 <MultiplyInternalFPF+0xa9>
int i;          /* Index */
int new_carry;
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
  403076:	0f b7 4b 04          	movzwl 0x4(%rbx),%ecx
  40307a:	0f b7 53 06          	movzwl 0x6(%rbx),%edx
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  40307e:	89 c8                	mov    %ecx,%eax
  403080:	66 d1 e8             	shr    %ax
  403083:	66 89 43 04          	mov    %ax,0x4(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403087:	89 d0                	mov    %edx,%eax
  403089:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  40308c:	89 c6                	mov    %eax,%esi
  40308e:	66 81 ce 00 80       	or     $0x8000,%si
  403093:	83 e1 01             	and    $0x1,%ecx
  403096:	0f 45 c6             	cmovne %esi,%eax
int i;          /* Index */
int new_carry;
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
  403099:	0f b7 73 08          	movzwl 0x8(%rbx),%esi
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  40309d:	66 89 43 06          	mov    %ax,0x6(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4030a1:	89 f0                	mov    %esi,%eax
  4030a3:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  4030a6:	89 c1                	mov    %eax,%ecx
  4030a8:	66 81 c9 00 80       	or     $0x8000,%cx
  4030ad:	83 e2 01             	and    $0x1,%edx
  4030b0:	0f 45 c1             	cmovne %ecx,%eax
int i;          /* Index */
int new_carry;
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
  4030b3:	0f b7 4b 0a          	movzwl 0xa(%rbx),%ecx
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4030b7:	66 89 43 08          	mov    %ax,0x8(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4030bb:	89 ca                	mov    %ecx,%edx
  4030bd:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
  4030c0:	89 d0                	mov    %edx,%eax
  4030c2:	66 0d 00 80          	or     $0x8000,%ax
  4030c6:	83 e6 01             	and    $0x1,%esi
  4030c9:	0f 45 d0             	cmovne %eax,%edx
        else
                for(i=0;i<amount;i++)
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  4030cc:	89 d0                	mov    %edx,%eax
  4030ce:	83 c8 01             	or     $0x1,%eax
  4030d1:	83 e1 01             	and    $0x1,%ecx
  4030d4:	0f 44 c2             	cmove  %edx,%eax
  4030d7:	e9 67 ff ff ff       	jmpq   403043 <MultiplyInternalFPF+0x573>
        ** Note that we use a "special" normalization routine
        ** because we need to use the extra bits. (These are
        ** bits that may have been shifted off the bottom that
        ** we want to reclaim...if we can.
        */
        while ((z->mantissa[0] & 0x8000) == 0)
  4030dc:	89 f0                	mov    %esi,%eax
  4030de:	0f b7 54 24 0c       	movzwl 0xc(%rsp),%edx
  4030e3:	0f b7 74 24 0a       	movzwl 0xa(%rsp),%esi
  4030e8:	e9 1c ff ff ff       	jmpq   403009 <MultiplyInternalFPF+0x539>
/*
** All math done...do rounding.
*/
RoundInternalFPF(z);
return;
}
  4030ed:	e8 0e de ff ff       	callq  400f00 <__stack_chk_fail@plt>
  4030f2:	0f 1f 40 00          	nopl   0x0(%rax)
  4030f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4030fd:	00 00 00 

0000000000403100 <AddSubInternalFPF>:
*/
static void AddSubInternalFPF(uchar operation,
                InternalFPF *x,
                InternalFPF *y,
                InternalFPF *z)
{
  403100:	41 55                	push   %r13
  403102:	41 54                	push   %r12
  403104:	49 89 f0             	mov    %rsi,%r8
  403107:	55                   	push   %rbp
  403108:	53                   	push   %rbx
  403109:	48 89 d5             	mov    %rdx,%rbp
  40310c:	48 89 cb             	mov    %rcx,%rbx
  40310f:	48 83 ec 38          	sub    $0x38,%rsp

/*
** Following big switch statement handles the
** various combinations of operand types.
*/
switch ((x->type * IFPF_TYPE_COUNT) + y->type)
  403113:	0f b6 4d 00          	movzbl 0x0(%rbp),%ecx
*/
static void AddSubInternalFPF(uchar operation,
                InternalFPF *x,
                InternalFPF *y,
                InternalFPF *z)
{
  403117:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40311e:	00 00 
  403120:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  403125:	31 c0                	xor    %eax,%eax

/*
** Following big switch statement handles the
** various combinations of operand types.
*/
switch ((x->type * IFPF_TYPE_COUNT) + y->type)
  403127:	0f b6 06             	movzbl (%rsi),%eax
  40312a:	8d 34 80             	lea    (%rax,%rax,4),%esi
  40312d:	89 c2                	mov    %eax,%edx
  40312f:	0f b6 c1             	movzbl %cl,%eax
  403132:	01 f0                	add    %esi,%eax
  403134:	83 f8 18             	cmp    $0x18,%eax
  403137:	77 37                	ja     403170 <AddSubInternalFPF+0x70>
  403139:	41 89 fc             	mov    %edi,%r12d
  40313c:	ff 24 c5 c0 cc 40 00 	jmpq   *0x40ccc0(,%rax,8)
  403143:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  403148:	ba 0c 00 00 00       	mov    $0xc,%edx
  40314d:	48 89 de             	mov    %rbx,%rsi
  403150:	4c 89 c7             	mov    %r8,%rdi
  403153:	e8 c8 de ff ff       	callq  401020 <memmove@plt>
{
case ZERO_ZERO:
        memmove((void *)x,(void *)z,sizeof(InternalFPF));
        if (x->sign ^ y->sign ^ operation)
  403158:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  40315c:	32 45 01             	xor    0x1(%rbp),%al
  40315f:	44 38 e0             	cmp    %r12b,%al
  403162:	74 0c                	je     403170 <AddSubInternalFPF+0x70>
        {
                z->sign = 0; /* positive */
  403164:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
  403168:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40316f:	00 
*/
void RoundInternalFPF(InternalFPF *ptr)
{
/* int i; */

if (ptr->type == IFPF_IS_NORMAL ||
  403170:	0f b6 03             	movzbl (%rbx),%eax
  403173:	83 e8 01             	sub    $0x1,%eax
  403176:	3c 01                	cmp    $0x1,%al
  403178:	76 76                	jbe    4031f0 <AddSubInternalFPF+0xf0>
/*
** All the math is done; time to round.
*/
RoundInternalFPF(z);
return;
}
  40317a:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40317f:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  403186:	00 00 
  403188:	0f 85 72 06 00 00    	jne    403800 <AddSubInternalFPF+0x700>
  40318e:	48 83 c4 38          	add    $0x38,%rsp
  403192:	5b                   	pop    %rbx
  403193:	5d                   	pop    %rbp
  403194:	41 5c                	pop    %r12
  403196:	41 5d                	pop    %r13
  403198:	c3                   	retq   
  403199:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4031a0:	41 0f b7 40 04       	movzwl 0x4(%r8),%eax
  4031a5:	66 39 45 04          	cmp    %ax,0x4(%rbp)
  4031a9:	0f 82 81 00 00 00    	jb     403230 <AddSubInternalFPF+0x130>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  4031af:	77 25                	ja     4031d6 <AddSubInternalFPF+0xd6>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4031b1:	0f b7 45 06          	movzwl 0x6(%rbp),%eax
  4031b5:	66 41 39 40 06       	cmp    %ax,0x6(%r8)
  4031ba:	77 74                	ja     403230 <AddSubInternalFPF+0x130>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  4031bc:	72 18                	jb     4031d6 <AddSubInternalFPF+0xd6>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4031be:	0f b7 45 08          	movzwl 0x8(%rbp),%eax
  4031c2:	66 41 39 40 08       	cmp    %ax,0x8(%r8)
  4031c7:	77 67                	ja     403230 <AddSubInternalFPF+0x130>
        {
                memmove((void *)x,(void *)z,sizeof(InternalFPF));
                return;
        }
        if (x->mantissa[i] < y->mantissa[i])
  4031c9:	72 0b                	jb     4031d6 <AddSubInternalFPF+0xd6>
** return the larger.  Note that we will be emulating
** an 80387 in this operation.
*/
for (i=0; i<INTERNAL_FPF_PRECISION; i++)
{
        if (x->mantissa[i] > y->mantissa[i])
  4031cb:	0f b7 45 0a          	movzwl 0xa(%rbp),%eax
  4031cf:	66 41 39 40 0a       	cmp    %ax,0xa(%r8)
  4031d4:	77 5a                	ja     403230 <AddSubInternalFPF+0x130>
  4031d6:	ba 0c 00 00 00       	mov    $0xc,%edx
  4031db:	48 89 de             	mov    %rbx,%rsi
  4031de:	48 89 ef             	mov    %rbp,%rdi
  4031e1:	e8 3a de ff ff       	callq  401020 <memmove@plt>
*/
void RoundInternalFPF(InternalFPF *ptr)
{
/* int i; */

if (ptr->type == IFPF_IS_NORMAL ||
  4031e6:	0f b6 03             	movzbl (%rbx),%eax
  4031e9:	83 e8 01             	sub    $0x1,%eax
  4031ec:	3c 01                	cmp    $0x1,%al
  4031ee:	77 8a                	ja     40317a <AddSubInternalFPF+0x7a>
  4031f0:	48 8d 53 04          	lea    0x4(%rbx),%rdx
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  4031f4:	0f b7 42 04          	movzwl 0x4(%rdx),%eax
  4031f8:	66 0b 42 02          	or     0x2(%rdx),%ax
  4031fc:	66 0b 42 06          	or     0x6(%rdx),%ax
static void denormalize(InternalFPF *ptr,
                int minimum_exponent)
{
long exponent_difference;

if (IsMantissaZero(ptr->mantissa))
  403200:	66 0b 02             	or     (%rdx),%ax
  403203:	0f 84 9f 02 00 00    	je     4034a8 <AddSubInternalFPF+0x3a8>
{
        printf("Error:  zero significand in denormalize\n");
}

exponent_difference = ptr->exp-minimum_exponent;
if (exponent_difference < 0)
  403209:	66 81 7b 02 00 80    	cmpw   $0x8000,0x2(%rbx)
  40320f:	0f 84 fb 04 00 00    	je     403710 <AddSubInternalFPF+0x610>

if (ptr->type == IFPF_IS_NORMAL ||
        ptr->type == IFPF_IS_SUBNORMAL)
{
        denormalize(ptr, MIN_EXP);
        if (ptr->type != IFPF_IS_ZERO)
  403215:	80 3b 00             	cmpb   $0x0,(%rbx)
  403218:	0f 84 5c ff ff ff    	je     40317a <AddSubInternalFPF+0x7a>
  40321e:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
        {

                /* clear the extraneous bits */
                ptr->mantissa[3] &= 0xfff8;
  403222:	83 e0 f8             	and    $0xfffffff8,%eax
  403225:	66 89 43 0a          	mov    %ax,0xa(%rbx)

/*
** All the math is done; time to round.
*/
RoundInternalFPF(z);
return;
  403229:	e9 4c ff ff ff       	jmpq   40317a <AddSubInternalFPF+0x7a>
  40322e:	66 90                	xchg   %ax,%ax
  403230:	ba 0c 00 00 00       	mov    $0xc,%edx
  403235:	48 89 de             	mov    %rbx,%rsi
  403238:	4c 89 c7             	mov    %r8,%rdi
  40323b:	e8 e0 dd ff ff       	callq  401020 <memmove@plt>
  403240:	e9 2b ff ff ff       	jmpq   403170 <AddSubInternalFPF+0x70>
  403245:	0f 1f 00             	nopl   (%rax)
  403248:	ba 0c 00 00 00       	mov    $0xc,%edx
  40324d:	48 89 de             	mov    %rbx,%rsi
  403250:	48 89 ef             	mov    %rbp,%rdi
  403253:	e8 c8 dd ff ff       	callq  401020 <memmove@plt>
case ZERO_NORMAL:
case ZERO_INFINITY:
case SUBNORMAL_INFINITY:
case NORMAL_INFINITY:
        memmove((void *)y,(void *)z,sizeof(InternalFPF));
        z->sign ^= operation;
  403258:	44 30 63 01          	xor    %r12b,0x1(%rbx)
        break;
  40325c:	e9 0f ff ff ff       	jmpq   403170 <AddSubInternalFPF+0x70>
  403261:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
static void SetInternalFPFNaN(InternalFPF *dest)
{
int i;          /* Index */

dest->type=IFPF_IS_NAN;
dest->exp=MAX_EXP;
  403268:	ba ff 7f 00 00       	mov    $0x7fff,%edx
dest->sign=1;
dest->mantissa[0]=0x4000;
  40326d:	b9 00 40 00 00       	mov    $0x4000,%ecx
for(i=1;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  403272:	31 f6                	xor    %esi,%esi
  403274:	31 ff                	xor    %edi,%edi
  403276:	45 31 c0             	xor    %r8d,%r8d
*/
static void SetInternalFPFNaN(InternalFPF *dest)
{
int i;          /* Index */

dest->type=IFPF_IS_NAN;
  403279:	c6 03 04             	movb   $0x4,(%rbx)
dest->exp=MAX_EXP;
  40327c:	66 89 53 02          	mov    %dx,0x2(%rbx)
dest->sign=1;
  403280:	c6 43 01 01          	movb   $0x1,0x1(%rbx)
dest->mantissa[0]=0x4000;
  403284:	66 89 4b 04          	mov    %cx,0x4(%rbx)
for(i=1;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  403288:	66 89 73 06          	mov    %si,0x6(%rbx)
  40328c:	66 89 7b 08          	mov    %di,0x8(%rbx)
  403290:	66 44 89 43 0a       	mov    %r8w,0xa(%rbx)
  403295:	e9 e0 fe ff ff       	jmpq   40317a <AddSubInternalFPF+0x7a>
  40329a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4032a0:	41 8b 40 08          	mov    0x8(%r8),%eax
  4032a4:	49 8b 38             	mov    (%r8),%rdi
  4032a7:	8b 75 08             	mov    0x8(%rbp),%esi
  4032aa:	89 44 24 08          	mov    %eax,0x8(%rsp)
  4032ae:	48 8b 45 00          	mov    0x0(%rbp),%rax
  4032b2:	48 89 3c 24          	mov    %rdi,(%rsp)
        */
        memmove((void *)&locx,(void *)x,sizeof(InternalFPF));
        memmove((void *)&locy,(void *)y,sizeof(InternalFPF));

        /* compute sum/difference */
        exponent_difference = locx.exp-locy.exp;
  4032b6:	c1 ef 10             	shr    $0x10,%edi
  4032b9:	89 74 24 18          	mov    %esi,0x18(%rsp)
  4032bd:	0f bf f7             	movswl %di,%esi
  4032c0:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  4032c5:	c1 e8 10             	shr    $0x10,%eax
  4032c8:	44 0f bf c0          	movswl %ax,%r8d
  4032cc:	44 29 c6             	sub    %r8d,%esi
        if (exponent_difference == 0)
  4032cf:	83 fe 00             	cmp    $0x0,%esi
  4032d2:	0f 85 08 01 00 00    	jne    4033e0 <AddSubInternalFPF+0x2e0>
        {
                /*
                ** locx.exp == locy.exp
                ** so, no shifting required
                */
                if (locx.type == IFPF_IS_SUBNORMAL ||
  4032d8:	80 fa 01             	cmp    $0x1,%dl
  4032db:	0f 84 b7 02 00 00    	je     403598 <AddSubInternalFPF+0x498>
  4032e1:	80 f9 01             	cmp    $0x1,%cl
                  locy.type == IFPF_IS_SUBNORMAL)
                        z->type = IFPF_IS_SUBNORMAL;
                else
                        z->type = IFPF_IS_NORMAL;
  4032e4:	b8 02 00 00 00       	mov    $0x2,%eax
        {
                /*
                ** locx.exp == locy.exp
                ** so, no shifting required
                */
                if (locx.type == IFPF_IS_SUBNORMAL ||
  4032e9:	0f 84 a9 02 00 00    	je     403598 <AddSubInternalFPF+0x498>
  4032ef:	88 03                	mov    %al,(%rbx)
                        z->type = IFPF_IS_NORMAL;

                /*
                ** Assume that locx.mantissa > locy.mantissa
                */
                z->sign = locx.sign;
  4032f1:	0f b6 44 24 01       	movzbl 0x1(%rsp),%eax
  4032f6:	0f b6 4c 24 11       	movzbl 0x11(%rsp),%ecx
                z->exp= locx.exp;
  4032fb:	66 89 7b 02          	mov    %di,0x2(%rbx)
                        z->type = IFPF_IS_NORMAL;

                /*
                ** Assume that locx.mantissa > locy.mantissa
                */
                z->sign = locx.sign;
  4032ff:	88 43 01             	mov    %al,0x1(%rbx)
                        z->type = locy.type;
                        z->sign = locy.sign ^ operation;
                        z->exp = locy.exp;
                }

                if (locx.sign ^ locy.sign ^ operation)
  403302:	31 c8                	xor    %ecx,%eax
  403304:	41 38 c4             	cmp    %al,%r12b
  403307:	0f 84 23 03 00 00    	je     403630 <AddSubInternalFPF+0x530>
                        */
                        borrow = 0;
                        for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
                                Sub16Bits(&borrow,
                                        &z->mantissa[i],
                                        locx.mantissa[i],
  40330d:	0f b7 44 24 0a       	movzwl 0xa(%rsp),%eax
                                        locy.mantissa[i]);
  403312:	0f b7 74 24 1a       	movzwl 0x1a(%rsp),%esi
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  403317:	0f b7 7c 24 18       	movzwl 0x18(%rsp),%edi
                        */
                        borrow = 0;
                        for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
                                Sub16Bits(&borrow,
                                        &z->mantissa[i],
                                        locx.mantissa[i],
  40331c:	89 c2                	mov    %eax,%edx
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  40331e:	29 f0                	sub    %esi,%eax
  403320:	29 f2                	sub    %esi,%edx
  403322:	c1 e8 10             	shr    $0x10,%eax
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  403325:	0f b7 74 24 16       	movzwl 0x16(%rsp),%esi
accum-=(u32)*borrow;
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  40332a:	66 89 53 0a          	mov    %dx,0xa(%rbx)
                u16 b,
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
  40332e:	0f b7 54 24 08       	movzwl 0x8(%rsp),%edx
accum-=(u32)c;
accum-=(u32)*borrow;
  403333:	83 e0 01             	and    $0x1,%eax
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  403336:	29 fa                	sub    %edi,%edx
accum-=(u32)*borrow;
  403338:	29 c2                	sub    %eax,%edx
                u16 b,
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
  40333a:	0f b7 44 24 06       	movzwl 0x6(%rsp),%eax
accum-=(u32)c;
accum-=(u32)*borrow;
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  40333f:	66 89 53 08          	mov    %dx,0x8(%rbx)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  403343:	c1 ea 10             	shr    $0x10,%edx
  403346:	83 e2 01             	and    $0x1,%edx
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  403349:	29 f0                	sub    %esi,%eax
  40334b:	0f b7 74 24 14       	movzwl 0x14(%rsp),%esi
accum-=(u32)*borrow;
  403350:	29 d0                	sub    %edx,%eax
                u16 b,
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
  403352:	0f b7 54 24 04       	movzwl 0x4(%rsp),%edx
accum-=(u32)c;
accum-=(u32)*borrow;
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  403357:	66 89 43 06          	mov    %ax,0x6(%rbx)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  40335b:	c1 e8 10             	shr    $0x10,%eax
  40335e:	83 e0 01             	and    $0x1,%eax
                u16 c)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
  403361:	29 f2                	sub    %esi,%edx
accum-=(u32)*borrow;
  403363:	29 c2                	sub    %eax,%edx
  403365:	89 d0                	mov    %edx,%eax
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  403367:	66 89 53 04          	mov    %dx,0x4(%rbx)
                                Sub16Bits(&borrow,
                                        &z->mantissa[i],
                                        locx.mantissa[i],
                                        locy.mantissa[i]);

                        if (borrow)
  40336b:	a9 00 00 01 00       	test   $0x10000,%eax
  403370:	74 42                	je     4033b4 <AddSubInternalFPF+0x2b4>
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  403372:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
  403376:	0f b7 53 08          	movzwl 0x8(%rbx),%edx
                                ** x->mantissa leaving a negative
                                ** result.  Change the result back to
                                ** an unsigned number and flip the
                                ** sign flag.
                                */
                                z->sign = locy.sign ^ operation;
  40337a:	41 31 cc             	xor    %ecx,%r12d
  40337d:	44 88 63 01          	mov    %r12b,0x1(%rbx)
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  403381:	f7 d8                	neg    %eax
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  403383:	66 89 43 0a          	mov    %ax,0xa(%rbx)
  403387:	c1 f8 1f             	sar    $0x1f,%eax
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  40338a:	29 d0                	sub    %edx,%eax
  40338c:	0f b7 53 06          	movzwl 0x6(%rbx),%edx
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  403390:	66 89 43 08          	mov    %ax,0x8(%rbx)
  403394:	c1 e8 10             	shr    $0x10,%eax
  403397:	83 e0 01             	and    $0x1,%eax
  40339a:	01 d0                	add    %edx,%eax
  40339c:	0f b7 53 04          	movzwl 0x4(%rbx),%edx
{
u32 accum;              /* Accumulator */

accum=(u32)b;
accum-=(u32)c;
accum-=(u32)*borrow;
  4033a0:	f7 d8                	neg    %eax
*borrow=(u32)((accum & 0x00010000) ? 1 : 0);    /* New borrow */
*a=(u16)(accum & 0xFFFF);
  4033a2:	66 89 43 06          	mov    %ax,0x6(%rbx)
  4033a6:	c1 e8 10             	shr    $0x10,%eax
  4033a9:	83 e0 01             	and    $0x1,%eax
  4033ac:	01 d0                	add    %edx,%eax
  4033ae:	f7 d8                	neg    %eax
  4033b0:	66 89 43 04          	mov    %ax,0x4(%rbx)
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  4033b4:	0f b7 73 06          	movzwl 0x6(%rbx),%esi
  4033b8:	0f b7 7b 08          	movzwl 0x8(%rbx),%edi
  4033bc:	44 0f b7 43 0a       	movzwl 0xa(%rbx),%r8d
  4033c1:	89 f0                	mov    %esi,%eax
  4033c3:	66 0b 43 04          	or     0x4(%rbx),%ax
  4033c7:	09 f8                	or     %edi,%eax
                                ** was correct.  Therefore, do nothing.
                                ** z->sign = x->sign;
                                */
                        }

                        if (IsMantissaZero(z->mantissa))
  4033c9:	66 44 09 c0          	or     %r8w,%ax
  4033cd:	0f 85 d5 01 00 00    	jne    4035a8 <AddSubInternalFPF+0x4a8>
                        {
                                z->type = IFPF_IS_ZERO;
  4033d3:	c6 03 00             	movb   $0x0,(%rbx)
                                z->sign = 0; /* positive */
  4033d6:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
  4033da:	e9 9b fd ff ff       	jmpq   40317a <AddSubInternalFPF+0x7a>
  4033df:	90                   	nop
                */
                z->sign = locx.sign;
                z->exp= locx.exp;
        }
        else
                if (exponent_difference > 0)
  4033e0:	0f 8e da 00 00 00    	jle    4034c0 <AddSubInternalFPF+0x3c0>
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  4033e6:	84 c9                	test   %cl,%cl
  4033e8:	0f 84 9f 00 00 00    	je     40348d <AddSubInternalFPF+0x38d>
        /*
        ** If the amount of shifting will shift everyting
        ** out of existence, then just clear the whole mantissa
        ** and set the lowmost bit to 1.
        */
        if(amount>=INTERNAL_FPF_PRECISION * 16)
  4033ee:	83 fe 3f             	cmp    $0x3f,%esi
  4033f1:	0f 8f b9 03 00 00    	jg     4037b0 <AddSubInternalFPF+0x6b0>
  4033f7:	44 0f b7 4c 24 14    	movzwl 0x14(%rsp),%r9d
  4033fd:	0f b7 44 24 16       	movzwl 0x16(%rsp),%eax
  403402:	31 ed                	xor    %ebp,%ebp
  403404:	44 0f b7 54 24 18    	movzwl 0x18(%rsp),%r10d
  40340a:	44 0f b7 5c 24 1a    	movzwl 0x1a(%rsp),%r11d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403410:	41 89 c0             	mov    %eax,%r8d
  403413:	66 41 d1 e8          	shr    %r8w
        if(*carry)
                accum|=0x8000;
  403417:	44 89 c1             	mov    %r8d,%ecx
  40341a:	66 81 c9 00 80       	or     $0x8000,%cx
  40341f:	41 f6 c1 01          	test   $0x1,%r9b
  403423:	44 0f 45 c1          	cmovne %ecx,%r8d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403427:	44 89 d1             	mov    %r10d,%ecx
  40342a:	66 d1 e9             	shr    %cx
        if(*carry)
                accum|=0x8000;
  40342d:	41 89 cd             	mov    %ecx,%r13d
  403430:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  403436:	a8 01                	test   $0x1,%al
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403438:	44 89 d8             	mov    %r11d,%eax
        if(*carry)
                accum|=0x8000;
  40343b:	41 0f 45 cd          	cmovne %r13d,%ecx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  40343f:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  403442:	41 89 c5             	mov    %eax,%r13d
  403445:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  40344b:	41 83 e2 01          	and    $0x1,%r10d
  40344f:	41 0f 45 c5          	cmovne %r13d,%eax
        else
                for(i=0;i<amount;i++)
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  403453:	41 89 c2             	mov    %eax,%r10d
  403456:	41 83 ca 01          	or     $0x1,%r10d
  40345a:	41 83 e3 01          	and    $0x1,%r11d
  40345e:	41 0f 45 c2          	cmovne %r10d,%eax
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  403462:	83 c5 01             	add    $0x1,%ebp
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403465:	66 41 d1 e9          	shr    %r9w
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  403469:	39 ee                	cmp    %ebp,%esi
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  40346b:	41 89 c3             	mov    %eax,%r11d
  40346e:	41 89 ca             	mov    %ecx,%r10d
  403471:	44 89 c0             	mov    %r8d,%eax
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  403474:	75 9a                	jne    403410 <AddSubInternalFPF+0x310>
  403476:	66 44 89 5c 24 1a    	mov    %r11w,0x1a(%rsp)
  40347c:	66 44 89 4c 24 14    	mov    %r9w,0x14(%rsp)
  403482:	66 89 44 24 16       	mov    %ax,0x16(%rsp)
  403487:	66 44 89 54 24 18    	mov    %r10w,0x18(%rsp)
                        ** locx.exp > locy.exp
                        */
                        StickyShiftRightMant(&locy,
                                 exponent_difference);
                        z->type = locx.type;
                        z->sign = locx.sign;
  40348d:	0f b6 44 24 01       	movzbl 0x1(%rsp),%eax
                        /*
                        ** locx.exp > locy.exp
                        */
                        StickyShiftRightMant(&locy,
                                 exponent_difference);
                        z->type = locx.type;
  403492:	88 13                	mov    %dl,(%rbx)
                        z->sign = locx.sign;
                        z->exp = locx.exp;
  403494:	66 89 7b 02          	mov    %di,0x2(%rbx)
  403498:	0f b6 4c 24 11       	movzbl 0x11(%rsp),%ecx
                        ** locx.exp > locy.exp
                        */
                        StickyShiftRightMant(&locy,
                                 exponent_difference);
                        z->type = locx.type;
                        z->sign = locx.sign;
  40349d:	88 43 01             	mov    %al,0x1(%rbx)
  4034a0:	e9 5d fe ff ff       	jmpq   403302 <AddSubInternalFPF+0x202>
  4034a5:	0f 1f 00             	nopl   (%rax)
  4034a8:	bf 08 cb 40 00       	mov    $0x40cb08,%edi
  4034ad:	e8 de d9 ff ff       	callq  400e90 <puts@plt>
  4034b2:	e9 52 fd ff ff       	jmpq   403209 <AddSubInternalFPF+0x109>
  4034b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4034be:	00 00 
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  4034c0:	84 d2                	test   %dl,%dl
  4034c2:	0f 84 ae 00 00 00    	je     403576 <AddSubInternalFPF+0x476>
                else    /* if (exponent_difference < 0) */
                {
                        /*
                        ** locx.exp < locy.exp
                        */
                        StickyShiftRightMant(&locx,
  4034c8:	f7 de                	neg    %esi
        /*
        ** If the amount of shifting will shift everyting
        ** out of existence, then just clear the whole mantissa
        ** and set the lowmost bit to 1.
        */
        if(amount>=INTERNAL_FPF_PRECISION * 16)
  4034ca:	83 fe 3f             	cmp    $0x3f,%esi
  4034cd:	0f 8f 03 03 00 00    	jg     4037d6 <AddSubInternalFPF+0x6d6>
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  4034d3:	85 f6                	test   %esi,%esi
  4034d5:	0f 84 9b 00 00 00    	je     403576 <AddSubInternalFPF+0x476>
  4034db:	44 0f b7 5c 24 04    	movzwl 0x4(%rsp),%r11d
  4034e1:	0f b7 54 24 06       	movzwl 0x6(%rsp),%edx
  4034e6:	31 ed                	xor    %ebp,%ebp
  4034e8:	44 0f b7 4c 24 08    	movzwl 0x8(%rsp),%r9d
  4034ee:	44 0f b7 54 24 0a    	movzwl 0xa(%rsp),%r10d
  4034f4:	0f 1f 40 00          	nopl   0x0(%rax)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4034f8:	41 89 d0             	mov    %edx,%r8d
  4034fb:	66 41 d1 e8          	shr    %r8w
        if(*carry)
                accum|=0x8000;
  4034ff:	44 89 c7             	mov    %r8d,%edi
  403502:	66 81 cf 00 80       	or     $0x8000,%di
  403507:	41 f6 c3 01          	test   $0x1,%r11b
  40350b:	44 0f 45 c7          	cmovne %edi,%r8d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  40350f:	44 89 cf             	mov    %r9d,%edi
  403512:	66 d1 ef             	shr    %di
        if(*carry)
                accum|=0x8000;
  403515:	41 89 fd             	mov    %edi,%r13d
  403518:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  40351e:	83 e2 01             	and    $0x1,%edx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403521:	44 89 d2             	mov    %r10d,%edx
        if(*carry)
                accum|=0x8000;
  403524:	41 0f 45 fd          	cmovne %r13d,%edi
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403528:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
  40352b:	41 89 d5             	mov    %edx,%r13d
  40352e:	66 41 81 cd 00 80    	or     $0x8000,%r13w
  403534:	41 83 e1 01          	and    $0x1,%r9d
  403538:	41 0f 45 d5          	cmovne %r13d,%edx
        else
                for(i=0;i<amount;i++)
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  40353c:	41 89 d1             	mov    %edx,%r9d
  40353f:	41 83 c9 01          	or     $0x1,%r9d
  403543:	41 83 e2 01          	and    $0x1,%r10d
  403547:	41 0f 45 d1          	cmovne %r9d,%edx
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  40354b:	83 c5 01             	add    $0x1,%ebp
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  40354e:	66 41 d1 eb          	shr    %r11w
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  403552:	39 ee                	cmp    %ebp,%esi
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  403554:	41 89 d2             	mov    %edx,%r10d
  403557:	41 89 f9             	mov    %edi,%r9d
  40355a:	44 89 c2             	mov    %r8d,%edx
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
        }
        else
                for(i=0;i<amount;i++)
  40355d:	75 99                	jne    4034f8 <AddSubInternalFPF+0x3f8>
  40355f:	66 44 89 54 24 0a    	mov    %r10w,0xa(%rsp)
  403565:	66 44 89 5c 24 04    	mov    %r11w,0x4(%rsp)
  40356b:	66 89 54 24 06       	mov    %dx,0x6(%rsp)
  403570:	66 44 89 4c 24 08    	mov    %r9w,0x8(%rsp)
                        /*
                        ** locx.exp < locy.exp
                        */
                        StickyShiftRightMant(&locx,
                                -exponent_difference);
                        z->type = locy.type;
  403576:	88 0b                	mov    %cl,(%rbx)
                        z->sign = locy.sign ^ operation;
  403578:	0f b6 4c 24 11       	movzbl 0x11(%rsp),%ecx
                        z->exp = locy.exp;
  40357d:	66 89 43 02          	mov    %ax,0x2(%rbx)
  403581:	0f b6 44 24 01       	movzbl 0x1(%rsp),%eax
                        ** locx.exp < locy.exp
                        */
                        StickyShiftRightMant(&locx,
                                -exponent_difference);
                        z->type = locy.type;
                        z->sign = locy.sign ^ operation;
  403586:	89 ca                	mov    %ecx,%edx
  403588:	44 31 e2             	xor    %r12d,%edx
  40358b:	88 53 01             	mov    %dl,0x1(%rbx)
  40358e:	e9 6f fd ff ff       	jmpq   403302 <AddSubInternalFPF+0x202>
  403593:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                ** locx.exp == locy.exp
                ** so, no shifting required
                */
                if (locx.type == IFPF_IS_SUBNORMAL ||
                  locy.type == IFPF_IS_SUBNORMAL)
                        z->type = IFPF_IS_SUBNORMAL;
  403598:	b8 01 00 00 00       	mov    $0x1,%eax
  40359d:	e9 4d fd ff ff       	jmpq   4032ef <AddSubInternalFPF+0x1ef>
  4035a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                        {
                                z->type = IFPF_IS_ZERO;
                                z->sign = 0; /* positive */
                        }
                        else
                                if (locx.type == IFPF_IS_NORMAL ||
  4035a8:	80 3c 24 02          	cmpb   $0x2,(%rsp)
  4035ac:	74 0b                	je     4035b9 <AddSubInternalFPF+0x4b9>
  4035ae:	80 7c 24 10 02       	cmpb   $0x2,0x10(%rsp)
  4035b3:	0f 85 b7 fb ff ff    	jne    403170 <AddSubInternalFPF+0x70>
/*
** As long as there's a highmost 0 bit, shift the significand
** left 1 bit.  Each time you do this, though, you've
** gotta decrement the exponent.
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
  4035b9:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
  4035bd:	66 85 c0             	test   %ax,%ax
  4035c0:	0f 88 aa fb ff ff    	js     403170 <AddSubInternalFPF+0x70>
  4035c6:	0f b7 4b 02          	movzwl 0x2(%rbx),%ecx
  4035ca:	44 8d 49 ff          	lea    -0x1(%rcx),%r9d
  4035ce:	66 90                	xchg   %ax,%ax
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4035d0:	8d 0c 3f             	lea    (%rdi,%rdi,1),%ecx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4035d3:	89 ca                	mov    %ecx,%edx
  4035d5:	83 ca 01             	or     $0x1,%edx
  4035d8:	66 45 85 c0          	test   %r8w,%r8w
  4035dc:	0f 48 ca             	cmovs  %edx,%ecx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4035df:	8d 14 36             	lea    (%rsi,%rsi,1),%edx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4035e2:	41 89 d2             	mov    %edx,%r10d
  4035e5:	41 83 ca 01          	or     $0x1,%r10d
  4035e9:	66 85 ff             	test   %di,%di
  4035ec:	41 0f 48 d2          	cmovs  %r10d,%edx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4035f0:	01 c0                	add    %eax,%eax
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
{
        carry = 0;
        ShiftMantLeft1(&carry, ptr->mantissa);
        ptr->exp--;
  4035f2:	45 89 ca             	mov    %r9d,%r10d
for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4035f5:	89 c7                	mov    %eax,%edi
  4035f7:	83 cf 01             	or     $0x1,%edi
  4035fa:	66 85 f6             	test   %si,%si
  4035fd:	89 d6                	mov    %edx,%esi
  4035ff:	0f 48 c7             	cmovs  %edi,%eax
  403602:	41 83 e9 01          	sub    $0x1,%r9d
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  403606:	45 01 c0             	add    %r8d,%r8d
/*
** As long as there's a highmost 0 bit, shift the significand
** left 1 bit.  Each time you do this, though, you've
** gotta decrement the exponent.
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
  403609:	66 85 c0             	test   %ax,%ax
  40360c:	89 cf                	mov    %ecx,%edi
  40360e:	79 c0                	jns    4035d0 <AddSubInternalFPF+0x4d0>
  403610:	66 44 89 43 0a       	mov    %r8w,0xa(%rbx)
  403615:	66 89 4b 08          	mov    %cx,0x8(%rbx)
  403619:	66 89 53 06          	mov    %dx,0x6(%rbx)
  40361d:	66 89 43 04          	mov    %ax,0x4(%rbx)
  403621:	66 44 89 53 02       	mov    %r10w,0x2(%rbx)
  403626:	e9 45 fb ff ff       	jmpq   403170 <AddSubInternalFPF+0x70>
  40362b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                        for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
                        {
                                Add16Bits(&carry,
                                        &z->mantissa[i],
                                        locx.mantissa[i],
                                        locy.mantissa[i]);
  403630:	0f b7 4c 24 1a       	movzwl 0x1a(%rsp),%ecx
                        carry = 0;
                        for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
                        {
                                Add16Bits(&carry,
                                        &z->mantissa[i],
                                        locx.mantissa[i],
  403635:	0f b7 54 24 0a       	movzwl 0xa(%rsp),%edx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  40363a:	0f b7 44 24 08       	movzwl 0x8(%rsp),%eax
accum+=(u32)c;
  40363f:	0f b7 74 24 18       	movzwl 0x18(%rsp),%esi
                        carry = 0;
                        for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
                        {
                                Add16Bits(&carry,
                                        &z->mantissa[i],
                                        locx.mantissa[i],
  403644:	89 d7                	mov    %edx,%edi
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403646:	01 c6                	add    %eax,%esi
accum+=(u32)*carry;
  403648:	0f b7 c1             	movzwl %cx,%eax
  40364b:	01 cf                	add    %ecx,%edi
  40364d:	01 d0                	add    %edx,%eax
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  40364f:	0f b7 4c 24 16       	movzwl 0x16(%rsp),%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403654:	0f b7 54 24 06       	movzwl 0x6(%rsp),%edx
accum+=(u32)c;
accum+=(u32)*carry;
  403659:	c1 e8 10             	shr    $0x10,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  40365c:	66 89 7b 0a          	mov    %di,0xa(%rbx)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403660:	01 f0                	add    %esi,%eax
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403662:	0f b7 74 24 14       	movzwl 0x14(%rsp),%esi
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403667:	66 89 43 08          	mov    %ax,0x8(%rbx)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  40366b:	01 ca                	add    %ecx,%edx
accum+=(u32)*carry;
  40366d:	89 c1                	mov    %eax,%ecx
  40366f:	c1 e9 10             	shr    $0x10,%ecx
  403672:	83 e1 01             	and    $0x1,%ecx
  403675:	01 d1                	add    %edx,%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403677:	0f b7 54 24 04       	movzwl 0x4(%rsp),%edx
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  40367c:	66 89 4b 06          	mov    %cx,0x6(%rbx)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403680:	01 f2                	add    %esi,%edx
accum+=(u32)*carry;
  403682:	89 ce                	mov    %ecx,%esi
  403684:	c1 ee 10             	shr    $0x10,%esi
  403687:	83 e6 01             	and    $0x1,%esi
  40368a:	01 d6                	add    %edx,%esi
                                        &z->mantissa[i],
                                        locx.mantissa[i],
                                        locy.mantissa[i]);
                        }

                        if (carry)
  40368c:	f7 c6 00 00 01 00    	test   $0x10000,%esi
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403692:	66 89 73 04          	mov    %si,0x4(%rbx)
                                        &z->mantissa[i],
                                        locx.mantissa[i],
                                        locy.mantissa[i]);
                        }

                        if (carry)
  403696:	0f 84 f4 00 00 00    	je     403790 <AddSubInternalFPF+0x690>
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  40369c:	41 89 f0             	mov    %esi,%r8d
                                        locy.mantissa[i]);
                        }

                        if (carry)
                        {
                                z->exp++;
  40369f:	66 83 43 02 01       	addw   $0x1,0x2(%rbx)
                                carry=0;
                                ShiftMantRight1(&carry,z->mantissa);
  4036a4:	48 8d 53 04          	lea    0x4(%rbx),%rdx
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4036a8:	66 41 d1 e8          	shr    %r8w
                        {
                                z->exp++;
                                carry=0;
                                ShiftMantRight1(&carry,z->mantissa);
                                z->mantissa[0] |= 0x8000;
                                z->type = IFPF_IS_NORMAL;
  4036ac:	c6 03 02             	movb   $0x2,(%rbx)
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4036af:	66 44 89 43 04       	mov    %r8w,0x4(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4036b4:	41 89 c8             	mov    %ecx,%r8d
  4036b7:	66 41 d1 e8          	shr    %r8w
        if(*carry)
                accum|=0x8000;
  4036bb:	45 89 c1             	mov    %r8d,%r9d
  4036be:	66 41 81 c9 00 80    	or     $0x8000,%r9w
  4036c4:	83 e6 01             	and    $0x1,%esi
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4036c7:	89 c6                	mov    %eax,%esi
        if(*carry)
                accum|=0x8000;
  4036c9:	45 0f 45 c1          	cmovne %r9d,%r8d
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4036cd:	66 d1 ee             	shr    %si
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4036d0:	66 44 89 43 06       	mov    %r8w,0x6(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  4036d5:	41 89 f0             	mov    %esi,%r8d
  4036d8:	66 41 81 c8 00 80    	or     $0x8000,%r8w
  4036de:	83 e1 01             	and    $0x1,%ecx
  4036e1:	41 0f 45 f0          	cmovne %r8d,%esi
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4036e5:	66 d1 ef             	shr    %di
        if(*carry)
                accum|=0x8000;
  4036e8:	89 f9                	mov    %edi,%ecx
        *carry=new_carry;
        mantissa[i]=accum;
  4036ea:	66 89 73 08          	mov    %si,0x8(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  4036ee:	66 81 c9 00 80       	or     $0x8000,%cx
  4036f3:	a8 01                	test   $0x1,%al
  4036f5:	0f 45 f9             	cmovne %ecx,%edi
                        if (carry)
                        {
                                z->exp++;
                                carry=0;
                                ShiftMantRight1(&carry,z->mantissa);
                                z->mantissa[0] |= 0x8000;
  4036f8:	66 81 4b 04 00 80    	orw    $0x8000,0x4(%rbx)
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4036fe:	66 89 7b 0a          	mov    %di,0xa(%rbx)
  403702:	e9 ed fa ff ff       	jmpq   4031f4 <AddSubInternalFPF+0xf4>
  403707:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40370e:	00 00 
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  403710:	80 3b 00             	cmpb   $0x0,(%rbx)
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  403713:	b8 01 80 ff ff       	mov    $0xffff8001,%eax
  403718:	66 89 43 02          	mov    %ax,0x2(%rbx)
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  40371c:	0f 84 58 fa ff ff    	je     40317a <AddSubInternalFPF+0x7a>
int i;          /* Index */
int new_carry;
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
  403722:	0f b7 4b 04          	movzwl 0x4(%rbx),%ecx
  403726:	0f b7 53 06          	movzwl 0x6(%rbx),%edx
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  40372a:	89 c8                	mov    %ecx,%eax
  40372c:	66 d1 e8             	shr    %ax
  40372f:	66 89 43 04          	mov    %ax,0x4(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403733:	89 d0                	mov    %edx,%eax
  403735:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  403738:	89 c6                	mov    %eax,%esi
  40373a:	66 81 ce 00 80       	or     $0x8000,%si
  40373f:	83 e1 01             	and    $0x1,%ecx
  403742:	0f 45 c6             	cmovne %esi,%eax
int i;          /* Index */
int new_carry;
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
  403745:	0f b7 73 08          	movzwl 0x8(%rbx),%esi
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  403749:	66 89 43 06          	mov    %ax,0x6(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  40374d:	89 f0                	mov    %esi,%eax
  40374f:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  403752:	89 c1                	mov    %eax,%ecx
  403754:	66 81 c9 00 80       	or     $0x8000,%cx
  403759:	83 e2 01             	and    $0x1,%edx
  40375c:	0f 45 c1             	cmovne %ecx,%eax
int i;          /* Index */
int new_carry;
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
  40375f:	0f b7 4b 0a          	movzwl 0xa(%rbx),%ecx
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  403763:	66 89 43 08          	mov    %ax,0x8(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403767:	89 ca                	mov    %ecx,%edx
  403769:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
  40376c:	89 d0                	mov    %edx,%eax
  40376e:	66 0d 00 80          	or     $0x8000,%ax
  403772:	83 e6 01             	and    $0x1,%esi
  403775:	0f 45 d0             	cmovne %eax,%edx
        else
                for(i=0;i<amount;i++)
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  403778:	89 d0                	mov    %edx,%eax
  40377a:	83 c8 01             	or     $0x1,%eax
  40377d:	83 e1 01             	and    $0x1,%ecx
  403780:	0f 44 c2             	cmove  %edx,%eax
  403783:	e9 9a fa ff ff       	jmpq   403222 <AddSubInternalFPF+0x122>
  403788:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40378f:	00 
                                ShiftMantRight1(&carry,z->mantissa);
                                z->mantissa[0] |= 0x8000;
                                z->type = IFPF_IS_NORMAL;
                        }
                        else
                                if (z->mantissa[0] & 0x8000)
  403790:	66 83 7b 04 00       	cmpw   $0x0,0x4(%rbx)
  403795:	0f 89 d5 f9 ff ff    	jns    403170 <AddSubInternalFPF+0x70>
                                        z->type = IFPF_IS_NORMAL;
  40379b:	c6 03 02             	movb   $0x2,(%rbx)
  40379e:	48 8d 53 04          	lea    0x4(%rbx),%rdx
  4037a2:	e9 4d fa ff ff       	jmpq   4031f4 <AddSubInternalFPF+0xf4>
  4037a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4037ae:	00 00 
        ** and set the lowmost bit to 1.
        */
        if(amount>=INTERNAL_FPF_PRECISION * 16)
        {
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
  4037b0:	31 c0                	xor    %eax,%eax
  4037b2:	45 31 ed             	xor    %r13d,%r13d
  4037b5:	66 89 44 24 16       	mov    %ax,0x16(%rsp)
  4037ba:	31 c0                	xor    %eax,%eax
  4037bc:	66 44 89 6c 24 14    	mov    %r13w,0x14(%rsp)
  4037c2:	66 89 44 24 18       	mov    %ax,0x18(%rsp)
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
  4037c7:	b8 01 00 00 00       	mov    $0x1,%eax
  4037cc:	66 89 44 24 1a       	mov    %ax,0x1a(%rsp)
  4037d1:	e9 b7 fc ff ff       	jmpq   40348d <AddSubInternalFPF+0x38d>
        ** and set the lowmost bit to 1.
        */
        if(amount>=INTERNAL_FPF_PRECISION * 16)
        {
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
  4037d6:	45 31 c9             	xor    %r9d,%r9d
  4037d9:	45 31 d2             	xor    %r10d,%r10d
  4037dc:	45 31 db             	xor    %r11d,%r11d
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
  4037df:	bd 01 00 00 00       	mov    $0x1,%ebp
        ** and set the lowmost bit to 1.
        */
        if(amount>=INTERNAL_FPF_PRECISION * 16)
        {
                for(i=0;i<INTERNAL_FPF_PRECISION-1;i++)
                        mantissa[i]=0;
  4037e4:	66 44 89 4c 24 04    	mov    %r9w,0x4(%rsp)
  4037ea:	66 44 89 54 24 06    	mov    %r10w,0x6(%rsp)
  4037f0:	66 44 89 5c 24 08    	mov    %r11w,0x8(%rsp)
                mantissa[INTERNAL_FPF_PRECISION-1]=1;
  4037f6:	66 89 6c 24 0a       	mov    %bp,0xa(%rsp)
  4037fb:	e9 76 fd ff ff       	jmpq   403576 <AddSubInternalFPF+0x476>
/*
** All the math is done; time to round.
*/
RoundInternalFPF(z);
return;
}
  403800:	e8 fb d6 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  403805:	90                   	nop
  403806:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40380d:	00 00 00 

0000000000403810 <InternalFPFToString>:
**  conversion.  It should be more than enough for programmers
**  to determine whether the package is properly ported.
*/
static int InternalFPFToString(char *dest,
                InternalFPF *src)
{
  403810:	41 57                	push   %r15
  403812:	41 56                	push   %r14
  403814:	41 55                	push   %r13
  403816:	41 54                	push   %r12
  403818:	55                   	push   %rbp
  403819:	53                   	push   %rbx
  40381a:	48 89 fb             	mov    %rdi,%rbx
  40381d:	48 83 ec 68          	sub    $0x68,%rsp
  403821:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  403828:	00 00 
  40382a:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  40382f:	31 c0                	xor    %eax,%eax

/*
** Check first for the simple things...Nan, Infinity, Zero.
** If found, copy the proper string in and go home.
*/
switch(src->type)
  403831:	0f b6 06             	movzbl (%rsi),%eax
  403834:	3c 03                	cmp    $0x3,%al
  403836:	0f 84 cc 06 00 00    	je     403f08 <InternalFPFToString+0x6f8>
  40383c:	3c 04                	cmp    $0x4,%al
  40383e:	0f 84 ac 06 00 00    	je     403ef0 <InternalFPFToString+0x6e0>
  403844:	84 c0                	test   %al,%al
  403846:	0f 84 84 06 00 00    	je     403ed0 <InternalFPFToString+0x6c0>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
  40384c:	48 8b 06             	mov    (%rsi),%rax
if(mylong<(int32)0)
{       dest->sign=1;
        mylong=(int32)0-mylong;
}
else
        dest->sign=0;
  40384f:	c6 44 24 31 00       	movb   $0x0,0x31(%rsp)
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  403854:	ba 0a 00 00 00       	mov    $0xa,%edx
  403859:	c6 44 24 30 02       	movb   $0x2,0x30(%rsp)
  40385e:	b9 20 00 00 00       	mov    $0x20,%ecx
  403863:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403868:	8b 46 08             	mov    0x8(%rsi),%eax
  40386b:	89 44 24 28          	mov    %eax,0x28(%rsp)
  40386f:	31 c0                	xor    %eax,%eax
  403871:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  403878:	01 c0                	add    %eax,%eax
        if(*carry)
                accum|=1;               /* Insert previous carry */
  40387a:	89 c7                	mov    %eax,%edi
  40387c:	83 cf 01             	or     $0x1,%edi
  40387f:	66 85 d2             	test   %dx,%dx
  403882:	0f 48 c7             	cmovs  %edi,%eax
  403885:	83 e9 01             	sub    $0x1,%ecx
  403888:	01 d2                	add    %edx,%edx
/*
** As long as there's a highmost 0 bit, shift the significand
** left 1 bit.  Each time you do this, though, you've
** gotta decrement the exponent.
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
  40388a:	66 85 c0             	test   %ax,%ax
  40388d:	79 e9                	jns    403878 <InternalFPFToString+0x68>
  40388f:	31 ff                	xor    %edi,%edi
  403891:	45 31 c0             	xor    %r8d,%r8d
  403894:	66 89 54 24 36       	mov    %dx,0x36(%rsp)
  403899:	66 89 7c 24 3a       	mov    %di,0x3a(%rsp)
  40389e:	66 44 89 44 24 38    	mov    %r8w,0x38(%rsp)
msign=src->sign;

/* src->sign=0 */ /* bug, fixed Nov. 13, 1997 */
(&locFPFNum)->sign=0;

expcount=0;             /* Init exponent counter */
  4038a4:	45 31 e4             	xor    %r12d,%r12d
  4038a7:	66 89 44 24 34       	mov    %ax,0x34(%rsp)
  4038ac:	66 89 4c 24 32       	mov    %cx,0x32(%rsp)
Int32ToInternalFPF((int32)10,&IFPF10);

/*
** Save the mantissa sign and make it positive.
*/
msign=src->sign;
  4038b1:	0f b6 6e 01          	movzbl 0x1(%rsi),%ebp

/* src->sign=0 */ /* bug, fixed Nov. 13, 1997 */
(&locFPFNum)->sign=0;
  4038b5:	c6 44 24 21 00       	movb   $0x0,0x21(%rsp)
  4038ba:	eb 2e                	jmp    4038ea <InternalFPFToString+0xda>
  4038bc:	0f 1f 40 00          	nopl   0x0(%rax)
*/

while(1)
{       AddSubInternalFPF(1,&locFPFNum,&IFPF10,&IFPFComp);
        if(IFPFComp.sign==0) break;
        MultiplyInternalFPF(&locFPFNum,&IFPF10,&IFPFComp);
  4038c0:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
  4038c5:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
  4038ca:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
        expcount--;
  4038cf:	41 83 ec 01          	sub    $0x1,%r12d
*/

while(1)
{       AddSubInternalFPF(1,&locFPFNum,&IFPF10,&IFPFComp);
        if(IFPFComp.sign==0) break;
        MultiplyInternalFPF(&locFPFNum,&IFPF10,&IFPFComp);
  4038d3:	e8 f8 f1 ff ff       	callq  402ad0 <MultiplyInternalFPF>
  4038d8:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  4038dd:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  4038e2:	8b 44 24 48          	mov    0x48(%rsp),%eax
  4038e6:	89 44 24 28          	mov    %eax,0x28(%rsp)
** multiplication, decrement a counter so we can keep track
** of the exponent.
*/

while(1)
{       AddSubInternalFPF(1,&locFPFNum,&IFPF10,&IFPFComp);
  4038ea:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
  4038ef:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
  4038f4:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  4038f9:	bf 01 00 00 00       	mov    $0x1,%edi
  4038fe:	e8 fd f7 ff ff       	callq  403100 <AddSubInternalFPF>
        if(IFPFComp.sign==0) break;
  403903:	80 7c 24 41 00       	cmpb   $0x0,0x41(%rsp)
  403908:	75 b6                	jne    4038c0 <InternalFPFToString+0xb0>
  40390a:	eb 2e                	jmp    40393a <InternalFPFToString+0x12a>
  40390c:	0f 1f 40 00          	nopl   0x0(%rax)

while(1)
{
        AddSubInternalFPF(1,&locFPFNum,&IFPF10,&IFPFComp);
        if(IFPFComp.sign!=0) break;
        DivideInternalFPF(&locFPFNum,&IFPF10,&IFPFComp);
  403910:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
  403915:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
  40391a:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
        expcount++;
  40391f:	41 83 c4 01          	add    $0x1,%r12d

while(1)
{
        AddSubInternalFPF(1,&locFPFNum,&IFPF10,&IFPFComp);
        if(IFPFComp.sign!=0) break;
        DivideInternalFPF(&locFPFNum,&IFPF10,&IFPFComp);
  403923:	e8 78 eb ff ff       	callq  4024a0 <DivideInternalFPF>
  403928:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40392d:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403932:	8b 44 24 48          	mov    0x48(%rsp),%eax
  403936:	89 44 24 28          	mov    %eax,0x28(%rsp)
** exponent counter for each multiplication.
*/

while(1)
{
        AddSubInternalFPF(1,&locFPFNum,&IFPF10,&IFPFComp);
  40393a:	48 8d 4c 24 40       	lea    0x40(%rsp),%rcx
  40393f:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
  403944:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
  403949:	bf 01 00 00 00       	mov    $0x1,%edi
  40394e:	e8 ad f7 ff ff       	callq  403100 <AddSubInternalFPF>
        if(IFPFComp.sign!=0) break;
  403953:	80 7c 24 41 00       	cmpb   $0x0,0x41(%rsp)
  403958:	74 b6                	je     403910 <InternalFPFToString+0x100>
/*
** About time to start storing things.  First, store the
** mantissa sign.
*/
ccount=1;               /* Init character counter */
if(msign==0)
  40395a:	40 84 ed             	test   %bpl,%bpl
  40395d:	44 89 64 24 1c       	mov    %r12d,0x1c(%rsp)
        *dest++='+';
  403962:	4c 8d 53 01          	lea    0x1(%rbx),%r10
  403966:	b8 2b 00 00 00       	mov    $0x2b,%eax
/*
** About time to start storing things.  First, store the
** mantissa sign.
*/
ccount=1;               /* Init character counter */
if(msign==0)
  40396b:	0f 85 d7 05 00 00    	jne    403f48 <InternalFPFToString+0x738>
*/
/*
** Re-position radix point
*/
carryaccum=0;
while(locFPFNum.exp>0)
  403971:	0f b7 7c 24 22       	movzwl 0x22(%rsp),%edi
  403976:	88 03                	mov    %al,(%rbx)
  403978:	66 83 ff 00          	cmp    $0x0,%di
  40397c:	0f 8e d0 05 00 00    	jle    403f52 <InternalFPFToString+0x742>
  403982:	44 0f b7 44 24 2a    	movzwl 0x2a(%rsp),%r8d
  403988:	44 0f b7 4c 24 28    	movzwl 0x28(%rsp),%r9d
  40398e:	31 c0                	xor    %eax,%eax
  403990:	44 0f b7 5c 24 26    	movzwl 0x26(%rsp),%r11d
  403996:	0f b7 54 24 24       	movzwl 0x24(%rsp),%edx
  40399b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4039a0:	43 8d 34 09          	lea    (%r9,%r9,1),%esi
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4039a4:	89 f1                	mov    %esi,%ecx
  4039a6:	83 c9 01             	or     $0x1,%ecx
  4039a9:	66 45 85 c0          	test   %r8w,%r8w
  4039ad:	0f 48 f1             	cmovs  %ecx,%esi
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4039b0:	43 8d 0c 1b          	lea    (%r11,%r11,1),%ecx
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4039b4:	89 cb                	mov    %ecx,%ebx
  4039b6:	83 cb 01             	or     $0x1,%ebx
  4039b9:	66 45 85 c9          	test   %r9w,%r9w
  4039bd:	41 89 d1             	mov    %edx,%r9d
  4039c0:	0f 48 cb             	cmovs  %ebx,%ecx
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4039c3:	01 d2                	add    %edx,%edx
  4039c5:	66 41 81 e1 00 80    	and    $0x8000,%r9w
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4039cb:	89 d3                	mov    %edx,%ebx
  4039cd:	83 cb 01             	or     $0x1,%ebx
  4039d0:	66 45 85 db          	test   %r11w,%r11w
  4039d4:	41 89 cb             	mov    %ecx,%r11d
  4039d7:	0f 48 d3             	cmovs  %ebx,%edx
carryaccum=0;
while(locFPFNum.exp>0)
{
        mycarry=0;
        ShiftMantLeft1(&mycarry,locFPFNum.mantissa);
        carryaccum=(carryaccum<<1);
  4039da:	01 c0                	add    %eax,%eax
        if(mycarry) carryaccum++;
  4039dc:	66 41 83 f9 01       	cmp    $0x1,%r9w
  4039e1:	66 83 d8 ff          	sbb    $0xffff,%ax
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4039e5:	45 01 c0             	add    %r8d,%r8d
*/
/*
** Re-position radix point
*/
carryaccum=0;
while(locFPFNum.exp>0)
  4039e8:	66 83 ef 01          	sub    $0x1,%di
  4039ec:	41 89 f1             	mov    %esi,%r9d
  4039ef:	75 af                	jne    4039a0 <InternalFPFToString+0x190>
  4039f1:	66 89 54 24 24       	mov    %dx,0x24(%rsp)
  4039f6:	31 d2                	xor    %edx,%edx
  4039f8:	66 89 4c 24 26       	mov    %cx,0x26(%rsp)
  4039fd:	66 89 74 24 28       	mov    %si,0x28(%rsp)
  403a02:	66 44 89 44 24 2a    	mov    %r8w,0x2a(%rsp)
  403a08:	66 89 54 24 22       	mov    %dx,0x22(%rsp)
  403a0d:	49 8d 5a 01          	lea    0x1(%r10),%rbx
  403a11:	4c 8b 7c 24 20       	mov    0x20(%rsp),%r15
  403a16:	c7 44 24 18 02 00 00 	movl   $0x2,0x18(%rsp)
  403a1d:	00 
  403a1e:	44 8b 74 24 28       	mov    0x28(%rsp),%r14d
  403a23:	48 89 1c 24          	mov    %rbx,(%rsp)
  403a27:	bb 01 00 00 00       	mov    $0x1,%ebx
  403a2c:	4d 89 f8             	mov    %r15,%r8
  403a2f:	41 89 df             	mov    %ebx,%r15d
  403a32:	eb 12                	jmp    403a46 <InternalFPFToString+0x236>
  403a34:	0f 1f 40 00          	nopl   0x0(%rax)
  403a38:	48 83 04 24 01       	addq   $0x1,(%rsp)
  403a3d:	83 44 24 18 01       	addl   $0x1,0x18(%rsp)
  403a42:	41 83 c7 01          	add    $0x1,%r15d
        ShiftMantRight1(&mycarry,locFPFNum.mantissa);
        locFPFNum.exp++;
}

for(i=0;i<6;i++)
        if(i==1)
  403a46:	41 83 ff 02          	cmp    $0x2,%r15d
  403a4a:	0f 84 96 05 00 00    	je     403fe6 <InternalFPFToString+0x7d6>
                *dest++='.';
                ccount++;
        }
        else
        {       /* Emit a digit */
                *dest++=('0'+carryaccum);
  403a50:	83 c0 30             	add    $0x30,%eax
  403a53:	45 0f b7 ce          	movzwl %r14w,%r9d
  403a57:	48 8b 1c 24          	mov    (%rsp),%rbx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403a5b:	0f b7 4c 24 2a       	movzwl 0x2a(%rsp),%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403a60:	0f b7 54 24 28       	movzwl 0x28(%rsp),%edx
  403a65:	4c 89 44 24 30       	mov    %r8,0x30(%rsp)
  403a6a:	44 89 74 24 38       	mov    %r14d,0x38(%rsp)
                *dest++='.';
                ccount++;
        }
        else
        {       /* Emit a digit */
                *dest++=('0'+carryaccum);
  403a6f:	88 43 ff             	mov    %al,-0x1(%rbx)
  403a72:	4c 89 c0             	mov    %r8,%rax
  403a75:	49 c1 e8 30          	shr    $0x30,%r8
  403a79:	48 c1 e8 20          	shr    $0x20,%rax
  403a7d:	49 89 c3             	mov    %rax,%r11
  403a80:	44 89 f0             	mov    %r14d,%eax
  403a83:	c1 e8 10             	shr    $0x10,%eax
  403a86:	45 0f b7 db          	movzwl %r11w,%r11d
  403a8a:	89 c3                	mov    %eax,%ebx
  403a8c:	0f b7 e8             	movzwl %ax,%ebp
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403a8f:	89 c8                	mov    %ecx,%eax
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403a91:	01 d8                	add    %ebx,%eax
  403a93:	66 89 44 24 4a       	mov    %ax,0x4a(%rsp)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403a98:	41 8d 04 11          	lea    (%r9,%rdx,1),%eax
accum+=(u32)*carry;
  403a9c:	8d 54 0d 00          	lea    0x0(%rbp,%rcx,1),%edx
  403aa0:	c1 ea 10             	shr    $0x10,%edx
  403aa3:	01 c2                	add    %eax,%edx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403aa5:	0f b7 44 24 26       	movzwl 0x26(%rsp),%eax
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403aaa:	66 89 54 24 48       	mov    %dx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403aaf:	c1 ea 10             	shr    $0x10,%edx
  403ab2:	8b 4c 24 48          	mov    0x48(%rsp),%ecx
  403ab6:	83 e2 01             	and    $0x1,%edx
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403ab9:	44 01 c0             	add    %r8d,%eax
accum+=(u32)*carry;
  403abc:	01 d0                	add    %edx,%eax

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403abe:	0f b7 54 24 24       	movzwl 0x24(%rsp),%edx
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403ac3:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403ac8:	c1 e8 10             	shr    $0x10,%eax
  403acb:	83 e0 01             	and    $0x1,%eax
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403ace:	44 01 da             	add    %r11d,%edx
accum+=(u32)*carry;
  403ad1:	01 d0                	add    %edx,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403ad3:	66 89 44 24 44       	mov    %ax,0x44(%rsp)
  403ad8:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  403add:	89 44 24 14          	mov    %eax,0x14(%rsp)
  403ae1:	48 89 d7             	mov    %rdx,%rdi

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403ae4:	48 c1 ea 30          	shr    $0x30,%rdx
  403ae8:	48 c1 ef 20          	shr    $0x20,%rdi
accum+=(u32)c;
  403aec:	44 01 c2             	add    %r8d,%edx
  403aef:	48 89 fe             	mov    %rdi,%rsi
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403af2:	89 cf                	mov    %ecx,%edi

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403af4:	0f b7 c9             	movzwl %cx,%ecx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403af7:	c1 ef 10             	shr    $0x10,%edi

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403afa:	0f b7 f6             	movzwl %si,%esi
  403afd:	0f b7 c7             	movzwl %di,%eax
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b00:	01 df                	add    %ebx,%edi
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403b02:	44 01 de             	add    %r11d,%esi
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b05:	66 89 7c 24 4a       	mov    %di,0x4a(%rsp)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403b0a:	41 8d 3c 09          	lea    (%r9,%rcx,1),%edi
accum+=(u32)*carry;
  403b0e:	8d 4c 05 00          	lea    0x0(%rbp,%rax,1),%ecx
  403b12:	c1 e9 10             	shr    $0x10,%ecx
  403b15:	01 f9                	add    %edi,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b17:	66 89 4c 24 48       	mov    %cx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403b1c:	c1 e9 10             	shr    $0x10,%ecx
  403b1f:	83 e1 01             	and    $0x1,%ecx
  403b22:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b25:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403b2a:	c1 e8 10             	shr    $0x10,%eax
  403b2d:	83 e0 01             	and    $0x1,%eax
  403b30:	8d 3c 30             	lea    (%rax,%rsi,1),%edi
  403b33:	8b 44 24 48          	mov    0x48(%rsp),%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b37:	66 89 7c 24 44       	mov    %di,0x44(%rsp)
  403b3c:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403b41:	89 c1                	mov    %eax,%ecx
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b43:	89 7c 24 0c          	mov    %edi,0xc(%rsp)

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403b47:	0f b7 c0             	movzwl %ax,%eax
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403b4a:	c1 e9 10             	shr    $0x10,%ecx
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403b4d:	44 01 c8             	add    %r9d,%eax
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403b50:	89 cf                	mov    %ecx,%edi

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403b52:	0f b7 c9             	movzwl %cx,%ecx
  403b55:	48 89 d6             	mov    %rdx,%rsi
accum+=(u32)c;
accum+=(u32)*carry;
  403b58:	01 e9                	add    %ebp,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b5a:	01 df                	add    %ebx,%edi
  403b5c:	48 c1 ee 20          	shr    $0x20,%rsi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403b60:	c1 e9 10             	shr    $0x10,%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403b63:	48 c1 ea 30          	shr    $0x30,%rdx
  403b67:	0f b7 f6             	movzwl %si,%esi
accum+=(u32)c;
accum+=(u32)*carry;
  403b6a:	01 c1                	add    %eax,%ecx
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403b6c:	44 01 c2             	add    %r8d,%edx
  403b6f:	44 01 de             	add    %r11d,%esi
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b72:	66 89 4c 24 48       	mov    %cx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403b77:	c1 e9 10             	shr    $0x10,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b7a:	66 89 7c 24 4a       	mov    %di,0x4a(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403b7f:	83 e1 01             	and    $0x1,%ecx
  403b82:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b85:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403b8a:	c1 e8 10             	shr    $0x10,%eax
  403b8d:	83 e0 01             	and    $0x1,%eax
  403b90:	01 c6                	add    %eax,%esi
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403b92:	66 89 74 24 44       	mov    %si,0x44(%rsp)
  403b97:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  403b9c:	89 74 24 10          	mov    %esi,0x10(%rsp)
  403ba0:	48 89 c1             	mov    %rax,%rcx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403ba3:	48 c1 e8 30          	shr    $0x30,%rax
  403ba7:	48 c1 e9 20          	shr    $0x20,%rcx
  403bab:	48 89 ce             	mov    %rcx,%rsi
  403bae:	8b 4c 24 48          	mov    0x48(%rsp),%ecx
  403bb2:	44 0f b7 d6          	movzwl %si,%r10d
accum+=(u32)c;
  403bb6:	45 01 da             	add    %r11d,%r10d
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403bb9:	89 ca                	mov    %ecx,%edx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403bbb:	0f b7 c9             	movzwl %cx,%ecx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403bbe:	c1 ea 10             	shr    $0x10,%edx
  403bc1:	89 d7                	mov    %edx,%edi

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403bc3:	0f b7 d2             	movzwl %dx,%edx
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403bc6:	01 df                	add    %ebx,%edi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403bc8:	01 ea                	add    %ebp,%edx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403bca:	66 89 7c 24 4a       	mov    %di,0x4a(%rsp)
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403bcf:	41 8d 3c 09          	lea    (%r9,%rcx,1),%edi
accum+=(u32)*carry;
  403bd3:	c1 ea 10             	shr    $0x10,%edx
  403bd6:	8d 0c 3a             	lea    (%rdx,%rdi,1),%ecx
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403bd9:	42 8d 14 00          	lea    (%rax,%r8,1),%edx
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403bdd:	66 89 4c 24 48       	mov    %cx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403be2:	c1 e9 10             	shr    $0x10,%ecx
  403be5:	83 e1 01             	and    $0x1,%ecx
  403be8:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403beb:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403bf0:	c1 e8 10             	shr    $0x10,%eax
  403bf3:	83 e0 01             	and    $0x1,%eax
  403bf6:	41 01 c2             	add    %eax,%r10d
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403bf9:	66 44 89 54 24 44    	mov    %r10w,0x44(%rsp)
  403bff:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  403c04:	48 89 d1             	mov    %rdx,%rcx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c07:	48 c1 ea 30          	shr    $0x30,%rdx
  403c0b:	48 c1 e9 20          	shr    $0x20,%rcx
accum+=(u32)c;
  403c0f:	44 01 c2             	add    %r8d,%edx
  403c12:	48 89 ce             	mov    %rcx,%rsi
  403c15:	8b 4c 24 48          	mov    0x48(%rsp),%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c19:	0f b7 f6             	movzwl %si,%esi
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403c1c:	41 89 ce             	mov    %ecx,%r14d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c1f:	0f b7 c9             	movzwl %cx,%ecx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403c22:	41 c1 ee 10          	shr    $0x10,%r14d
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403c26:	44 01 c9             	add    %r9d,%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c29:	41 0f b7 c6          	movzwl %r14w,%eax
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403c2d:	44 89 f7             	mov    %r14d,%edi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c30:	01 e8                	add    %ebp,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c32:	01 df                	add    %ebx,%edi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c34:	c1 e8 10             	shr    $0x10,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c37:	66 89 7c 24 4a       	mov    %di,0x4a(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c3c:	01 c1                	add    %eax,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c3e:	66 89 4c 24 48       	mov    %cx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c43:	c1 e9 10             	shr    $0x10,%ecx
  403c46:	83 e1 01             	and    $0x1,%ecx
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403c49:	44 01 de             	add    %r11d,%esi
accum+=(u32)*carry;
  403c4c:	8d 04 0a             	lea    (%rdx,%rcx,1),%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c4f:	66 89 44 24 46       	mov    %ax,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c54:	c1 e8 10             	shr    $0x10,%eax
  403c57:	83 e0 01             	and    $0x1,%eax
  403c5a:	8d 3c 06             	lea    (%rsi,%rax,1),%edi
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c5d:	66 89 7c 24 44       	mov    %di,0x44(%rsp)
  403c62:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  403c67:	48 89 d1             	mov    %rdx,%rcx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c6a:	48 c1 ea 30          	shr    $0x30,%rdx
  403c6e:	48 c1 e9 20          	shr    $0x20,%rcx
accum+=(u32)c;
  403c72:	44 01 c2             	add    %r8d,%edx
  403c75:	49 89 cc             	mov    %rcx,%r12
  403c78:	8b 4c 24 48          	mov    0x48(%rsp),%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c7c:	45 0f b7 e4          	movzwl %r12w,%r12d
accum+=(u32)c;
  403c80:	45 01 dc             	add    %r11d,%r12d
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403c83:	41 89 ce             	mov    %ecx,%r14d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c86:	0f b7 c9             	movzwl %cx,%ecx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403c89:	41 c1 ee 10          	shr    $0x10,%r14d
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403c8d:	44 01 c9             	add    %r9d,%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403c90:	41 0f b7 c6          	movzwl %r14w,%eax
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403c94:	44 89 f6             	mov    %r14d,%esi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c97:	01 e8                	add    %ebp,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c99:	01 de                	add    %ebx,%esi
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403c9b:	c1 e8 10             	shr    $0x10,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403c9e:	66 89 74 24 4a       	mov    %si,0x4a(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403ca3:	01 c1                	add    %eax,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403ca5:	66 89 4c 24 48       	mov    %cx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403caa:	c1 e9 10             	shr    $0x10,%ecx
  403cad:	83 e1 01             	and    $0x1,%ecx
  403cb0:	01 ca                	add    %ecx,%edx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403cb2:	66 89 54 24 46       	mov    %dx,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403cb7:	c1 ea 10             	shr    $0x10,%edx
  403cba:	83 e2 01             	and    $0x1,%edx
  403cbd:	41 8d 34 14          	lea    (%r12,%rdx,1),%esi
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403cc1:	66 89 74 24 44       	mov    %si,0x44(%rsp)
  403cc6:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  403ccb:	48 89 d1             	mov    %rdx,%rcx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403cce:	48 c1 ea 30          	shr    $0x30,%rdx
  403cd2:	48 c1 e9 20          	shr    $0x20,%rcx
accum+=(u32)c;
  403cd6:	44 01 c2             	add    %r8d,%edx
  403cd9:	49 89 cc             	mov    %rcx,%r12
  403cdc:	8b 4c 24 48          	mov    0x48(%rsp),%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403ce0:	45 0f b7 e4          	movzwl %r12w,%r12d
accum+=(u32)c;
  403ce4:	45 01 dc             	add    %r11d,%r12d
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403ce7:	41 89 ce             	mov    %ecx,%r14d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403cea:	0f b7 c9             	movzwl %cx,%ecx
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403ced:	41 c1 ee 10          	shr    $0x10,%r14d
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403cf1:	44 01 c9             	add    %r9d,%ecx

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403cf4:	41 0f b7 c6          	movzwl %r14w,%eax
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403cf8:	45 89 f5             	mov    %r14d,%r13d
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403cfb:	01 e8                	add    %ebp,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403cfd:	41 01 dd             	add    %ebx,%r13d
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d00:	c1 e8 10             	shr    $0x10,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d03:	66 44 89 6c 24 4a    	mov    %r13w,0x4a(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d09:	01 c1                	add    %eax,%ecx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d0b:	66 89 4c 24 48       	mov    %cx,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d10:	c1 e9 10             	shr    $0x10,%ecx
  403d13:	83 e1 01             	and    $0x1,%ecx
  403d16:	01 ca                	add    %ecx,%edx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d18:	66 89 54 24 46       	mov    %dx,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d1d:	c1 ea 10             	shr    $0x10,%edx
  403d20:	83 e2 01             	and    $0x1,%edx
  403d23:	41 8d 0c 14          	lea    (%r12,%rdx,1),%ecx
  403d27:	44 8b 64 24 48       	mov    0x48(%rsp),%r12d
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d2c:	66 89 4c 24 44       	mov    %cx,0x44(%rsp)
  403d31:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  403d36:	49 89 d6             	mov    %rdx,%r14

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403d39:	48 c1 ea 30          	shr    $0x30,%rdx
  403d3d:	49 c1 ee 20          	shr    $0x20,%r14
accum+=(u32)c;
  403d41:	44 01 c2             	add    %r8d,%edx
  403d44:	4d 89 f5             	mov    %r14,%r13
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403d47:	45 89 e6             	mov    %r12d,%r14d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403d4a:	45 0f b7 e4          	movzwl %r12w,%r12d
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403d4e:	41 c1 ee 10          	shr    $0x10,%r14d
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403d52:	45 01 cc             	add    %r9d,%r12d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403d55:	45 0f b7 ed          	movzwl %r13w,%r13d
  403d59:	41 0f b7 c6          	movzwl %r14w,%eax
accum+=(u32)c;
  403d5d:	45 01 dd             	add    %r11d,%r13d
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d60:	41 01 de             	add    %ebx,%r14d
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d63:	01 e8                	add    %ebp,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d65:	66 44 89 74 24 4a    	mov    %r14w,0x4a(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d6b:	c1 e8 10             	shr    $0x10,%eax
  403d6e:	41 01 c4             	add    %eax,%r12d
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d71:	66 44 89 64 24 48    	mov    %r12w,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d77:	41 c1 ec 10          	shr    $0x10,%r12d
  403d7b:	41 83 e4 01          	and    $0x1,%r12d
  403d7f:	44 01 e2             	add    %r12d,%edx
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d82:	66 89 54 24 46       	mov    %dx,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403d87:	c1 ea 10             	shr    $0x10,%edx
  403d8a:	83 e2 01             	and    $0x1,%edx
  403d8d:	44 01 ea             	add    %r13d,%edx
  403d90:	44 8b 6c 24 48       	mov    0x48(%rsp),%r13d
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403d95:	66 89 54 24 44       	mov    %dx,0x44(%rsp)
  403d9a:	4c 8b 74 24 40       	mov    0x40(%rsp),%r14
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403d9f:	45 89 ec             	mov    %r13d,%r12d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403da2:	45 0f b7 ed          	movzwl %r13w,%r13d
                for(j=0;j<9;j++)
                {
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
  403da6:	41 c1 ec 10          	shr    $0x10,%r12d
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403daa:	45 01 cd             	add    %r9d,%r13d

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403dad:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  403db2:	41 0f b7 c4          	movzwl %r12w,%eax
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403db6:	44 01 e3             	add    %r12d,%ebx
  403db9:	49 c1 ee 20          	shr    $0x20,%r14
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403dbd:	01 e8                	add    %ebp,%eax
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403dbf:	66 89 5c 24 4a       	mov    %bx,0x4a(%rsp)

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403dc4:	45 0f b7 f6          	movzwl %r14w,%r14d
accum+=(u32)c;
accum+=(u32)*carry;
  403dc8:	c1 e8 10             	shr    $0x10,%eax

/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
  403dcb:	49 c1 e9 30          	shr    $0x30,%r9
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
                                        IFPF10.mantissa[k]);
                        carryaccum+=mycarry ? 1 : 0;
  403dcf:	8b 5c 24 0c          	mov    0xc(%rsp),%ebx
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403dd3:	41 01 c5             	add    %eax,%r13d
/*
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
  403dd6:	45 01 c8             	add    %r9d,%r8d
  403dd9:	45 01 de             	add    %r11d,%r14d
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403ddc:	66 44 89 6c 24 48    	mov    %r13w,0x48(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403de2:	41 c1 ed 10          	shr    $0x10,%r13d
  403de6:	41 83 e5 01          	and    $0x1,%r13d
  403dea:	47 8d 24 28          	lea    (%r8,%r13,1),%r12d
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403dee:	66 44 89 64 24 46    	mov    %r12w,0x46(%rsp)
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403df4:	41 c1 ec 10          	shr    $0x10,%r12d
  403df8:	41 83 e4 01          	and    $0x1,%r12d
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
                                        IFPF10.mantissa[k]);
                        carryaccum+=mycarry ? 1 : 0;
  403dfc:	c1 eb 10             	shr    $0x10,%ebx
  403dff:	41 c1 ea 10          	shr    $0x10,%r10d
** Do the work in the 32-bit accumulator so we can return
** the carry.
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
  403e03:	47 8d 1c 26          	lea    (%r14,%r12,1),%r11d
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
                                        IFPF10.mantissa[k]);
                        carryaccum+=mycarry ? 1 : 0;
  403e07:	41 89 d8             	mov    %ebx,%r8d
  403e0a:	41 83 e2 01          	and    $0x1,%r10d
  403e0e:	41 83 e0 01          	and    $0x1,%r8d
  403e12:	c1 ef 10             	shr    $0x10,%edi
  403e15:	c1 ee 10             	shr    $0x10,%esi
*/
accum=(u32)b;
accum+=(u32)c;
accum+=(u32)*carry;
*carry=(u16)((accum & 0x00010000) ? 1 : 0);     /* New carry */
*a=(u16)(accum & 0xFFFF);       /* Result is lo 16 bits */
  403e18:	66 44 89 5c 24 44    	mov    %r11w,0x44(%rsp)
                        mycarry=0;
                        for(k=(INTERNAL_FPF_PRECISION-1);k>=0;k--)
                                Add16Bits(&mycarry,&(IFPFComp.mantissa[k]),
                                        locFPFNum.mantissa[k],
                                        IFPF10.mantissa[k]);
                        carryaccum+=mycarry ? 1 : 0;
  403e1e:	8b 5c 24 10          	mov    0x10(%rsp),%ebx
  403e22:	83 e7 01             	and    $0x1,%edi
  403e25:	83 e6 01             	and    $0x1,%esi
  403e28:	c1 e9 10             	shr    $0x10,%ecx
  403e2b:	c1 ea 10             	shr    $0x10,%edx
  403e2e:	83 e1 01             	and    $0x1,%ecx
  403e31:	83 e2 01             	and    $0x1,%edx
  403e34:	41 c1 eb 10          	shr    $0x10,%r11d
  403e38:	c1 eb 10             	shr    $0x10,%ebx
  403e3b:	41 83 e3 01          	and    $0x1,%r11d
  403e3f:	44 8b 74 24 48       	mov    0x48(%rsp),%r14d
  403e44:	89 d8                	mov    %ebx,%eax
  403e46:	83 e0 01             	and    $0x1,%eax
  403e49:	44 01 c0             	add    %r8d,%eax
  403e4c:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
  403e51:	44 89 74 24 28       	mov    %r14d,0x28(%rsp)
  403e56:	44 01 d0             	add    %r10d,%eax
  403e59:	01 f8                	add    %edi,%eax
  403e5b:	01 f0                	add    %esi,%eax
  403e5d:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  403e62:	01 c8                	add    %ecx,%eax
  403e64:	01 d0                	add    %edx,%eax
  403e66:	42 8d 14 18          	lea    (%rax,%r11,1),%edx
  403e6a:	8b 44 24 14          	mov    0x14(%rsp),%eax
  403e6e:	c1 e8 10             	shr    $0x10,%eax
  403e71:	83 e0 01             	and    $0x1,%eax
  403e74:	01 d0                	add    %edx,%eax
        mycarry=0;
        ShiftMantRight1(&mycarry,locFPFNum.mantissa);
        locFPFNum.exp++;
}

for(i=0;i<6;i++)
  403e76:	41 83 ff 06          	cmp    $0x6,%r15d
  403e7a:	0f 85 b8 fb ff ff    	jne    403a38 <InternalFPFToString+0x228>

/*
** Now move the 'E', the exponent sign, and the exponent
** into the string.
*/
*dest++='E';
  403e80:	48 8b 04 24          	mov    (%rsp),%rax

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  403e84:	44 8b 44 24 1c       	mov    0x1c(%rsp),%r8d
  403e89:	b9 a0 cd 40 00       	mov    $0x40cda0,%ecx
  403e8e:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  403e95:	be 01 00 00 00       	mov    $0x1,%esi
  403e9a:	48 8d 78 01          	lea    0x1(%rax),%rdi
  403e9e:	c6 00 45             	movb   $0x45,(%rax)
  403ea1:	31 c0                	xor    %eax,%eax
  403ea3:	e8 08 d2 ff ff       	callq  4010b0 <__sprintf_chk@plt>
ccount+=(int)sprintf(dest,"%4d",expcount);

/*
** All done, go home.
*/
return(ccount);
  403ea8:	03 44 24 18          	add    0x18(%rsp),%eax

}
  403eac:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
  403eb1:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  403eb8:	00 00 
  403eba:	0f 85 33 01 00 00    	jne    403ff3 <InternalFPFToString+0x7e3>
  403ec0:	48 83 c4 68          	add    $0x68,%rsp
  403ec4:	5b                   	pop    %rbx
  403ec5:	5d                   	pop    %rbp
  403ec6:	41 5c                	pop    %r12
  403ec8:	41 5d                	pop    %r13
  403eca:	41 5e                	pop    %r14
  403ecc:	41 5f                	pop    %r15
  403ece:	c3                   	retq   
  403ecf:	90                   	nop
                else
                        memcpy(dest,"-Inf",4);
                return(4);

        case IFPF_IS_ZERO:
                if(src->sign==0)
  403ed0:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
  403ed4:	75 5a                	jne    403f30 <InternalFPFToString+0x720>
  403ed6:	41 ba 2b 30 00 00    	mov    $0x302b,%r10d
                        memcpy(dest,"+0",2);
                else
                        memcpy(dest,"-0",2);
                return(2);
  403edc:	b8 02 00 00 00       	mov    $0x2,%eax
  403ee1:	66 44 89 17          	mov    %r10w,(%rdi)
  403ee5:	eb c5                	jmp    403eac <InternalFPFToString+0x69c>
  403ee7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  403eee:	00 00 
  403ef0:	41 bb 4e 61 00 00    	mov    $0x614e,%r11d
  403ef6:	c6 47 02 4e          	movb   $0x4e,0x2(%rdi)
*/
switch(src->type)
{
        case IFPF_IS_NAN:
                memcpy(dest,"NaN",3);
                return(3);
  403efa:	b8 03 00 00 00       	mov    $0x3,%eax
  403eff:	66 44 89 1f          	mov    %r11w,(%rdi)
  403f03:	eb a7                	jmp    403eac <InternalFPFToString+0x69c>
  403f05:	0f 1f 00             	nopl   (%rax)

        case IFPF_IS_INFINITY:
                if(src->sign==0)
  403f08:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
  403f0c:	75 12                	jne    403f20 <InternalFPFToString+0x710>
  403f0e:	c7 07 2b 49 6e 66    	movl   $0x666e492b,(%rdi)
                        memcpy(dest,"+Inf",4);
                else
                        memcpy(dest,"-Inf",4);
                return(4);
  403f14:	b8 04 00 00 00       	mov    $0x4,%eax
  403f19:	eb 91                	jmp    403eac <InternalFPFToString+0x69c>
  403f1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  403f20:	c7 07 2d 49 6e 66    	movl   $0x666e492d,(%rdi)
  403f26:	b8 04 00 00 00       	mov    $0x4,%eax
  403f2b:	e9 7c ff ff ff       	jmpq   403eac <InternalFPFToString+0x69c>
  403f30:	41 b9 2d 30 00 00    	mov    $0x302d,%r9d
        case IFPF_IS_ZERO:
                if(src->sign==0)
                        memcpy(dest,"+0",2);
                else
                        memcpy(dest,"-0",2);
                return(2);
  403f36:	b8 02 00 00 00       	mov    $0x2,%eax
  403f3b:	66 44 89 0f          	mov    %r9w,(%rdi)
  403f3f:	e9 68 ff ff ff       	jmpq   403eac <InternalFPFToString+0x69c>
  403f44:	0f 1f 40 00          	nopl   0x0(%rax)
*/
ccount=1;               /* Init character counter */
if(msign==0)
        *dest++='+';
else
        *dest++='-';
  403f48:	b8 2d 00 00 00       	mov    $0x2d,%eax
  403f4d:	e9 1f fa ff ff       	jmpq   403971 <InternalFPFToString+0x161>
        carryaccum=(carryaccum<<1);
        if(mycarry) carryaccum++;
        locFPFNum.exp--;
}

while(locFPFNum.exp<0)
  403f52:	0f 84 87 00 00 00    	je     403fdf <InternalFPFToString+0x7cf>
  403f58:	44 0f b7 4c 24 24    	movzwl 0x24(%rsp),%r9d
  403f5e:	44 0f b7 44 24 26    	movzwl 0x26(%rsp),%r8d
  403f64:	0f b7 74 24 28       	movzwl 0x28(%rsp),%esi
  403f69:	0f b7 44 24 2a       	movzwl 0x2a(%rsp),%eax
  403f6e:	66 90                	xchg   %ax,%ax
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403f70:	44 89 c1             	mov    %r8d,%ecx
  403f73:	66 d1 e9             	shr    %cx
        if(*carry)
                accum|=0x8000;
  403f76:	89 ca                	mov    %ecx,%edx
  403f78:	66 81 ca 00 80       	or     $0x8000,%dx
  403f7d:	41 f6 c1 01          	test   $0x1,%r9b
  403f81:	0f 45 ca             	cmovne %edx,%ecx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403f84:	89 f2                	mov    %esi,%edx
  403f86:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
  403f89:	41 89 d3             	mov    %edx,%r11d
  403f8c:	66 41 81 cb 00 80    	or     $0x8000,%r11w
  403f92:	41 83 e0 01          	and    $0x1,%r8d
  403f96:	41 0f 45 d3          	cmovne %r11d,%edx
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403f9a:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  403f9d:	41 89 c0             	mov    %eax,%r8d
  403fa0:	66 41 81 c8 00 80    	or     $0x8000,%r8w
  403fa6:	83 e6 01             	and    $0x1,%esi
  403fa9:	89 d6                	mov    %edx,%esi
  403fab:	41 0f 45 c0          	cmovne %r8d,%eax
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  403faf:	66 41 d1 e9          	shr    %r9w
        carryaccum=(carryaccum<<1);
        if(mycarry) carryaccum++;
        locFPFNum.exp--;
}

while(locFPFNum.exp<0)
  403fb3:	66 83 c7 01          	add    $0x1,%di
  403fb7:	41 89 c8             	mov    %ecx,%r8d
  403fba:	75 b4                	jne    403f70 <InternalFPFToString+0x760>
  403fbc:	66 89 44 24 2a       	mov    %ax,0x2a(%rsp)
  403fc1:	31 c0                	xor    %eax,%eax
  403fc3:	66 44 89 4c 24 24    	mov    %r9w,0x24(%rsp)
  403fc9:	66 89 44 24 22       	mov    %ax,0x22(%rsp)
  403fce:	66 89 4c 24 26       	mov    %cx,0x26(%rsp)
** verify things).
*/
/*
** Re-position radix point
*/
carryaccum=0;
  403fd3:	31 c0                	xor    %eax,%eax
  403fd5:	66 89 54 24 28       	mov    %dx,0x28(%rsp)
  403fda:	e9 2e fa ff ff       	jmpq   403a0d <InternalFPFToString+0x1fd>
  403fdf:	31 c0                	xor    %eax,%eax
  403fe1:	e9 27 fa ff ff       	jmpq   403a0d <InternalFPFToString+0x1fd>
}

for(i=0;i<6;i++)
        if(i==1)
        {       /* Emit decimal point */
                *dest++='.';
  403fe6:	48 8b 1c 24          	mov    (%rsp),%rbx
  403fea:	c6 43 ff 2e          	movb   $0x2e,-0x1(%rbx)
  403fee:	e9 45 fa ff ff       	jmpq   403a38 <InternalFPFToString+0x228>
/*
** All done, go home.
*/
return(ccount);

}
  403ff3:	e8 08 cf ff ff       	callq  400f00 <__stack_chk_fail@plt>
  403ff8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  403fff:	00 

0000000000404000 <SetupCPUEmFloatArrays>:
*/
void SetupCPUEmFloatArrays(InternalFPF *abase,
                InternalFPF *bbase,
                InternalFPF *cbase,
                ulong arraysize)
{
  404000:	41 55                	push   %r13
  404002:	41 54                	push   %r12
  404004:	49 89 cd             	mov    %rcx,%r13
  404007:	55                   	push   %rbp
  404008:	53                   	push   %rbx
  404009:	48 89 fb             	mov    %rdi,%rbx
InternalFPF locFPF1,locFPF2;
/*
** Reset random number generator so things repeat. Inserted by Uwe F. Mayer.
*/
extern int32 randnum(int32 lngval);
randnum((int32)13);
  40400c:	bf 0d 00 00 00       	mov    $0xd,%edi
*/
void SetupCPUEmFloatArrays(InternalFPF *abase,
                InternalFPF *bbase,
                InternalFPF *cbase,
                ulong arraysize)
{
  404011:	48 89 f5             	mov    %rsi,%rbp
  404014:	48 83 ec 38          	sub    $0x38,%rsp
  404018:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40401f:	00 00 
  404021:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  404026:	31 c0                	xor    %eax,%eax
InternalFPF locFPF1,locFPF2;
/*
** Reset random number generator so things repeat. Inserted by Uwe F. Mayer.
*/
extern int32 randnum(int32 lngval);
randnum((int32)13);
  404028:	e8 b3 07 00 00       	callq  4047e0 <randnum>

for(i=0;i<arraysize;i++)
  40402d:	4d 85 ed             	test   %r13,%r13
  404030:	0f 84 7a 02 00 00    	je     4042b0 <SetupCPUEmFloatArrays+0x2b0>
  404036:	45 31 e4             	xor    %r12d,%r12d
  404039:	e9 3f 01 00 00       	jmpq   40417d <SetupCPUEmFloatArrays+0x17d>
  40403e:	66 90                	xchg   %ax,%ax
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  404040:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  404046:	41 ba 00 00 00 00    	mov    $0x0,%r10d
  40404c:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  404052:	ba 00 00 00 00       	mov    $0x0,%edx
if(mylong<(int32)0)
{       dest->sign=1;
        mylong=(int32)0-mylong;
}
else
        dest->sign=0;
  404057:	c6 44 24 01 00       	movb   $0x0,0x1(%rsp)
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  40405c:	c6 04 24 02          	movb   $0x2,(%rsp)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  404060:	66 44 89 4c 24 04    	mov    %r9w,0x4(%rsp)
  404066:	66 44 89 54 24 06    	mov    %r10w,0x6(%rsp)
  40406c:	66 44 89 5c 24 08    	mov    %r11w,0x8(%rsp)
  404072:	66 89 54 24 0a       	mov    %dx,0xa(%rsp)

/*
** See if we've got a zero.  If so, make the resultant FP
** number a true zero and go home.
*/
if(mylong==0)
  404077:	0f 85 1d 01 00 00    	jne    40419a <SetupCPUEmFloatArrays+0x19a>
{       dest->type=IFPF_IS_ZERO;
        dest->exp=0;
  40407d:	45 31 c0             	xor    %r8d,%r8d

for(i=0;i<arraysize;i++)
{/*       LongToInternalFPF(randwc(50000L),&locFPF1); */
        Int32ToInternalFPF(randwc((int32)50000),&locFPF1);
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
  404080:	bf 50 c3 00 00       	mov    $0xc350,%edi
/*
** See if we've got a zero.  If so, make the resultant FP
** number a true zero and go home.
*/
if(mylong==0)
{       dest->type=IFPF_IS_ZERO;
  404085:	c6 04 24 00          	movb   $0x0,(%rsp)
        dest->exp=0;
  404089:	66 44 89 44 24 02    	mov    %r8w,0x2(%rsp)

for(i=0;i<arraysize;i++)
{/*       LongToInternalFPF(randwc(50000L),&locFPF1); */
        Int32ToInternalFPF(randwc((int32)50000),&locFPF1);
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
  40408f:	e8 9c 06 00 00       	callq  404730 <randwc>
** Save the sign and get the absolute value.  This will help us
** with 64-bit machines, since we use only the lower 32
** bits just in case. (No longer necessary after we use int32.)
*/
/* if(mylong<0L) */
if(mylong<(int32)0)
  404094:	83 c0 01             	add    $0x1,%eax
  404097:	0f 88 54 01 00 00    	js     4041f1 <SetupCPUEmFloatArrays+0x1f1>
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  40409d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  4040a3:	41 ba 00 00 00 00    	mov    $0x0,%r10d
  4040a9:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  4040af:	ba 00 00 00 00       	mov    $0x0,%edx
if(mylong<(int32)0)
{       dest->sign=1;
        mylong=(int32)0-mylong;
}
else
        dest->sign=0;
  4040b4:	c6 44 24 11 00       	movb   $0x0,0x11(%rsp)
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  4040b9:	c6 44 24 10 02       	movb   $0x2,0x10(%rsp)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  4040be:	66 44 89 4c 24 14    	mov    %r9w,0x14(%rsp)
  4040c4:	66 44 89 54 24 16    	mov    %r10w,0x16(%rsp)
  4040ca:	66 44 89 5c 24 18    	mov    %r11w,0x18(%rsp)
  4040d0:	66 89 54 24 1a       	mov    %dx,0x1a(%rsp)

/*
** See if we've got a zero.  If so, make the resultant FP
** number a true zero and go home.
*/
if(mylong==0)
  4040d5:	0f 85 22 01 00 00    	jne    4041fd <SetupCPUEmFloatArrays+0x1fd>
{       dest->type=IFPF_IS_ZERO;
        dest->exp=0;
  4040db:	45 31 c0             	xor    %r8d,%r8d
/*
** See if we've got a zero.  If so, make the resultant FP
** number a true zero and go home.
*/
if(mylong==0)
{       dest->type=IFPF_IS_ZERO;
  4040de:	c6 44 24 10 00       	movb   $0x0,0x10(%rsp)
        dest->exp=0;
  4040e3:	66 44 89 44 24 12    	mov    %r8w,0x12(%rsp)
for(i=0;i<arraysize;i++)
{/*       LongToInternalFPF(randwc(50000L),&locFPF1); */
        Int32ToInternalFPF(randwc((int32)50000),&locFPF1);
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
        DivideInternalFPF(&locFPF1,&locFPF2,abase+i);
  4040e9:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  4040ee:	48 89 da             	mov    %rbx,%rdx
  4040f1:	48 89 e7             	mov    %rsp,%rdi
  4040f4:	e8 a7 e3 ff ff       	callq  4024a0 <DivideInternalFPF>
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
  4040f9:	bf 50 c3 00 00       	mov    $0xc350,%edi
  4040fe:	e8 2d 06 00 00       	callq  404730 <randwc>
** Save the sign and get the absolute value.  This will help us
** with 64-bit machines, since we use only the lower 32
** bits just in case. (No longer necessary after we use int32.)
*/
/* if(mylong<0L) */
if(mylong<(int32)0)
  404103:	83 c0 01             	add    $0x1,%eax
  404106:	0f 88 44 01 00 00    	js     404250 <SetupCPUEmFloatArrays+0x250>
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  40410c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  404112:	41 ba 00 00 00 00    	mov    $0x0,%r10d
  404118:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  40411e:	ba 00 00 00 00       	mov    $0x0,%edx
if(mylong<(int32)0)
{       dest->sign=1;
        mylong=(int32)0-mylong;
}
else
        dest->sign=0;
  404123:	c6 44 24 11 00       	movb   $0x0,0x11(%rsp)
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  404128:	c6 44 24 10 02       	movb   $0x2,0x10(%rsp)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        dest->mantissa[i]=0;
  40412d:	66 44 89 4c 24 14    	mov    %r9w,0x14(%rsp)
  404133:	66 44 89 54 24 16    	mov    %r10w,0x16(%rsp)
  404139:	66 44 89 5c 24 18    	mov    %r11w,0x18(%rsp)
  40413f:	66 89 54 24 1a       	mov    %dx,0x1a(%rsp)

/*
** See if we've got a zero.  If so, make the resultant FP
** number a true zero and go home.
*/
if(mylong==0)
  404144:	0f 85 12 01 00 00    	jne    40425c <SetupCPUEmFloatArrays+0x25c>
{       dest->type=IFPF_IS_ZERO;
        dest->exp=0;
  40414a:	45 31 c0             	xor    %r8d,%r8d
/*
** See if we've got a zero.  If so, make the resultant FP
** number a true zero and go home.
*/
if(mylong==0)
{       dest->type=IFPF_IS_ZERO;
  40414d:	c6 44 24 10 00       	movb   $0x0,0x10(%rsp)
        dest->exp=0;
  404152:	66 44 89 44 24 12    	mov    %r8w,0x12(%rsp)
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
        DivideInternalFPF(&locFPF1,&locFPF2,abase+i);
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
        DivideInternalFPF(&locFPF1,&locFPF2,bbase+i);
  404158:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  40415d:	48 89 ea             	mov    %rbp,%rdx
  404160:	48 89 e7             	mov    %rsp,%rdi
** Reset random number generator so things repeat. Inserted by Uwe F. Mayer.
*/
extern int32 randnum(int32 lngval);
randnum((int32)13);

for(i=0;i<arraysize;i++)
  404163:	49 83 c4 01          	add    $0x1,%r12
  404167:	48 83 c5 0c          	add    $0xc,%rbp
  40416b:	48 83 c3 0c          	add    $0xc,%rbx
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
        DivideInternalFPF(&locFPF1,&locFPF2,abase+i);
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
        DivideInternalFPF(&locFPF1,&locFPF2,bbase+i);
  40416f:	e8 2c e3 ff ff       	callq  4024a0 <DivideInternalFPF>
** Reset random number generator so things repeat. Inserted by Uwe F. Mayer.
*/
extern int32 randnum(int32 lngval);
randnum((int32)13);

for(i=0;i<arraysize;i++)
  404174:	4d 39 e5             	cmp    %r12,%r13
  404177:	0f 84 33 01 00 00    	je     4042b0 <SetupCPUEmFloatArrays+0x2b0>
{/*       LongToInternalFPF(randwc(50000L),&locFPF1); */
        Int32ToInternalFPF(randwc((int32)50000),&locFPF1);
  40417d:	bf 50 c3 00 00       	mov    $0xc350,%edi
  404182:	e8 a9 05 00 00       	callq  404730 <randwc>
** Save the sign and get the absolute value.  This will help us
** with 64-bit machines, since we use only the lower 32
** bits just in case. (No longer necessary after we use int32.)
*/
/* if(mylong<0L) */
if(mylong<(int32)0)
  404187:	85 c0                	test   %eax,%eax
  404189:	0f 89 b1 fe ff ff    	jns    404040 <SetupCPUEmFloatArrays+0x40>
{       dest->sign=1;
  40418f:	c6 44 24 01 01       	movb   $0x1,0x1(%rsp)
        mylong=(int32)0-mylong;
  404194:	f7 d8                	neg    %eax
else
        dest->sign=0;
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  404196:	c6 04 24 02          	movb   $0x2,(%rsp)
** up the exponent properly.
*/
dest->exp=32;
myword=(u16)((mylong >> 16) & 0xFFFFL);
dest->mantissa[0]=myword;
myword=(u16)(mylong & 0xFFFFL);
  40419a:	89 c2                	mov    %eax,%edx
  40419c:	b9 1f 00 00 00       	mov    $0x1f,%ecx
  4041a1:	c1 e8 10             	shr    $0x10,%eax
  4041a4:	0f 1f 40 00          	nopl   0x0(%rax)
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  4041a8:	01 c0                	add    %eax,%eax
        if(*carry)
                accum|=1;               /* Insert previous carry */
  4041aa:	89 c6                	mov    %eax,%esi
  4041ac:	83 ce 01             	or     $0x1,%esi
  4041af:	66 85 d2             	test   %dx,%dx
  4041b2:	0f 48 c6             	cmovs  %esi,%eax
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
{
        carry = 0;
        ShiftMantLeft1(&carry, ptr->mantissa);
        ptr->exp--;
  4041b5:	89 ce                	mov    %ecx,%esi
  4041b7:	01 d2                	add    %edx,%edx
  4041b9:	83 e9 01             	sub    $0x1,%ecx
/*
** As long as there's a highmost 0 bit, shift the significand
** left 1 bit.  Each time you do this, though, you've
** gotta decrement the exponent.
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
  4041bc:	66 85 c0             	test   %ax,%ax
  4041bf:	79 e7                	jns    4041a8 <SetupCPUEmFloatArrays+0x1a8>
  4041c1:	31 ff                	xor    %edi,%edi
  4041c3:	31 c9                	xor    %ecx,%ecx
  4041c5:	66 89 54 24 06       	mov    %dx,0x6(%rsp)
  4041ca:	66 89 7c 24 08       	mov    %di,0x8(%rsp)

for(i=0;i<arraysize;i++)
{/*       LongToInternalFPF(randwc(50000L),&locFPF1); */
        Int32ToInternalFPF(randwc((int32)50000),&locFPF1);
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
  4041cf:	bf 50 c3 00 00       	mov    $0xc350,%edi
  4041d4:	66 89 4c 24 0a       	mov    %cx,0xa(%rsp)
  4041d9:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
  4041de:	66 89 74 24 02       	mov    %si,0x2(%rsp)
  4041e3:	e8 48 05 00 00       	callq  404730 <randwc>
** Save the sign and get the absolute value.  This will help us
** with 64-bit machines, since we use only the lower 32
** bits just in case. (No longer necessary after we use int32.)
*/
/* if(mylong<0L) */
if(mylong<(int32)0)
  4041e8:	83 c0 01             	add    $0x1,%eax
  4041eb:	0f 89 ac fe ff ff    	jns    40409d <SetupCPUEmFloatArrays+0x9d>
{       dest->sign=1;
  4041f1:	c6 44 24 11 01       	movb   $0x1,0x11(%rsp)
        mylong=(int32)0-mylong;
  4041f6:	f7 d8                	neg    %eax
else
        dest->sign=0;
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  4041f8:	c6 44 24 10 02       	movb   $0x2,0x10(%rsp)
** up the exponent properly.
*/
dest->exp=32;
myword=(u16)((mylong >> 16) & 0xFFFFL);
dest->mantissa[0]=myword;
myword=(u16)(mylong & 0xFFFFL);
  4041fd:	89 c2                	mov    %eax,%edx
  4041ff:	b9 20 00 00 00       	mov    $0x20,%ecx
  404204:	c1 e8 10             	shr    $0x10,%eax
  404207:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40420e:	00 00 
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  404210:	01 c0                	add    %eax,%eax
        if(*carry)
                accum|=1;               /* Insert previous carry */
  404212:	89 c6                	mov    %eax,%esi
  404214:	83 ce 01             	or     $0x1,%esi
  404217:	66 85 d2             	test   %dx,%dx
  40421a:	0f 48 c6             	cmovs  %esi,%eax
  40421d:	83 e9 01             	sub    $0x1,%ecx
  404220:	01 d2                	add    %edx,%edx
/*
** As long as there's a highmost 0 bit, shift the significand
** left 1 bit.  Each time you do this, though, you've
** gotta decrement the exponent.
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
  404222:	66 85 c0             	test   %ax,%ax
  404225:	79 e9                	jns    404210 <SetupCPUEmFloatArrays+0x210>
  404227:	31 f6                	xor    %esi,%esi
  404229:	31 ff                	xor    %edi,%edi
  40422b:	66 89 54 24 16       	mov    %dx,0x16(%rsp)
  404230:	66 89 74 24 1a       	mov    %si,0x1a(%rsp)
  404235:	66 89 7c 24 18       	mov    %di,0x18(%rsp)
  40423a:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
  40423f:	66 89 4c 24 12       	mov    %cx,0x12(%rsp)
  404244:	e9 a0 fe ff ff       	jmpq   4040e9 <SetupCPUEmFloatArrays+0xe9>
  404249:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
** with 64-bit machines, since we use only the lower 32
** bits just in case. (No longer necessary after we use int32.)
*/
/* if(mylong<0L) */
if(mylong<(int32)0)
{       dest->sign=1;
  404250:	c6 44 24 11 01       	movb   $0x1,0x11(%rsp)
        mylong=(int32)0-mylong;
  404255:	f7 d8                	neg    %eax
else
        dest->sign=0;
/*
** Prepare the destination floating point number
*/
dest->type=IFPF_IS_NORMAL;
  404257:	c6 44 24 10 02       	movb   $0x2,0x10(%rsp)
** up the exponent properly.
*/
dest->exp=32;
myword=(u16)((mylong >> 16) & 0xFFFFL);
dest->mantissa[0]=myword;
myword=(u16)(mylong & 0xFFFFL);
  40425c:	89 c2                	mov    %eax,%edx
  40425e:	b9 1f 00 00 00       	mov    $0x1f,%ecx
  404263:	c1 e8 10             	shr    $0x10,%eax
  404266:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40426d:	00 00 00 
u16 accum;      /* Temporary holding placed */

for(i=INTERNAL_FPF_PRECISION-1;i>=0;i--)
{       accum=mantissa[i];
        new_carry=accum & 0x8000;       /* Get new carry */
        accum=accum<<1;                 /* Do the shift */
  404270:	01 c0                	add    %eax,%eax
        if(*carry)
                accum|=1;               /* Insert previous carry */
  404272:	89 c6                	mov    %eax,%esi
  404274:	83 ce 01             	or     $0x1,%esi
  404277:	66 85 d2             	test   %dx,%dx
  40427a:	0f 48 c6             	cmovs  %esi,%eax
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
{
        carry = 0;
        ShiftMantLeft1(&carry, ptr->mantissa);
        ptr->exp--;
  40427d:	89 ce                	mov    %ecx,%esi
  40427f:	01 d2                	add    %edx,%edx
  404281:	83 e9 01             	sub    $0x1,%ecx
/*
** As long as there's a highmost 0 bit, shift the significand
** left 1 bit.  Each time you do this, though, you've
** gotta decrement the exponent.
*/
while ((ptr->mantissa[0] & 0x8000) == 0)
  404284:	66 85 c0             	test   %ax,%ax
  404287:	79 e7                	jns    404270 <SetupCPUEmFloatArrays+0x270>
  404289:	31 c9                	xor    %ecx,%ecx
  40428b:	31 ff                	xor    %edi,%edi
  40428d:	66 89 54 24 16       	mov    %dx,0x16(%rsp)
  404292:	66 89 4c 24 1a       	mov    %cx,0x1a(%rsp)
  404297:	66 89 7c 24 18       	mov    %di,0x18(%rsp)
  40429c:	66 89 44 24 14       	mov    %ax,0x14(%rsp)
  4042a1:	66 89 74 24 12       	mov    %si,0x12(%rsp)
  4042a6:	e9 ad fe ff ff       	jmpq   404158 <SetupCPUEmFloatArrays+0x158>
  4042ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
 /*       LongToInternalFPF(randwc(50000L)+1L,&locFPF2); */
        Int32ToInternalFPF(randwc((int32)50000)+(int32)1,&locFPF2);
        DivideInternalFPF(&locFPF1,&locFPF2,bbase+i);
}
return;
}
  4042b0:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  4042b5:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4042bc:	00 00 
  4042be:	75 0b                	jne    4042cb <SetupCPUEmFloatArrays+0x2cb>
  4042c0:	48 83 c4 38          	add    $0x38,%rsp
  4042c4:	5b                   	pop    %rbx
  4042c5:	5d                   	pop    %rbp
  4042c6:	41 5c                	pop    %r12
  4042c8:	41 5d                	pop    %r13
  4042ca:	c3                   	retq   
  4042cb:	e8 30 cc ff ff       	callq  400f00 <__stack_chk_fail@plt>

00000000004042d0 <DoEmFloatIteration>:
*/
ulong DoEmFloatIteration(InternalFPF *abase,
                InternalFPF *bbase,
                InternalFPF *cbase,
                ulong arraysize, ulong loops)
{
  4042d0:	41 57                	push   %r15
  4042d2:	41 56                	push   %r14
  4042d4:	41 55                	push   %r13
  4042d6:	41 54                	push   %r12
  4042d8:	55                   	push   %rbp
  4042d9:	53                   	push   %rbx
  4042da:	4c 89 c3             	mov    %r8,%rbx
  4042dd:	48 89 cd             	mov    %rcx,%rbp
  4042e0:	48 81 ec b8 04 00 00 	sub    $0x4b8,%rsp
  4042e7:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4042ee:	00 00 
  4042f0:	48 89 84 24 a8 04 00 	mov    %rax,0x4a8(%rsp)
  4042f7:	00 
  4042f8:	31 c0                	xor    %eax,%eax
  4042fa:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  4042ff:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  404304:	48 89 14 24          	mov    %rdx,(%rsp)
int number_of_loops;
#endif
/*
** Begin timing
*/
elapsed=StartStopwatch();
  404308:	e8 a3 7e 00 00       	callq  40c1b0 <StartStopwatch>
** Each pass through the array performs operations in
** the followingratios:
**   4 adds, 4 subtracts, 5 multiplies, 3 divides
** (adds and subtracts being nearly the same operation)
*/
while(loops--)
  40430d:	48 85 db             	test   %rbx,%rbx
int number_of_loops;
#endif
/*
** Begin timing
*/
elapsed=StartStopwatch();
  404310:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
** Each pass through the array performs operations in
** the followingratios:
**   4 adds, 4 subtracts, 5 multiplies, 3 divides
** (adds and subtracts being nearly the same operation)
*/
while(loops--)
  404315:	0f 84 dd 02 00 00    	je     4045f8 <DoEmFloatIteration+0x328>
  40431b:	8d 43 ff             	lea    -0x1(%rbx),%eax
  40431e:	4c 8d 63 ff          	lea    -0x1(%rbx),%r12
  404322:	48 98                	cltq   
  404324:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    {
      j[0]=(ulong)2;
      j[1]=(ulong)6;
      j[2]=(ulong)10;
      j[3]=(ulong)14;
      j[4]=(ulong)(arraysize-14);
  404329:	48 8d 45 f2          	lea    -0xe(%rbp),%rax
  40432d:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
      j[5]=(ulong)(arraysize-10);
  404332:	48 8d 45 f6          	lea    -0xa(%rbp),%rax
  404336:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
      j[6]=(ulong)(arraysize-6);
  40433b:	48 8d 45 fa          	lea    -0x6(%rbp),%rax
  40433f:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
      j[7]=(ulong)(arraysize-2);
  404344:	48 8d 45 fe          	lea    -0x2(%rbp),%rax
  404348:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  40434d:	0f 1f 00             	nopl   (%rax)
**   4 adds, 4 subtracts, 5 multiplies, 3 divides
** (adds and subtracts being nearly the same operation)
*/
while(loops--)
{
        for(i=0;i<arraysize;i++)
  404350:	48 85 ed             	test   %rbp,%rbp
  404353:	0f 84 9f 00 00 00    	je     4043f8 <DoEmFloatIteration+0x128>
  404359:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40435e:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
  404363:	31 c0                	xor    %eax,%eax
  404365:	4c 8b 3c 24          	mov    (%rsp),%r15
  404369:	31 db                	xor    %ebx,%ebx
  40436b:	eb 3d                	jmp    4043aa <DoEmFloatIteration+0xda>
  40436d:	0f 1f 00             	nopl   (%rax)
                switch(jtable[i % 16])
  404370:	72 6e                	jb     4043e0 <DoEmFloatIteration+0x110>
  404372:	3c 02                	cmp    $0x2,%al
  404374:	74 52                	je     4043c8 <DoEmFloatIteration+0xf8>
  404376:	3c 03                	cmp    $0x3,%al
  404378:	75 0e                	jne    404388 <DoEmFloatIteration+0xb8>
                                MultiplyInternalFPF(abase+i,
                                  bbase+i,
                                  cbase+i);
                                break;
                        case 3: /* Divide */
                                DivideInternalFPF(abase+i,
  40437a:	4c 89 fa             	mov    %r15,%rdx
  40437d:	4c 89 ee             	mov    %r13,%rsi
  404380:	4c 89 f7             	mov    %r14,%rdi
  404383:	e8 18 e1 ff ff       	callq  4024a0 <DivideInternalFPF>
**   4 adds, 4 subtracts, 5 multiplies, 3 divides
** (adds and subtracts being nearly the same operation)
*/
while(loops--)
{
        for(i=0;i<arraysize;i++)
  404388:	48 83 c3 01          	add    $0x1,%rbx
  40438c:	49 83 c6 0c          	add    $0xc,%r14
  404390:	49 83 c5 0c          	add    $0xc,%r13
  404394:	49 83 c7 0c          	add    $0xc,%r15
  404398:	48 39 dd             	cmp    %rbx,%rbp
  40439b:	74 5b                	je     4043f8 <DoEmFloatIteration+0x128>
  40439d:	48 89 d8             	mov    %rbx,%rax
  4043a0:	83 e0 0f             	and    $0xf,%eax
  4043a3:	0f b6 80 90 cd 40 00 	movzbl 0x40cd90(%rax),%eax
                switch(jtable[i % 16])
  4043aa:	3c 01                	cmp    $0x1,%al
  4043ac:	75 c2                	jne    404370 <DoEmFloatIteration+0xa0>
                                AddSubInternalFPF(0,abase+i,
                                  bbase+i,
                                  cbase+i);
                                break;
                        case 1: /* Subtract */
                                AddSubInternalFPF(1,abase+i,
  4043ae:	4c 89 f9             	mov    %r15,%rcx
  4043b1:	4c 89 ea             	mov    %r13,%rdx
  4043b4:	4c 89 f6             	mov    %r14,%rsi
  4043b7:	bf 01 00 00 00       	mov    $0x1,%edi
  4043bc:	e8 3f ed ff ff       	callq  403100 <AddSubInternalFPF>
                                  bbase+i,
                                  cbase+i);
                                break;
  4043c1:	eb c5                	jmp    404388 <DoEmFloatIteration+0xb8>
  4043c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                        case 2: /* Multiply */
                                MultiplyInternalFPF(abase+i,
  4043c8:	4c 89 fa             	mov    %r15,%rdx
  4043cb:	4c 89 ee             	mov    %r13,%rsi
  4043ce:	4c 89 f7             	mov    %r14,%rdi
  4043d1:	e8 fa e6 ff ff       	callq  402ad0 <MultiplyInternalFPF>
                                  bbase+i,
                                  cbase+i);
                                break;
  4043d6:	eb b0                	jmp    404388 <DoEmFloatIteration+0xb8>
  4043d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4043df:	00 
{
        for(i=0;i<arraysize;i++)
                switch(jtable[i % 16])
                {
                        case 0: /* Add */
                                AddSubInternalFPF(0,abase+i,
  4043e0:	4c 89 f9             	mov    %r15,%rcx
  4043e3:	4c 89 ea             	mov    %r13,%rdx
  4043e6:	4c 89 f6             	mov    %r14,%rsi
  4043e9:	31 ff                	xor    %edi,%edi
  4043eb:	e8 10 ed ff ff       	callq  403100 <AddSubInternalFPF>
                                  bbase+i,
                                  cbase+i);
                                break;
  4043f0:	eb 96                	jmp    404388 <DoEmFloatIteration+0xb8>
  4043f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
  ulong j[8];   /* we test 8 entries */
  int k;
  ulong i;
  char buffer[1024];
  if (number_of_loops==loops) /* the first loop */
  4043f8:	4c 39 64 24 20       	cmp    %r12,0x20(%rsp)
  4043fd:	74 19                	je     404418 <DoEmFloatIteration+0x148>
** Each pass through the array performs operations in
** the followingratios:
**   4 adds, 4 subtracts, 5 multiplies, 3 divides
** (adds and subtracts being nearly the same operation)
*/
while(loops--)
  4043ff:	4d 85 e4             	test   %r12,%r12
  404402:	49 8d 44 24 ff       	lea    -0x1(%r12),%rax
  404407:	0f 84 eb 01 00 00    	je     4045f8 <DoEmFloatIteration+0x328>
  40440d:	49 89 c4             	mov    %rax,%r12
  404410:	e9 3b ff ff ff       	jmpq   404350 <DoEmFloatIteration+0x80>
  404415:	0f 1f 00             	nopl   (%rax)
    {
      j[0]=(ulong)2;
      j[1]=(ulong)6;
      j[2]=(ulong)10;
      j[3]=(ulong)14;
      j[4]=(ulong)(arraysize-14);
  404418:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  40441d:	4c 8d 74 24 60       	lea    0x60(%rsp),%r14
      j[5]=(ulong)(arraysize-10);
      j[6]=(ulong)(arraysize-6);
      j[7]=(ulong)(arraysize-2);
  404422:	45 31 ed             	xor    %r13d,%r13d
  404425:	4c 89 64 24 28       	mov    %r12,0x28(%rsp)
  40442a:	48 89 6c 24 30       	mov    %rbp,0x30(%rsp)
  40442f:	45 89 ec             	mov    %r13d,%r12d
  404432:	4c 89 f5             	mov    %r14,%rbp
  int k;
  ulong i;
  char buffer[1024];
  if (number_of_loops==loops) /* the first loop */
    {
      j[0]=(ulong)2;
  404435:	48 c7 44 24 60 02 00 	movq   $0x2,0x60(%rsp)
  40443c:	00 00 
      j[1]=(ulong)6;
  40443e:	48 c7 44 24 68 06 00 	movq   $0x6,0x68(%rsp)
  404445:	00 00 
      j[2]=(ulong)10;
      j[3]=(ulong)14;
      j[4]=(ulong)(arraysize-14);
  404447:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
  40444e:	00 
      j[5]=(ulong)(arraysize-10);
  40444f:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  char buffer[1024];
  if (number_of_loops==loops) /* the first loop */
    {
      j[0]=(ulong)2;
      j[1]=(ulong)6;
      j[2]=(ulong)10;
  404454:	48 c7 44 24 70 0a 00 	movq   $0xa,0x70(%rsp)
  40445b:	00 00 
      j[3]=(ulong)14;
  40445d:	48 c7 44 24 78 0e 00 	movq   $0xe,0x78(%rsp)
  404464:	00 00 
  404466:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  40446b:	4c 8b 74 24 18       	mov    0x18(%rsp),%r14
      j[4]=(ulong)(arraysize-14);
      j[5]=(ulong)(arraysize-10);
  404470:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
  404477:	00 
      j[6]=(ulong)(arraysize-6);
  404478:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
  40447d:	48 89 84 24 90 00 00 	mov    %rax,0x90(%rsp)
  404484:	00 
      j[7]=(ulong)(arraysize-2);
  404485:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  40448a:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
  404491:	00 
  404492:	48 8d 84 24 a0 00 00 	lea    0xa0(%rsp),%rax
  404499:	00 
  40449a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40449f:	e9 af 00 00 00       	jmpq   404553 <DoEmFloatIteration+0x283>
  4044a4:	0f 1f 40 00          	nopl   0x0(%rax)
      for(k=0;k<8;k++){
	i=j[k];
	InternalFPFToString(buffer,abase+i);
	printf("%6ld: (%s) ",i,buffer);
	switch(jtable[i % 16])
  4044a8:	0f 82 1a 01 00 00    	jb     4045c8 <DoEmFloatIteration+0x2f8>
  4044ae:	41 80 fc 02          	cmp    $0x2,%r12b
  4044b2:	0f 84 f8 00 00 00    	je     4045b0 <DoEmFloatIteration+0x2e0>
  4044b8:	41 80 fc 03          	cmp    $0x3,%r12b
  4044bc:	75 12                	jne    4044d0 <DoEmFloatIteration+0x200>
#endif

__fortify_function char *
__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  4044be:	b8 2f 00 00 00       	mov    $0x2f,%eax
  4044c3:	66 89 84 24 a0 00 00 	mov    %ax,0xa0(%rsp)
  4044ca:	00 
  4044cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4044d0:	48 8d 94 24 a0 00 00 	lea    0xa0(%rsp),%rdx
  4044d7:	00 
  4044d8:	be b0 cd 40 00       	mov    $0x40cdb0,%esi
  4044dd:	bf 01 00 00 00       	mov    $0x1,%edi
  4044e2:	31 c0                	xor    %eax,%eax
  4044e4:	48 83 c5 08          	add    $0x8,%rbp
  4044e8:	e8 23 cb ff ff       	callq  401010 <__printf_chk@plt>
	  case 1: strcpy(buffer,"-"); break;
	  case 2: strcpy(buffer,"*"); break;
	  case 3: strcpy(buffer,"/"); break;
	  }
	printf("%s ",buffer);
	InternalFPFToString(buffer,bbase+i);
  4044ed:	49 8d 34 1e          	lea    (%r14,%rbx,1),%rsi
  4044f1:	48 8d bc 24 a0 00 00 	lea    0xa0(%rsp),%rdi
  4044f8:	00 
  4044f9:	e8 12 f3 ff ff       	callq  403810 <InternalFPFToString>
  4044fe:	48 8d 94 24 a0 00 00 	lea    0xa0(%rsp),%rdx
  404505:	00 
  404506:	be b4 cd 40 00       	mov    $0x40cdb4,%esi
  40450b:	bf 01 00 00 00       	mov    $0x1,%edi
  404510:	31 c0                	xor    %eax,%eax
  404512:	e8 f9 ca ff ff       	callq  401010 <__printf_chk@plt>
	printf("(%s) = ",buffer);
	InternalFPFToString(buffer,cbase+i);
  404517:	48 8b 04 24          	mov    (%rsp),%rax
  40451b:	48 8d bc 24 a0 00 00 	lea    0xa0(%rsp),%rdi
  404522:	00 
  404523:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
  404527:	e8 e4 f2 ff ff       	callq  403810 <InternalFPFToString>
  40452c:	48 8d bc 24 a0 00 00 	lea    0xa0(%rsp),%rdi
  404533:	00 
  404534:	e8 57 c9 ff ff       	callq  400e90 <puts@plt>
      j[3]=(ulong)14;
      j[4]=(ulong)(arraysize-14);
      j[5]=(ulong)(arraysize-10);
      j[6]=(ulong)(arraysize-6);
      j[7]=(ulong)(arraysize-2);
      for(k=0;k<8;k++){
  404539:	48 3b 6c 24 08       	cmp    0x8(%rsp),%rbp
  40453e:	0f 84 9c 00 00 00    	je     4045e0 <DoEmFloatIteration+0x310>
  404544:	48 8b 45 00          	mov    0x0(%rbp),%rax
  404548:	83 e0 0f             	and    $0xf,%eax
  40454b:	44 0f b6 a0 90 cd 40 	movzbl 0x40cd90(%rax),%r12d
  404552:	00 
	i=j[k];
  404553:	4c 8b 7d 00          	mov    0x0(%rbp),%r15
	InternalFPFToString(buffer,abase+i);
  404557:	48 8d bc 24 a0 00 00 	lea    0xa0(%rsp),%rdi
  40455e:	00 
  40455f:	4b 8d 1c 7f          	lea    (%r15,%r15,2),%rbx
  404563:	48 c1 e3 02          	shl    $0x2,%rbx
  404567:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
  40456c:	e8 9f f2 ff ff       	callq  403810 <InternalFPFToString>
  404571:	48 8d 8c 24 a0 00 00 	lea    0xa0(%rsp),%rcx
  404578:	00 
  404579:	31 c0                	xor    %eax,%eax
  40457b:	4c 89 fa             	mov    %r15,%rdx
  40457e:	be a4 cd 40 00       	mov    $0x40cda4,%esi
  404583:	bf 01 00 00 00       	mov    $0x1,%edi
  404588:	e8 83 ca ff ff       	callq  401010 <__printf_chk@plt>
	printf("%6ld: (%s) ",i,buffer);
	switch(jtable[i % 16])
  40458d:	41 80 fc 01          	cmp    $0x1,%r12b
  404591:	0f 85 11 ff ff ff    	jne    4044a8 <DoEmFloatIteration+0x1d8>
  404597:	b9 2d 00 00 00       	mov    $0x2d,%ecx
  40459c:	66 89 8c 24 a0 00 00 	mov    %cx,0xa0(%rsp)
  4045a3:	00 
  4045a4:	e9 27 ff ff ff       	jmpq   4044d0 <DoEmFloatIteration+0x200>
  4045a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  4045b0:	ba 2a 00 00 00       	mov    $0x2a,%edx
  4045b5:	66 89 94 24 a0 00 00 	mov    %dx,0xa0(%rsp)
  4045bc:	00 
  4045bd:	e9 0e ff ff ff       	jmpq   4044d0 <DoEmFloatIteration+0x200>
  4045c2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4045c8:	be 2b 00 00 00       	mov    $0x2b,%esi
  4045cd:	66 89 b4 24 a0 00 00 	mov    %si,0xa0(%rsp)
  4045d4:	00 
  4045d5:	e9 f6 fe ff ff       	jmpq   4044d0 <DoEmFloatIteration+0x200>
  4045da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4045e0:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
  4045e5:	48 8b 6c 24 30       	mov    0x30(%rsp),%rbp
** Each pass through the array performs operations in
** the followingratios:
**   4 adds, 4 subtracts, 5 multiplies, 3 divides
** (adds and subtracts being nearly the same operation)
*/
while(loops--)
  4045ea:	4d 85 e4             	test   %r12,%r12
  4045ed:	49 8d 44 24 ff       	lea    -0x1(%r12),%rax
  4045f2:	0f 85 15 fe ff ff    	jne    40440d <DoEmFloatIteration+0x13d>
      }
    }
}
#endif
}
return(StopStopwatch(elapsed));
  4045f8:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  4045fd:	e8 be 7b 00 00       	callq  40c1c0 <StopStopwatch>
}
  404602:	48 8b 8c 24 a8 04 00 	mov    0x4a8(%rsp),%rcx
  404609:	00 
  40460a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  404611:	00 00 
  404613:	75 12                	jne    404627 <DoEmFloatIteration+0x357>
  404615:	48 81 c4 b8 04 00 00 	add    $0x4b8,%rsp
  40461c:	5b                   	pop    %rbx
  40461d:	5d                   	pop    %rbp
  40461e:	41 5c                	pop    %r12
  404620:	41 5d                	pop    %r13
  404622:	41 5e                	pop    %r14
  404624:	41 5f                	pop    %r15
  404626:	c3                   	retq   
  404627:	e8 d4 c8 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  40462c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404630 <RoundInternalFPF>:
*/
void RoundInternalFPF(InternalFPF *ptr)
{
/* int i; */

if (ptr->type == IFPF_IS_NORMAL ||
  404630:	0f b6 07             	movzbl (%rdi),%eax
  404633:	8d 50 ff             	lea    -0x1(%rax),%edx
  404636:	80 fa 01             	cmp    $0x1,%dl
  404639:	76 05                	jbe    404640 <RoundInternalFPF+0x10>
                }
*/
        }
}
return;
}
  40463b:	c3                   	retq   
  40463c:	0f 1f 40 00          	nopl   0x0(%rax)
** Round an internal-representation number.
** The kind of rounding we do here is simplest...referred to as
** "chop".  "Extraneous" rightmost bits are simply hacked off.
*/
void RoundInternalFPF(InternalFPF *ptr)
{
  404640:	53                   	push   %rbx
int i;          /* Index */
int n;          /* Return value */

n=0;
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
        n|=mant[i];
  404641:	0f b7 77 06          	movzwl 0x6(%rdi),%esi
  404645:	48 89 fb             	mov    %rdi,%rbx
  404648:	0f b7 4f 04          	movzwl 0x4(%rdi),%ecx
  40464c:	0f b7 7f 08          	movzwl 0x8(%rdi),%edi
  404650:	44 0f b7 43 0a       	movzwl 0xa(%rbx),%r8d
  404655:	89 f2                	mov    %esi,%edx
  404657:	09 ca                	or     %ecx,%edx
  404659:	09 fa                	or     %edi,%edx
static void denormalize(InternalFPF *ptr,
                int minimum_exponent)
{
long exponent_difference;

if (IsMantissaZero(ptr->mantissa))
  40465b:	66 44 09 c2          	or     %r8w,%dx
  40465f:	74 2f                	je     404690 <RoundInternalFPF+0x60>
{
        printf("Error:  zero significand in denormalize\n");
}

exponent_difference = ptr->exp-minimum_exponent;
if (exponent_difference < 0)
  404661:	66 81 7b 02 00 80    	cmpw   $0x8000,0x2(%rbx)
  404667:	0f 84 b3 00 00 00    	je     404720 <RoundInternalFPF+0xf0>

if (ptr->type == IFPF_IS_NORMAL ||
        ptr->type == IFPF_IS_SUBNORMAL)
{
        denormalize(ptr, MIN_EXP);
        if (ptr->type != IFPF_IS_ZERO)
  40466d:	84 c0                	test   %al,%al
  40466f:	75 07                	jne    404678 <RoundInternalFPF+0x48>
                }
*/
        }
}
return;
}
  404671:	5b                   	pop    %rbx
  404672:	f3 c3                	repz retq 
  404674:	0f 1f 40 00          	nopl   0x0(%rax)
  404678:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
        denormalize(ptr, MIN_EXP);
        if (ptr->type != IFPF_IS_ZERO)
        {

                /* clear the extraneous bits */
                ptr->mantissa[3] &= 0xfff8;
  40467c:	83 e0 f8             	and    $0xfffffff8,%eax
  40467f:	66 89 43 0a          	mov    %ax,0xa(%rbx)
                }
*/
        }
}
return;
}
  404683:	5b                   	pop    %rbx
  404684:	eb ec                	jmp    404672 <RoundInternalFPF+0x42>
  404686:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40468d:	00 00 00 
  404690:	bf 08 cb 40 00       	mov    $0x40cb08,%edi
  404695:	e8 f6 c7 ff ff       	callq  400e90 <puts@plt>
{
        printf("Error:  zero significand in denormalize\n");
}

exponent_difference = ptr->exp-minimum_exponent;
if (exponent_difference < 0)
  40469a:	66 81 7b 02 00 80    	cmpw   $0x8000,0x2(%rbx)
  4046a0:	0f b6 03             	movzbl (%rbx),%eax
  4046a3:	75 c8                	jne    40466d <RoundInternalFPF+0x3d>
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  4046a5:	ba 01 80 ff ff       	mov    $0xffff8001,%edx
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  4046aa:	84 c0                	test   %al,%al
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  4046ac:	66 89 53 02          	mov    %dx,0x2(%rbx)
u16 carry;      /* Self-explanatory */
u16 *mantissa;

mantissa=ptr->mantissa;

if(ptr->type!=IFPF_IS_ZERO)     /* Don't bother shifting a zero */
  4046b0:	74 bf                	je     404671 <RoundInternalFPF+0x41>
  4046b2:	0f b7 4b 04          	movzwl 0x4(%rbx),%ecx
  4046b6:	0f b7 73 06          	movzwl 0x6(%rbx),%esi
  4046ba:	0f b7 7b 08          	movzwl 0x8(%rbx),%edi
  4046be:	44 0f b7 43 0a       	movzwl 0xa(%rbx),%r8d
  4046c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4046c8:	89 c8                	mov    %ecx,%eax
  4046ca:	66 d1 e8             	shr    %ax
  4046cd:	66 89 43 04          	mov    %ax,0x4(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4046d1:	89 f0                	mov    %esi,%eax
  4046d3:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  4046d6:	89 c2                	mov    %eax,%edx
  4046d8:	66 81 ca 00 80       	or     $0x8000,%dx
  4046dd:	83 e1 01             	and    $0x1,%ecx
  4046e0:	0f 45 c2             	cmovne %edx,%eax
        *carry=new_carry;
        mantissa[i]=accum;
  4046e3:	66 89 43 06          	mov    %ax,0x6(%rbx)
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4046e7:	89 f8                	mov    %edi,%eax
  4046e9:	66 d1 e8             	shr    %ax
        if(*carry)
                accum|=0x8000;
  4046ec:	89 c2                	mov    %eax,%edx
  4046ee:	66 81 ca 00 80       	or     $0x8000,%dx
  4046f3:	83 e6 01             	and    $0x1,%esi
  4046f6:	0f 45 c2             	cmovne %edx,%eax
u16 accum;

for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
  4046f9:	44 89 c2             	mov    %r8d,%edx
  4046fc:	66 d1 ea             	shr    %dx
        if(*carry)
                accum|=0x8000;
        *carry=new_carry;
        mantissa[i]=accum;
  4046ff:	66 89 43 08          	mov    %ax,0x8(%rbx)
for(i=0;i<INTERNAL_FPF_PRECISION;i++)
{       accum=mantissa[i];
        new_carry=accum & 1;            /* Get new carry */
        accum=accum>>1;
        if(*carry)
                accum|=0x8000;
  404703:	89 d0                	mov    %edx,%eax
  404705:	66 0d 00 80          	or     $0x8000,%ax
  404709:	83 e7 01             	and    $0x1,%edi
  40470c:	0f 45 d0             	cmovne %eax,%edx
        else
                for(i=0;i<amount;i++)
                {
                        carry=0;
                        ShiftMantRight1(&carry,mantissa);
                        if(carry)
  40470f:	89 d0                	mov    %edx,%eax
  404711:	83 c8 01             	or     $0x1,%eax
  404714:	41 83 e0 01          	and    $0x1,%r8d
  404718:	0f 44 c2             	cmove  %edx,%eax
  40471b:	e9 5c ff ff ff       	jmpq   40467c <RoundInternalFPF+0x4c>
                /* Underflow */
                SetInternalFPFZero(ptr, ptr->sign);
        }
        else
        {
                ptr->exp+=exponent_difference;
  404720:	b8 01 80 ff ff       	mov    $0xffff8001,%eax
  404725:	66 89 43 02          	mov    %ax,0x2(%rbx)
  404729:	eb 9d                	jmp    4046c8 <RoundInternalFPF+0x98>
  40472b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000404730 <randwc>:
	static int32 randw[2] = { (int32)13 , (int32)117 };

	if (lngval!=(int32)0)
	{	randw[0]=(int32)13; randw[1]=(int32)117; }

	interm=(randw[0]*(int32)254754+randw[1]*(int32)529562)%(int32)999563;
  404730:	8b 35 5a ba 20 00    	mov    0x20ba5a(%rip),%esi        # 610190 <randw.2566>
  404736:	ba 99 c2 46 86       	mov    $0x8646c299,%edx
  40473b:	69 0d 4f ba 20 00 9a 	imul   $0x8149a,0x20ba4f(%rip),%ecx        # 610194 <randw.2566+0x4>
  404742:	14 08 00 
  404745:	69 c6 22 e3 03 00    	imul   $0x3e322,%esi,%eax
	randw[1]=randw[0];
  40474b:	89 35 43 ba 20 00    	mov    %esi,0x20ba43(%rip)        # 610194 <randw.2566+0x4>
	static int32 randw[2] = { (int32)13 , (int32)117 };

	if (lngval!=(int32)0)
	{	randw[0]=(int32)13; randw[1]=(int32)117; }

	interm=(randw[0]*(int32)254754+randw[1]*(int32)529562)%(int32)999563;
  404751:	01 c1                	add    %eax,%ecx
  404753:	89 c8                	mov    %ecx,%eax
  404755:	f7 ea                	imul   %edx
  404757:	8d 04 0a             	lea    (%rdx,%rcx,1),%eax
  40475a:	89 ca                	mov    %ecx,%edx
  40475c:	c1 fa 1f             	sar    $0x1f,%edx
  40475f:	c1 f8 13             	sar    $0x13,%eax
  404762:	29 d0                	sub    %edx,%eax
  404764:	69 c0 8b 40 0f 00    	imul   $0xf408b,%eax,%eax
  40476a:	29 c1                	sub    %eax,%ecx
  40476c:	89 c8                	mov    %ecx,%eax
	randw[1]=randw[0];
	randw[0]=interm;
  40476e:	89 0d 1c ba 20 00    	mov    %ecx,0x20ba1c(%rip)        # 610190 <randw.2566>
/*
** Returns signed 32-bit random modulo num.
*/
int32 randwc(int32 num)
{
	return(randnum((int32)0)%num);
  404774:	99                   	cltd   
  404775:	f7 ff                	idiv   %edi
}
  404777:	89 d0                	mov    %edx,%eax
  404779:	c3                   	retq   
  40477a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000404780 <abs_randwc>:
	static int32 randw[2] = { (int32)13 , (int32)117 };

	if (lngval!=(int32)0)
	{	randw[0]=(int32)13; randw[1]=(int32)117; }

	interm=(randw[0]*(int32)254754+randw[1]*(int32)529562)%(int32)999563;
  404780:	8b 35 0a ba 20 00    	mov    0x20ba0a(%rip),%esi        # 610190 <randw.2566>
  404786:	ba 99 c2 46 86       	mov    $0x8646c299,%edx
  40478b:	69 0d ff b9 20 00 9a 	imul   $0x8149a,0x20b9ff(%rip),%ecx        # 610194 <randw.2566+0x4>
  404792:	14 08 00 
  404795:	69 c6 22 e3 03 00    	imul   $0x3e322,%esi,%eax
	randw[1]=randw[0];
  40479b:	89 35 f3 b9 20 00    	mov    %esi,0x20b9f3(%rip)        # 610194 <randw.2566+0x4>
	static int32 randw[2] = { (int32)13 , (int32)117 };

	if (lngval!=(int32)0)
	{	randw[0]=(int32)13; randw[1]=(int32)117; }

	interm=(randw[0]*(int32)254754+randw[1]*(int32)529562)%(int32)999563;
  4047a1:	01 c1                	add    %eax,%ecx
  4047a3:	89 c8                	mov    %ecx,%eax
  4047a5:	f7 ea                	imul   %edx
  4047a7:	8d 04 0a             	lea    (%rdx,%rcx,1),%eax
  4047aa:	89 ca                	mov    %ecx,%edx
  4047ac:	c1 fa 1f             	sar    $0x1f,%edx
  4047af:	c1 f8 13             	sar    $0x13,%eax
  4047b2:	29 d0                	sub    %edx,%eax
  4047b4:	69 c0 8b 40 0f 00    	imul   $0xf408b,%eax,%eax
  4047ba:	29 c1                	sub    %eax,%ecx
  4047bc:	89 c8                	mov    %ecx,%eax
	randw[1]=randw[0];
	randw[0]=interm;
  4047be:	89 0d cc b9 20 00    	mov    %ecx,0x20b9cc(%rip)        # 610190 <randw.2566>
/*
** Returns signed 32-bit random modulo num.
*/
int32 randwc(int32 num)
{
	return(randnum((int32)0)%num);
  4047c4:	99                   	cltd   
  4047c5:	f7 ff                	idiv   %edi
int32 temp;		/* Temporary storage */ 

temp=randwc(num);
if(temp<0) temp=(int32)0-temp;

return((u32)temp);
  4047c7:	89 d1                	mov    %edx,%ecx
  4047c9:	89 d0                	mov    %edx,%eax
  4047cb:	c1 f9 1f             	sar    $0x1f,%ecx
  4047ce:	31 c8                	xor    %ecx,%eax
  4047d0:	29 c8                	sub    %ecx,%eax
}
  4047d2:	c3                   	retq   
  4047d3:	0f 1f 00             	nopl   (%rax)
  4047d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4047dd:	00 00 00 

00000000004047e0 <randnum>:
int32 randnum(int32 lngval)
{
	register int32 interm;
	static int32 randw[2] = { (int32)13 , (int32)117 };

	if (lngval!=(int32)0)
  4047e0:	85 ff                	test   %edi,%edi
  4047e2:	b8 d1 8f 04 00       	mov    $0x48fd1,%eax
  4047e7:	b9 0d 00 00 00       	mov    $0xd,%ecx
  4047ec:	75 38                	jne    404826 <randnum+0x46>
  4047ee:	8b 0d 9c b9 20 00    	mov    0x20b99c(%rip),%ecx        # 610190 <randw.2566>
  4047f4:	ba 99 c2 46 86       	mov    $0x8646c299,%edx
  4047f9:	69 35 91 b9 20 00 9a 	imul   $0x8149a,0x20b991(%rip),%esi        # 610194 <randw.2566+0x4>
  404800:	14 08 00 
  404803:	69 c1 22 e3 03 00    	imul   $0x3e322,%ecx,%eax
  404809:	01 c6                	add    %eax,%esi
  40480b:	89 f0                	mov    %esi,%eax
  40480d:	f7 ea                	imul   %edx
  40480f:	8d 04 32             	lea    (%rdx,%rsi,1),%eax
  404812:	89 f2                	mov    %esi,%edx
  404814:	c1 fa 1f             	sar    $0x1f,%edx
  404817:	c1 f8 13             	sar    $0x13,%eax
  40481a:	29 d0                	sub    %edx,%eax
  40481c:	69 c0 8b 40 0f 00    	imul   $0xf408b,%eax,%eax
  404822:	29 c6                	sub    %eax,%esi
  404824:	89 f0                	mov    %esi,%eax
	{	randw[0]=(int32)13; randw[1]=(int32)117; }

	interm=(randw[0]*(int32)254754+randw[1]*(int32)529562)%(int32)999563;
	randw[1]=randw[0];
  404826:	89 0d 68 b9 20 00    	mov    %ecx,0x20b968(%rip)        # 610194 <randw.2566+0x4>
	randw[0]=interm;
  40482c:	89 05 5e b9 20 00    	mov    %eax,0x20b95e(%rip)        # 610190 <randw.2566>
	return(interm);
}
  404832:	c3                   	retq   
  404833:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40483a:	00 00 00 
  40483d:	0f 1f 00             	nopl   (%rax)

0000000000404840 <output_string>:
** write_to_file is set, outputs the string to the output file.
** Note, this routine presumes that you've included a carriage
** return at the end of the buffer.
*/
static void output_string(char *buffer)
{
  404840:	53                   	push   %rbx
  404841:	48 89 fa             	mov    %rdi,%rdx
  404844:	31 c0                	xor    %eax,%eax
  404846:	48 89 fb             	mov    %rdi,%rbx
  404849:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40484e:	bf 01 00 00 00       	mov    $0x1,%edi
  404853:	e8 b8 c7 ff ff       	callq  401010 <__printf_chk@plt>

printf("%s",buffer);
if(write_to_file!=0)
  404858:	8b 05 aa bf 20 00    	mov    0x20bfaa(%rip),%eax        # 610808 <write_to_file>
  40485e:	85 c0                	test   %eax,%eax
  404860:	75 06                	jne    404868 <output_string+0x28>
        fprintf(global_ofile,"%s",buffer);
return;
}
  404862:	5b                   	pop    %rbx
  404863:	c3                   	retq   
  404864:	0f 1f 40 00          	nopl   0x0(%rax)

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  404868:	48 89 df             	mov    %rbx,%rdi
  40486b:	48 8b 35 d6 bf 20 00 	mov    0x20bfd6(%rip),%rsi        # 610848 <global_ofile>
  404872:	5b                   	pop    %rbx
  404873:	e9 c8 c6 ff ff       	jmpq   400f40 <fputs@plt>
  404878:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40487f:	00 

0000000000404880 <bench_with_confidence>:
*/
static int bench_with_confidence(int fid,       /* Function id */
        double *mean,                   /* Mean of scores */
        double *stdev,                  /* Standard deviation */
        ulong *numtries)                /* # of attempts */
{
  404880:	41 57                	push   %r15
  404882:	41 56                	push   %r14
  404884:	4c 63 f7             	movslq %edi,%r14
  404887:	41 55                	push   %r13
  404889:	41 54                	push   %r12
  40488b:	49 89 f7             	mov    %rsi,%r15
  40488e:	55                   	push   %rbp
  40488f:	53                   	push   %rbx
  404890:	4c 89 f5             	mov    %r14,%rbp
  404893:	49 89 d5             	mov    %rdx,%r13
  404896:	48 89 cb             	mov    %rcx,%rbx
  404899:	45 31 e4             	xor    %r12d,%r12d
  40489c:	48 81 ec 08 02 00 00 	sub    $0x208,%rsp
  4048a3:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4048aa:	00 00 
  4048ac:	48 89 84 24 f8 01 00 	mov    %rax,0x1f8(%rsp)
  4048b3:	00 
  4048b4:	31 c0                	xor    %eax,%eax
  4048b6:	44 89 24 24          	mov    %r12d,(%rsp)

/*
** Get first 5 scores.  Then begin confidence testing.
*/
for (i=0;i<5;i++)
{       (*funcpointer[fid])();
  4048ba:	42 ff 14 f5 a0 01 61 	callq  *0x6101a0(,%r14,8)
  4048c1:	00 

/*
** Fid tells us the function.  This is really a matter of
** doing the proper coercion.
*/
switch(fid)
  4048c2:	83 fd 09             	cmp    $0x9,%ebp
        case TF_NNET:
                return(global_nnetstruct.iterspersec);
        case TF_LU:
                return(global_lustruct.iterspersec);
}
return((double)0.0);
  4048c5:	66 0f ef c0          	pxor   %xmm0,%xmm0

/*
** Fid tells us the function.  This is really a matter of
** doing the proper coercion.
*/
switch(fid)
  4048c9:	8b 14 24             	mov    (%rsp),%edx
  4048cc:	77 12                	ja     4048e0 <bench_with_confidence+0x60>
  4048ce:	89 e8                	mov    %ebp,%eax
  4048d0:	ff 24 c5 30 db 40 00 	jmpq   *0x40db30(,%rax,8)
        case TF_ASSIGN:
                return(global_assignstruct.iterspersec);
        case TF_IDEA:
                return(global_ideastruct.iterspersec);
        case TF_HUFF:
                return(global_huffstruct.iterspersec);
  4048d7:	f2 0f 10 05 a1 be 20 	movsd  0x20bea1(%rip),%xmm0        # 610780 <global_huffstruct+0x20>
  4048de:	00 
  4048df:	90                   	nop
/*
** Get first 5 scores.  Then begin confidence testing.
*/
for (i=0;i<5;i++)
{       (*funcpointer[fid])();
        myscores[i]=getscore(fid);
  4048e0:	f2 42 0f 11 44 e4 10 	movsd  %xmm0,0x10(%rsp,%r12,8)
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4048e7:	be bf cd 40 00       	mov    $0x40cdbf,%esi
  4048ec:	bf 01 00 00 00       	mov    $0x1,%edi
  4048f1:	b8 01 00 00 00       	mov    $0x1,%eax
  4048f6:	49 83 c4 01          	add    $0x1,%r12
  4048fa:	e8 11 c7 ff ff       	callq  401010 <__printf_chk@plt>
/* double newscore; */          /* For improving confidence interval */

/*
** Get first 5 scores.  Then begin confidence testing.
*/
for (i=0;i<5;i++)
  4048ff:	49 83 fc 05          	cmp    $0x5,%r12
  404903:	75 b1                	jne    4048b6 <bench_with_confidence+0x36>
                double *sdev)               /* Sample stand dev */
{
/* Here is a list of the student-t distribution up to 29 degrees of
   freedom. The value at 0 is bogus, as there is no value for zero
   degrees of freedom. */
double student_t[30]={0.0 , 12.706 , 4.303 , 3.182 , 2.776 , 2.571 ,
  404905:	4c 8d a4 24 00 01 00 	lea    0x100(%rsp),%r12
  40490c:	00 
  40490d:	b9 1e 00 00 00       	mov    $0x1e,%ecx
  404912:	be 40 da 40 00       	mov    $0x40da40,%esi
        myscores[i]=getscore(fid);
#ifdef DEBUG
	printf("score # %d = %g\n", i, myscores[i]);
#endif
}
*numtries=5;            /* Show 5 attempts */
  404917:	48 c7 03 05 00 00 00 	movq   $0x5,(%rbx)
                double *sdev)               /* Sample stand dev */
{
/* Here is a list of the student-t distribution up to 29 degrees of
   freedom. The value at 0 is bogus, as there is no value for zero
   degrees of freedom. */
double student_t[30]={0.0 , 12.706 , 4.303 , 3.182 , 2.776 , 2.571 ,
  40491e:	ba 05 00 00 00       	mov    $0x5,%edx
  404923:	4c 89 e7             	mov    %r12,%rdi
  404926:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
  404929:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
}
/*
** First calculate mean.
*/
*smean=(double)0.0;
for(i=0;i<num_scores;i++){
  404930:	85 d2                	test   %edx,%edx
  return(-1);
}
/*
** First calculate mean.
*/
*smean=(double)0.0;
  404932:	49 c7 07 00 00 00 00 	movq   $0x0,(%r15)
for(i=0;i<num_scores;i++){
  404939:	0f 8e 05 02 00 00    	jle    404b44 <bench_with_confidence+0x2c4>
  40493f:	66 0f ef c0          	pxor   %xmm0,%xmm0
  404943:	31 c0                	xor    %eax,%eax
  404945:	0f 1f 00             	nopl   (%rax)
  *smean+=scores[i];
  404948:	f2 0f 58 44 c4 10    	addsd  0x10(%rsp,%rax,8),%xmm0
  40494e:	48 83 c0 01          	add    $0x1,%rax
}
/*
** First calculate mean.
*/
*smean=(double)0.0;
for(i=0;i<num_scores;i++){
  404952:	39 c2                	cmp    %eax,%edx
  404954:	7f f2                	jg     404948 <bench_with_confidence+0xc8>
  *smean+=scores[i];
}
*smean/=(double)num_scores;
  404956:	66 0f ef d2          	pxor   %xmm2,%xmm2

/* Get standard deviation */
*sdev=(double)0.0;
  40495a:	31 c0                	xor    %eax,%eax
*/
*smean=(double)0.0;
for(i=0;i<num_scores;i++){
  *smean+=scores[i];
}
*smean/=(double)num_scores;
  40495c:	f2 0f 2a d2          	cvtsi2sd %edx,%xmm2
  404960:	f2 0f 5e c2          	divsd  %xmm2,%xmm0
  404964:	f2 41 0f 11 07       	movsd  %xmm0,(%r15)

/* Get standard deviation */
*sdev=(double)0.0;
  404969:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40496d:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
  404974:	00 
  404975:	0f 1f 00             	nopl   (%rax)
for(i=0;i<num_scores;i++) {
  *sdev+=(scores[i]-(*smean))*(scores[i]-(*smean));
  404978:	f2 0f 10 4c c4 10    	movsd  0x10(%rsp,%rax,8),%xmm1
  40497e:	48 83 c0 01          	add    $0x1,%rax
}
*smean/=(double)num_scores;

/* Get standard deviation */
*sdev=(double)0.0;
for(i=0;i<num_scores;i++) {
  404982:	39 c2                	cmp    %eax,%edx
  *sdev+=(scores[i]-(*smean))*(scores[i]-(*smean));
  404984:	f2 41 0f 5c 0f       	subsd  (%r15),%xmm1
  404989:	f2 0f 59 c9          	mulsd  %xmm1,%xmm1
  40498d:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  404991:	f2 41 0f 11 45 00    	movsd  %xmm0,0x0(%r13)
}
*smean/=(double)num_scores;

/* Get standard deviation */
*sdev=(double)0.0;
for(i=0;i<num_scores;i++) {
  404997:	7f df                	jg     404978 <bench_with_confidence+0xf8>
  *sdev+=(scores[i]-(*smean))*(scores[i]-(*smean));
}
*sdev/=(double)(num_scores-1);
  404999:	66 0f ef c9          	pxor   %xmm1,%xmm1
  40499d:	83 ea 01             	sub    $0x1,%edx
  4049a0:	f2 0f 2a ca          	cvtsi2sd %edx,%xmm1
  4049a4:	f2 0f 5e c1          	divsd  %xmm1,%xmm0
*sdev=sqrt(*sdev);
  4049a8:	f2 0f 51 c8          	sqrtsd %xmm0,%xmm1
  4049ac:	66 0f 2e c9          	ucomisd %xmm1,%xmm1
/* Get standard deviation */
*sdev=(double)0.0;
for(i=0;i<num_scores;i++) {
  *sdev+=(scores[i]-(*smean))*(scores[i]-(*smean));
}
*sdev/=(double)(num_scores-1);
  4049b0:	f2 41 0f 11 45 00    	movsd  %xmm0,0x0(%r13)
*sdev=sqrt(*sdev);
  4049b6:	0f 8a 22 02 00 00    	jp     404bde <bench_with_confidence+0x35e>
** confidence level of 95% our confidence coefficient gives us a
** multiplying factor of the upper .025 quartile of a t distribution
** with num_scores-1 degrees of freedom, and dividing by sqrt(number of
** observations). See any introduction to statistics.
*/
*c_half_interval=student_t[num_scores-1] * (*sdev) / sqrt((double)num_scores);
  4049bc:	f2 0f 51 c2          	sqrtsd %xmm2,%xmm0
  4049c0:	66 0f 2e c0          	ucomisd %xmm0,%xmm0
  4049c4:	48 63 d2             	movslq %edx,%rdx
*sdev=(double)0.0;
for(i=0;i<num_scores;i++) {
  *sdev+=(scores[i]-(*smean))*(scores[i]-(*smean));
}
*sdev/=(double)(num_scores-1);
*sdev=sqrt(*sdev);
  4049c7:	f2 41 0f 11 4d 00    	movsd  %xmm1,0x0(%r13)
** confidence level of 95% our confidence coefficient gives us a
** multiplying factor of the upper .025 quartile of a t distribution
** with num_scores-1 degrees of freedom, and dividing by sqrt(number of
** observations). See any introduction to statistics.
*/
*c_half_interval=student_t[num_scores-1] * (*sdev) / sqrt((double)num_scores);
  4049cd:	f2 0f 59 8c d4 00 01 	mulsd  0x100(%rsp,%rdx,8),%xmm1
  4049d4:	00 00 
  4049d6:	0f 8a 22 02 00 00    	jp     404bfe <bench_with_confidence+0x37e>

        /*
        ** Is the length of the half interval 5% or less of mean?
        ** If so, we can go home.  Otherwise, we have to continue.
        */
        if(c_half_interval/ (*mean) <= (double)0.05)
  4049dc:	f2 0f 5e c8          	divsd  %xmm0,%xmm1
  4049e0:	f2 0f 10 1d 80 93 00 	movsd  0x9380(%rip),%xmm3        # 40dd68 <jtable.3055+0xfd8>
  4049e7:	00 
  4049e8:	f2 41 0f 5e 0f       	divsd  (%r15),%xmm1
  4049ed:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  4049f1:	0f 83 e0 01 00 00    	jae    404bd7 <bench_with_confidence+0x357>
	      } while(seek_confidence(myscores,&newscore,
		      &c_half_interval,mean,stdev)==0);
#endif
	/* We now simply add a new test run and hope that the runs
           finally stabilize, Uwe F. Mayer */
	if(*numtries==30) return(-1);
  4049f7:	48 83 3b 1e          	cmpq   $0x1e,(%rbx)
  4049fb:	0f 84 a0 00 00 00    	je     404aa1 <bench_with_confidence+0x221>
	(*funcpointer[fid])();
  404a01:	42 ff 14 f5 a0 01 61 	callq  *0x6101a0(,%r14,8)
  404a08:	00 

/*
** Fid tells us the function.  This is really a matter of
** doing the proper coercion.
*/
switch(fid)
  404a09:	83 fd 09             	cmp    $0x9,%ebp
#endif
	/* We now simply add a new test run and hope that the runs
           finally stabilize, Uwe F. Mayer */
	if(*numtries==30) return(-1);
	(*funcpointer[fid])();
	myscores[*numtries]=getscore(fid);
  404a0c:	48 8b 13             	mov    (%rbx),%rdx
        case TF_NNET:
                return(global_nnetstruct.iterspersec);
        case TF_LU:
                return(global_lustruct.iterspersec);
}
return((double)0.0);
  404a0f:	66 0f ef c0          	pxor   %xmm0,%xmm0

/*
** Fid tells us the function.  This is really a matter of
** doing the proper coercion.
*/
switch(fid)
  404a13:	77 1b                	ja     404a30 <bench_with_confidence+0x1b0>
  404a15:	89 e8                	mov    %ebp,%eax
  404a17:	ff 24 c5 80 db 40 00 	jmpq   *0x40db80(,%rax,8)
        case TF_IDEA:
                return(global_ideastruct.iterspersec);
        case TF_HUFF:
                return(global_huffstruct.iterspersec);
        case TF_NNET:
                return(global_nnetstruct.iterspersec);
  404a1e:	f2 0f 10 05 b2 c2 20 	movsd  0x20c2b2(%rip),%xmm0        # 610cd8 <global_nnetstruct+0x18>
  404a25:	00 
  404a26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  404a2d:	00 00 00 
  404a30:	be d0 cd 40 00       	mov    $0x40cdd0,%esi
  404a35:	bf 01 00 00 00       	mov    $0x1,%edi
  404a3a:	b8 01 00 00 00       	mov    $0x1,%eax
#endif
	/* We now simply add a new test run and hope that the runs
           finally stabilize, Uwe F. Mayer */
	if(*numtries==30) return(-1);
	(*funcpointer[fid])();
	myscores[*numtries]=getscore(fid);
  404a3f:	f2 0f 11 44 d4 10    	movsd  %xmm0,0x10(%rsp,%rdx,8)
  404a45:	e8 c6 c5 ff ff       	callq  401010 <__printf_chk@plt>
#ifdef DEBUG
	printf("score # %ld = %g\n", *numtries, myscores[*numtries]);
#endif
	*numtries+=1;
  404a4a:	48 8b 03             	mov    (%rbx),%rax
                double *sdev)               /* Sample stand dev */
{
/* Here is a list of the student-t distribution up to 29 degrees of
   freedom. The value at 0 is bogus, as there is no value for zero
   degrees of freedom. */
double student_t[30]={0.0 , 12.706 , 4.303 , 3.182 , 2.776 , 2.571 ,
  404a4d:	b9 1e 00 00 00       	mov    $0x1e,%ecx
  404a52:	4c 89 e7             	mov    %r12,%rdi
  404a55:	be 40 da 40 00       	mov    $0x40da40,%esi
  404a5a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	(*funcpointer[fid])();
	myscores[*numtries]=getscore(fid);
#ifdef DEBUG
	printf("score # %ld = %g\n", *numtries, myscores[*numtries]);
#endif
	*numtries+=1;
  404a5d:	48 83 c0 01          	add    $0x1,%rax
  404a61:	48 89 03             	mov    %rax,(%rbx)
while(1)
{
        /*
        ** Calculate confidence. Should always return 0.
        */
        if (0!=calc_confidence(myscores,
  404a64:	89 c2                	mov    %eax,%edx
                             2.201 , 2.179 , 2.160 , 2.145 , 2.131 ,
                             2.120 , 2.110 , 2.101 , 2.093 , 2.086 ,
                             2.080 , 2.074 , 2.069 , 2.064 , 2.060 ,
		             2.056 , 2.052 , 2.048 , 2.045 };
int i;          /* Index */
if ((num_scores<2) || (num_scores>30)) {
  404a66:	83 e8 02             	sub    $0x2,%eax
  404a69:	83 f8 1c             	cmp    $0x1c,%eax
  404a6c:	0f 86 be fe ff ff    	jbe    404930 <bench_with_confidence+0xb0>
  404a72:	bf 28 d2 40 00       	mov    $0x40d228,%edi
  404a77:	e8 14 c4 ff ff       	callq  400e90 <puts@plt>
*/
static void output_string(char *buffer)
{

printf("%s",buffer);
if(write_to_file!=0)
  404a7c:	8b 05 86 bd 20 00    	mov    0x20bd86(%rip),%eax        # 610808 <write_to_file>
  404a82:	85 c0                	test   %eax,%eax
  404a84:	74 1b                	je     404aa1 <bench_with_confidence+0x221>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  404a86:	48 8b 0d bb bd 20 00 	mov    0x20bdbb(%rip),%rcx        # 610848 <global_ofile>
  404a8d:	ba 48 00 00 00       	mov    $0x48,%edx
  404a92:	be 01 00 00 00       	mov    $0x1,%esi
  404a97:	bf 70 d2 40 00       	mov    $0x40d270,%edi
  404a9c:	e8 cf c5 ff ff       	callq  401070 <fwrite@plt>
	      } while(seek_confidence(myscores,&newscore,
		      &c_half_interval,mean,stdev)==0);
#endif
	/* We now simply add a new test run and hope that the runs
           finally stabilize, Uwe F. Mayer */
	if(*numtries==30) return(-1);
  404aa1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif
	*numtries+=1;
}

return(0);
}
  404aa6:	48 8b 8c 24 f8 01 00 	mov    0x1f8(%rsp),%rcx
  404aad:	00 
  404aae:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  404ab5:	00 00 
  404ab7:	0f 85 59 01 00 00    	jne    404c16 <bench_with_confidence+0x396>
  404abd:	48 81 c4 08 02 00 00 	add    $0x208,%rsp
  404ac4:	5b                   	pop    %rbx
  404ac5:	5d                   	pop    %rbp
  404ac6:	41 5c                	pop    %r12
  404ac8:	41 5d                	pop    %r13
  404aca:	41 5e                	pop    %r14
  404acc:	41 5f                	pop    %r15
  404ace:	c3                   	retq   
        case TF_ASSIGN:
                return(global_assignstruct.iterspersec);
        case TF_IDEA:
                return(global_ideastruct.iterspersec);
        case TF_HUFF:
                return(global_huffstruct.iterspersec);
  404acf:	f2 0f 10 05 a9 bc 20 	movsd  0x20bca9(%rip),%xmm0        # 610780 <global_huffstruct+0x20>
  404ad6:	00 
  404ad7:	e9 54 ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
        case TF_FFPU:
                return(global_fourierstruct.fflops);
        case TF_ASSIGN:
                return(global_assignstruct.iterspersec);
        case TF_IDEA:
                return(global_ideastruct.iterspersec);
  404adc:	f2 0f 10 05 dc bc 20 	movsd  0x20bcdc(%rip),%xmm0        # 6107c0 <global_ideastruct+0x20>
  404ae3:	00 
  404ae4:	e9 47 ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
        case TF_FPEMU:
                return(global_emfloatstruct.emflops);
        case TF_FFPU:
                return(global_fourierstruct.fflops);
        case TF_ASSIGN:
                return(global_assignstruct.iterspersec);
  404ae9:	f2 0f 10 05 87 bd 20 	movsd  0x20bd87(%rip),%xmm0        # 610878 <global_assignstruct+0x18>
  404af0:	00 
  404af1:	e9 3a ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
        case TF_BITOP:
                return(global_bitopstruct.bitopspersec);
        case TF_FPEMU:
                return(global_emfloatstruct.emflops);
        case TF_FFPU:
                return(global_fourierstruct.fflops);
  404af6:	f2 0f 10 05 ba c1 20 	movsd  0x20c1ba(%rip),%xmm0        # 610cb8 <global_fourierstruct+0x18>
  404afd:	00 
  404afe:	e9 2d ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
        case TF_SSORT:
                return(global_strsortstruct.sortspersec);
        case TF_BITOP:
                return(global_bitopstruct.bitopspersec);
        case TF_FPEMU:
                return(global_emfloatstruct.emflops);
  404b03:	f2 0f 10 05 15 c2 20 	movsd  0x20c215(%rip),%xmm0        # 610d20 <global_emfloatstruct+0x20>
  404b0a:	00 
  404b0b:	e9 20 ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
        case TF_NUMSORT:
                return(global_numsortstruct.sortspersec);
        case TF_SSORT:
                return(global_strsortstruct.sortspersec);
        case TF_BITOP:
                return(global_bitopstruct.bitopspersec);
  404b10:	f2 0f 10 05 d8 bc 20 	movsd  0x20bcd8(%rip),%xmm0        # 6107f0 <global_bitopstruct+0x10>
  404b17:	00 
  404b18:	e9 13 ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
        case TF_HUFF:
                return(global_huffstruct.iterspersec);
        case TF_NNET:
                return(global_nnetstruct.iterspersec);
        case TF_LU:
                return(global_lustruct.iterspersec);
  404b1d:	f2 0f 10 05 13 bc 20 	movsd  0x20bc13(%rip),%xmm0        # 610738 <global_lustruct+0x18>
  404b24:	00 
  404b25:	e9 06 ff ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
switch(fid)
{
        case TF_NUMSORT:
                return(global_numsortstruct.sortspersec);
        case TF_SSORT:
                return(global_strsortstruct.sortspersec);
  404b2a:	f2 0f 10 05 fe bc 20 	movsd  0x20bcfe(%rip),%xmm0        # 610830 <global_strsortstruct+0x10>
  404b31:	00 
  404b32:	e9 f9 fe ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
** doing the proper coercion.
*/
switch(fid)
{
        case TF_NUMSORT:
                return(global_numsortstruct.sortspersec);
  404b37:	f2 0f 10 05 11 c2 20 	movsd  0x20c211(%rip),%xmm0        # 610d50 <global_numsortstruct+0x10>
  404b3e:	00 
  404b3f:	e9 ec fe ff ff       	jmpq   404a30 <bench_with_confidence+0x1b0>
*/
*smean=(double)0.0;
for(i=0;i<num_scores;i++){
  *smean+=scores[i];
}
*smean/=(double)num_scores;
  404b44:	66 0f ef d2          	pxor   %xmm2,%xmm2
  404b48:	66 0f ef c0          	pxor   %xmm0,%xmm0
  404b4c:	f2 0f 2a d2          	cvtsi2sd %edx,%xmm2
  404b50:	f2 0f 5e c2          	divsd  %xmm2,%xmm0
  404b54:	f2 41 0f 11 07       	movsd  %xmm0,(%r15)
  404b59:	66 0f ef c0          	pxor   %xmm0,%xmm0
  404b5d:	e9 37 fe ff ff       	jmpq   404999 <bench_with_confidence+0x119>
        case TF_IDEA:
                return(global_ideastruct.iterspersec);
        case TF_HUFF:
                return(global_huffstruct.iterspersec);
        case TF_NNET:
                return(global_nnetstruct.iterspersec);
  404b62:	f2 0f 10 05 6e c1 20 	movsd  0x20c16e(%rip),%xmm0        # 610cd8 <global_nnetstruct+0x18>
  404b69:	00 
  404b6a:	e9 71 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
        case TF_FFPU:
                return(global_fourierstruct.fflops);
        case TF_ASSIGN:
                return(global_assignstruct.iterspersec);
        case TF_IDEA:
                return(global_ideastruct.iterspersec);
  404b6f:	f2 0f 10 05 49 bc 20 	movsd  0x20bc49(%rip),%xmm0        # 6107c0 <global_ideastruct+0x20>
  404b76:	00 
  404b77:	e9 64 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
        case TF_FPEMU:
                return(global_emfloatstruct.emflops);
        case TF_FFPU:
                return(global_fourierstruct.fflops);
        case TF_ASSIGN:
                return(global_assignstruct.iterspersec);
  404b7c:	f2 0f 10 05 f4 bc 20 	movsd  0x20bcf4(%rip),%xmm0        # 610878 <global_assignstruct+0x18>
  404b83:	00 
  404b84:	e9 57 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
        case TF_BITOP:
                return(global_bitopstruct.bitopspersec);
        case TF_FPEMU:
                return(global_emfloatstruct.emflops);
        case TF_FFPU:
                return(global_fourierstruct.fflops);
  404b89:	f2 0f 10 05 27 c1 20 	movsd  0x20c127(%rip),%xmm0        # 610cb8 <global_fourierstruct+0x18>
  404b90:	00 
  404b91:	e9 4a fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
        case TF_SSORT:
                return(global_strsortstruct.sortspersec);
        case TF_BITOP:
                return(global_bitopstruct.bitopspersec);
        case TF_FPEMU:
                return(global_emfloatstruct.emflops);
  404b96:	f2 0f 10 05 82 c1 20 	movsd  0x20c182(%rip),%xmm0        # 610d20 <global_emfloatstruct+0x20>
  404b9d:	00 
  404b9e:	e9 3d fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
        case TF_NUMSORT:
                return(global_numsortstruct.sortspersec);
        case TF_SSORT:
                return(global_strsortstruct.sortspersec);
        case TF_BITOP:
                return(global_bitopstruct.bitopspersec);
  404ba3:	f2 0f 10 05 45 bc 20 	movsd  0x20bc45(%rip),%xmm0        # 6107f0 <global_bitopstruct+0x10>
  404baa:	00 
  404bab:	e9 30 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
switch(fid)
{
        case TF_NUMSORT:
                return(global_numsortstruct.sortspersec);
        case TF_SSORT:
                return(global_strsortstruct.sortspersec);
  404bb0:	f2 0f 10 05 78 bc 20 	movsd  0x20bc78(%rip),%xmm0        # 610830 <global_strsortstruct+0x10>
  404bb7:	00 
  404bb8:	e9 23 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
** doing the proper coercion.
*/
switch(fid)
{
        case TF_NUMSORT:
                return(global_numsortstruct.sortspersec);
  404bbd:	f2 0f 10 05 8b c1 20 	movsd  0x20c18b(%rip),%xmm0        # 610d50 <global_numsortstruct+0x10>
  404bc4:	00 
  404bc5:	e9 16 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
        case TF_HUFF:
                return(global_huffstruct.iterspersec);
        case TF_NNET:
                return(global_nnetstruct.iterspersec);
        case TF_LU:
                return(global_lustruct.iterspersec);
  404bca:	f2 0f 10 05 66 bb 20 	movsd  0x20bb66(%rip),%xmm0        # 610738 <global_lustruct+0x18>
  404bd1:	00 
  404bd2:	e9 09 fd ff ff       	jmpq   4048e0 <bench_with_confidence+0x60>
	printf("score # %ld = %g\n", *numtries, myscores[*numtries]);
#endif
	*numtries+=1;
}

return(0);
  404bd7:	31 c0                	xor    %eax,%eax
  404bd9:	e9 c8 fe ff ff       	jmpq   404aa6 <bench_with_confidence+0x226>
  404bde:	89 54 24 0c          	mov    %edx,0xc(%rsp)
  404be2:	f2 0f 11 14 24       	movsd  %xmm2,(%rsp)
*sdev=(double)0.0;
for(i=0;i<num_scores;i++) {
  *sdev+=(scores[i]-(*smean))*(scores[i]-(*smean));
}
*sdev/=(double)(num_scores-1);
*sdev=sqrt(*sdev);
  404be7:	e8 a4 c4 ff ff       	callq  401090 <sqrt@plt>
  404bec:	8b 54 24 0c          	mov    0xc(%rsp),%edx
  404bf0:	66 0f 28 c8          	movapd %xmm0,%xmm1
  404bf4:	f2 0f 10 14 24       	movsd  (%rsp),%xmm2
  404bf9:	e9 be fd ff ff       	jmpq   4049bc <bench_with_confidence+0x13c>
** confidence level of 95% our confidence coefficient gives us a
** multiplying factor of the upper .025 quartile of a t distribution
** with num_scores-1 degrees of freedom, and dividing by sqrt(number of
** observations). See any introduction to statistics.
*/
*c_half_interval=student_t[num_scores-1] * (*sdev) / sqrt((double)num_scores);
  404bfe:	66 0f 28 c2          	movapd %xmm2,%xmm0
  404c02:	f2 0f 11 0c 24       	movsd  %xmm1,(%rsp)
  404c07:	e8 84 c4 ff ff       	callq  401090 <sqrt@plt>
  404c0c:	f2 0f 10 0c 24       	movsd  (%rsp),%xmm1
  404c11:	e9 c6 fd ff ff       	jmpq   4049dc <bench_with_confidence+0x15c>
#endif
	*numtries+=1;
}

return(0);
}
  404c16:	e8 e5 c2 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  404c1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000404c20 <Assignment>:

/***************
** Assignment **
***************/
static void Assignment(farlong arraybase[][ASSIGNCOLS])
{
  404c20:	41 57                	push   %r15
  404c22:	41 56                	push   %r14
  404c24:	48 8d b7 c8 3e 01 00 	lea    0x13ec8(%rdi),%rsi
  404c2b:	41 55                	push   %r13
  404c2d:	41 54                	push   %r12
  404c2f:	49 89 f9             	mov    %rdi,%r9
  404c32:	55                   	push   %rbp
  404c33:	53                   	push   %rbx
** for that row.
*/
for(i=0;i<ASSIGNROWS;i++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(j=0;j<ASSIGNCOLS;j++)
  404c34:	45 31 db             	xor    %r11d,%r11d

/***************
** Assignment **
***************/
static void Assignment(farlong arraybase[][ASSIGNCOLS])
{
  404c37:	48 81 ec 78 51 00 00 	sub    $0x5178,%rsp
  404c3e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  404c45:	00 00 
  404c47:	48 89 84 24 68 51 00 	mov    %rax,0x5168(%rsp)
  404c4e:	00 
  404c4f:	31 c0                	xor    %eax,%eax
  404c51:	4c 8d 87 28 03 00 00 	lea    0x328(%rdi),%r8
  404c58:	48 89 f8             	mov    %rdi,%rax
  404c5b:	48 ba ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdx
  404c62:	ff ff 7f 
*/
for(i=0;i<ASSIGNROWS;i++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(j=0;j<ASSIGNCOLS;j++)
		if(tableau[i][j]<currentmin)
  404c65:	48 8b 08             	mov    (%rax),%rcx
  404c68:	48 39 ca             	cmp    %rcx,%rdx
  404c6b:	48 0f 4f d1          	cmovg  %rcx,%rdx
  404c6f:	48 83 c0 08          	add    $0x8,%rax
** for that row.
*/
for(i=0;i<ASSIGNROWS;i++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(j=0;j<ASSIGNCOLS;j++)
  404c73:	4c 39 c0             	cmp    %r8,%rax
  404c76:	75 ed                	jne    404c65 <Assignment+0x45>
  404c78:	40 f6 c7 08          	test   $0x8,%dil
  404c7c:	0f 84 e1 03 00 00    	je     405063 <Assignment+0x443>
		if(tableau[i][j]<currentmin)
			currentmin=tableau[i][j];

	for(j=0;j<ASSIGNCOLS;j++)
		tableau[i][j]-=currentmin;
  404c82:	48 29 17             	sub    %rdx,(%rdi)
  404c85:	b8 01 00 00 00       	mov    $0x1,%eax
  404c8a:	bb 64 00 00 00       	mov    $0x64,%ebx
  404c8f:	48 89 14 24          	mov    %rdx,(%rsp)
  404c93:	4c 01 d8             	add    %r11,%rax
** for that row.
*/
for(i=0;i<ASSIGNROWS;i++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(j=0;j<ASSIGNCOLS;j++)
  404c96:	31 c9                	xor    %ecx,%ecx
  404c98:	f3 0f 7e 0c 24       	movq   (%rsp),%xmm1
  404c9d:	4d 8d 14 c1          	lea    (%r9,%rax,8),%r10
  404ca1:	66 0f 6c c9          	punpcklqdq %xmm1,%xmm1
  404ca5:	31 c0                	xor    %eax,%eax
  404ca7:	83 c1 01             	add    $0x1,%ecx
		if(tableau[i][j]<currentmin)
			currentmin=tableau[i][j];

	for(j=0;j<ASSIGNCOLS;j++)
		tableau[i][j]-=currentmin;
  404caa:	66 41 0f 6f 04 02    	movdqa (%r10,%rax,1),%xmm0
  404cb0:	66 0f fb c1          	psubq  %xmm1,%xmm0
  404cb4:	41 0f 29 04 02       	movaps %xmm0,(%r10,%rax,1)
  404cb9:	48 83 c0 10          	add    $0x10,%rax
  404cbd:	66 83 f9 31          	cmp    $0x31,%cx
  404cc1:	76 e4                	jbe    404ca7 <Assignment+0x87>
  404cc3:	66 83 fb 64          	cmp    $0x64,%bx
  404cc7:	74 07                	je     404cd0 <Assignment+0xb0>
  404cc9:	48 29 97 20 03 00 00 	sub    %rdx,0x320(%rdi)
  404cd0:	49 83 c3 65          	add    $0x65,%r11
/*
** Determine minimum costs on row basis.  This is done by
** subtracting -- on a row-per-row basis -- the minum value
** for that row.
*/
for(i=0;i<ASSIGNROWS;i++)
  404cd4:	4c 39 c6             	cmp    %r8,%rsi
  404cd7:	4c 89 c7             	mov    %r8,%rdi
  404cda:	0f 85 71 ff ff ff    	jne    404c51 <Assignment+0x31>
  404ce0:	4d 8d 81 28 03 00 00 	lea    0x328(%r9),%r8
  404ce7:	4c 89 cf             	mov    %r9,%rdi
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(j=0;j<ASSIGNCOLS;j++)
  404cea:	48 89 f8             	mov    %rdi,%rax
  404ced:	48 ba ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdx
  404cf4:	ff ff 7f 
*/
for(j=0;j<ASSIGNCOLS;j++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(i=0;i<ASSIGNROWS;i++)
		if(tableau[i][j]<currentmin)
  404cf7:	48 8b 08             	mov    (%rax),%rcx
  404cfa:	48 39 ca             	cmp    %rcx,%rdx
  404cfd:	48 0f 4f d1          	cmovg  %rcx,%rdx
  404d01:	48 05 28 03 00 00    	add    $0x328,%rax
** column-wise
*/
for(j=0;j<ASSIGNCOLS;j++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(i=0;i<ASSIGNROWS;i++)
  404d07:	48 39 f0             	cmp    %rsi,%rax
  404d0a:	75 eb                	jne    404cf7 <Assignment+0xd7>
	** Here, we'll take the trouble to see if the current
	** minimum is zero.  This is likely worth it, since the
	** preceding loop will have created at least one zero in
	** each row.  We can save ourselves a few iterations.
	*/
	if(currentmin!=0)
  404d0c:	48 85 d2             	test   %rdx,%rdx
  404d0f:	0f 85 5b 03 00 00    	jne    405070 <Assignment+0x450>
  404d15:	48 83 c7 08          	add    $0x8,%rdi
  404d19:	48 83 c6 08          	add    $0x8,%rsi
/*
** Determine minimum cost on a column basis.  This works
** just as above, only now we step through the array
** column-wise
*/
for(j=0;j<ASSIGNCOLS;j++)
  404d1d:	4c 39 c7             	cmp    %r8,%rdi
  404d20:	75 c8                	jne    404cea <Assignment+0xca>
  404d22:	48 8d 84 24 62 51 00 	lea    0x5162(%rsp),%rax
  404d29:	00 
  404d2a:	4c 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%r8
  404d31:	00 
  404d32:	4c 8d 54 24 10       	lea    0x10(%rsp),%r10
  404d37:	48 89 04 24          	mov    %rax,(%rsp)
  404d3b:	49 8d 80 ca 00 00 00 	lea    0xca(%r8),%rax
  404d42:	49 8d b2 ca 00 00 00 	lea    0xca(%r10),%rsi
  404d49:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  404d4e:	48 8d 9c 24 b0 01 00 	lea    0x1b0(%rsp),%rbx
  404d55:	00 
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]==0)
		for(j=0;j<ASSIGNCOLS;j++)
			if(linescol[j]==1)
				tableau[i][j]+=smallest;
  404d56:	48 89 da             	mov    %rbx,%rdx
  404d59:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
  404d5d:	48 89 d1             	mov    %rdx,%rcx
  404d60:	31 c0                	xor    %eax,%eax
  404d62:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  404d69:	48 c7 82 c2 00 00 00 	movq   $0x0,0xc2(%rdx)
  404d70:	00 00 00 00 
  404d74:	48 81 c2 ca 00 00 00 	add    $0xca,%rdx
  404d7b:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  404d7f:	48 29 f9             	sub    %rdi,%rcx
  404d82:	81 c1 ca 00 00 00    	add    $0xca,%ecx
  404d88:	c1 e9 03             	shr    $0x3,%ecx
  404d8b:	f3 48 ab             	rep stos %rax,%es:(%rdi)

/*
** Clear the assignedtableau, setting all members to show that
** no one is yet assigned, eliminated, or anything.
*/
for(i=0;i<ASSIGNROWS;i++)
  404d8e:	48 39 14 24          	cmp    %rdx,(%rsp)
  404d92:	75 c5                	jne    404d59 <Assignment+0x139>
  404d94:	31 ff                	xor    %edi,%edi
  404d96:	45 31 db             	xor    %r11d,%r11d
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[i][selected]=1;
			for(k=0;k<ASSIGNROWS;k++)
  404d99:	4c 8d a4 24 b0 01 00 	lea    0x1b0(%rsp),%r12
  404da0:	00 
  404da1:	4c 89 ca             	mov    %r9,%rdx
	for(j=0;j<ASSIGNCOLS;j++)
		assignedtableau[i][j]=0;

totnumassigns=0;
do {
	numassigns=0;
  404da4:	31 ed                	xor    %ebp,%ebp
	** Step through rows.  For each one that is not currently
	** assigned, see if the row has only one zero in it.  If so,
	** mark that as an assigned row/col.  Eliminate other zeros
	** in the same column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
  404da6:	45 31 ed             	xor    %r13d,%r13d
  404da9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	{       numzeros=0;
		for(j=0;j<ASSIGNCOLS;j++)
			if(tableau[i][j]==0L)
				if(assignedtableau[i][j]==0)
  404db0:	31 c0                	xor    %eax,%eax
  404db2:	31 c9                	xor    %ecx,%ecx
  404db4:	0f 1f 40 00          	nopl   0x0(%rax)
	** in the same column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
	{       numzeros=0;
		for(j=0;j<ASSIGNCOLS;j++)
			if(tableau[i][j]==0L)
  404db8:	48 83 3c c2 00       	cmpq   $0x0,(%rdx,%rax,8)
  404dbd:	75 0d                	jne    404dcc <Assignment+0x1ac>
				if(assignedtableau[i][j]==0)
  404dbf:	66 41 83 3c 44 00    	cmpw   $0x0,(%r12,%rax,2)
  404dc5:	75 05                	jne    404dcc <Assignment+0x1ac>
				{       numzeros++;
  404dc7:	83 c1 01             	add    $0x1,%ecx
					selected=j;
  404dca:	89 c7                	mov    %eax,%edi
  404dcc:	48 83 c0 01          	add    $0x1,%rax
	** mark that as an assigned row/col.  Eliminate other zeros
	** in the same column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
	{       numzeros=0;
		for(j=0;j<ASSIGNCOLS;j++)
  404dd0:	48 83 f8 65          	cmp    $0x65,%rax
  404dd4:	75 e2                	jne    404db8 <Assignment+0x198>
			if(tableau[i][j]==0L)
				if(assignedtableau[i][j]==0)
				{       numzeros++;
					selected=j;
				}
		if(numzeros==1)
  404dd6:	66 83 f9 01          	cmp    $0x1,%cx
  404dda:	0f 84 0b 03 00 00    	je     4050eb <Assignment+0x4cb>
	** Step through rows.  For each one that is not currently
	** assigned, see if the row has only one zero in it.  If so,
	** mark that as an assigned row/col.  Eliminate other zeros
	** in the same column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
  404de0:	41 83 c5 01          	add    $0x1,%r13d
  404de4:	49 81 c4 ca 00 00 00 	add    $0xca,%r12
  404deb:	48 81 c2 28 03 00 00 	add    $0x328,%rdx
  404df2:	66 41 83 fd 65       	cmp    $0x65,%r13w
  404df7:	75 b7                	jne    404db0 <Assignment+0x190>
  404df9:	4c 8d a4 24 b0 01 00 	lea    0x1b0(%rsp),%r12
  404e00:	00 
  404e01:	4c 89 c9             	mov    %r9,%rcx
  404e04:	45 31 f6             	xor    %r14d,%r14d
  404e07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  404e0e:	00 00 
  404e10:	45 89 f5             	mov    %r14d,%r13d
  404e13:	31 c0                	xor    %eax,%eax
  404e15:	31 d2                	xor    %edx,%edx
  404e17:	45 31 ff             	xor    %r15d,%r15d
  404e1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	** of items in the other rows of a selected column.
	*/
	for(j=0;j<ASSIGNCOLS;j++)
	{       numzeros=0;
		for(i=0;i<ASSIGNROWS;i++)
			if(tableau[i][j]==0L)
  404e20:	48 83 3c 81 00       	cmpq   $0x0,(%rcx,%rax,4)
  404e25:	75 0e                	jne    404e35 <Assignment+0x215>
				if(assignedtableau[i][j]==0)
  404e27:	66 41 83 3c 04 00    	cmpw   $0x0,(%r12,%rax,1)
  404e2d:	75 06                	jne    404e35 <Assignment+0x215>
				{       numzeros++;
  404e2f:	41 83 c7 01          	add    $0x1,%r15d
					selected=i;
  404e33:	89 d7                	mov    %edx,%edi
  404e35:	48 05 ca 00 00 00    	add    $0xca,%rax
  404e3b:	83 c2 01             	add    $0x1,%edx
	** Step through columns, doing same as above.  Now, be careful
	** of items in the other rows of a selected column.
	*/
	for(j=0;j<ASSIGNCOLS;j++)
	{       numzeros=0;
		for(i=0;i<ASSIGNROWS;i++)
  404e3e:	48 3d b2 4f 00 00    	cmp    $0x4fb2,%rax
  404e44:	75 da                	jne    404e20 <Assignment+0x200>
			if(tableau[i][j]==0L)
				if(assignedtableau[i][j]==0)
				{       numzeros++;
					selected=i;
				}
		if(numzeros==1)
  404e46:	66 41 83 ff 01       	cmp    $0x1,%r15w
  404e4b:	0f 84 3f 02 00 00    	je     405090 <Assignment+0x470>
  404e51:	41 83 c6 01          	add    $0x1,%r14d
  404e55:	48 83 c1 08          	add    $0x8,%rcx
  404e59:	49 83 c4 02          	add    $0x2,%r12
	}
	/*
	** Step through columns, doing same as above.  Now, be careful
	** of items in the other rows of a selected column.
	*/
	for(j=0;j<ASSIGNCOLS;j++)
  404e5d:	41 83 fe 65          	cmp    $0x65,%r14d
  404e61:	75 ad                	jne    404e10 <Assignment+0x1f0>
		}
	}
	/*
	** Repeat until no more assignments to be made.
	*/
} while(numassigns!=0);
  404e63:	66 85 ed             	test   %bp,%bp
  404e66:	0f 85 2d ff ff ff    	jne    404d99 <Assignment+0x179>

/*
** See if we can leave at this point.
*/
if(totnumassigns==ASSIGNROWS) return(totnumassigns);
  404e6c:	66 41 83 fb 65       	cmp    $0x65,%r11w
  404e71:	0f 84 c3 02 00 00    	je     40513a <Assignment+0x51a>
  404e77:	48 8d ac 24 b0 01 00 	lea    0x1b0(%rsp),%rbp
  404e7e:	00 
  404e7f:	4c 89 c9             	mov    %r9,%rcx
  404e82:	31 ff                	xor    %edi,%edi
*/
for(i=0;i<ASSIGNROWS;i++)
{       selected=-1;
	for(j=0;j<ASSIGNCOLS;j++)
		if((tableau[i][j]==0L) &&
		   (assignedtableau[i][j]==0))
  404e84:	31 c0                	xor    %eax,%eax
  404e86:	eb 16                	jmp    404e9e <Assignment+0x27e>
  404e88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  404e8f:	00 
  404e90:	48 83 c0 01          	add    $0x1,%rax
** that same row & column.  This occurs if there are multiple optima...
** possibly.
*/
for(i=0;i<ASSIGNROWS;i++)
{       selected=-1;
	for(j=0;j<ASSIGNCOLS;j++)
  404e94:	48 83 f8 65          	cmp    $0x65,%rax
  404e98:	0f 84 8b 00 00 00    	je     404f29 <Assignment+0x309>
		if((tableau[i][j]==0L) &&
  404e9e:	48 83 3c c1 00       	cmpq   $0x0,(%rcx,%rax,8)
  404ea3:	89 c2                	mov    %eax,%edx
  404ea5:	75 e9                	jne    404e90 <Assignment+0x270>
  404ea7:	66 83 7c 45 00 00    	cmpw   $0x0,0x0(%rbp,%rax,2)
  404ead:	75 e1                	jne    404e90 <Assignment+0x270>
		   (assignedtableau[i][j]==0))
		{       selected=j;
			break;
		}
	if(selected!=-1)
	{       assignedtableau[i][selected]=1;
  404eaf:	4c 63 e8             	movslq %eax,%r13
  404eb2:	b8 01 00 00 00       	mov    $0x1,%eax
		totnumassigns++;
  404eb7:	41 83 c3 01          	add    $0x1,%r11d
		   (assignedtableau[i][j]==0))
		{       selected=j;
			break;
		}
	if(selected!=-1)
	{       assignedtableau[i][selected]=1;
  404ebb:	66 42 89 44 6d 00    	mov    %ax,0x0(%rbp,%r13,2)
		totnumassigns++;
  404ec1:	31 c0                	xor    %eax,%eax
  404ec3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		for(k=0;k<ASSIGNCOLS;k++)
			if((k!=selected) &&
  404ec8:	39 c2                	cmp    %eax,%edx
  404eca:	74 13                	je     404edf <Assignment+0x2bf>
  404ecc:	48 83 3c c1 00       	cmpq   $0x0,(%rcx,%rax,8)
  404ed1:	75 0c                	jne    404edf <Assignment+0x2bf>
			   (tableau[i][k]==0L))
				assignedtableau[i][k]=2;
  404ed3:	41 bf 02 00 00 00    	mov    $0x2,%r15d
  404ed9:	66 44 89 7c 45 00    	mov    %r15w,0x0(%rbp,%rax,2)
  404edf:	48 83 c0 01          	add    $0x1,%rax
			break;
		}
	if(selected!=-1)
	{       assignedtableau[i][selected]=1;
		totnumassigns++;
		for(k=0;k<ASSIGNCOLS;k++)
  404ee3:	48 83 f8 65          	cmp    $0x65,%rax
  404ee7:	75 df                	jne    404ec8 <Assignment+0x2a8>
  404ee9:	4f 8d 24 e9          	lea    (%r9,%r13,8),%r12
  404eed:	4e 8d ac 6c b0 01 00 	lea    0x1b0(%rsp,%r13,2),%r13
  404ef4:	00 
  404ef5:	31 c0                	xor    %eax,%eax
  404ef7:	31 d2                	xor    %edx,%edx
  404ef9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
			if((k!=selected) &&
			   (tableau[i][k]==0L))
				assignedtableau[i][k]=2;
		for(k=0;k<ASSIGNROWS;k++)
			if((k!=i) &&
  404f00:	66 39 d7             	cmp    %dx,%di
  404f03:	74 13                	je     404f18 <Assignment+0x2f8>
  404f05:	49 83 3c 84 00       	cmpq   $0x0,(%r12,%rax,4)
  404f0a:	75 0c                	jne    404f18 <Assignment+0x2f8>
			   (tableau[k][selected]==0L))
				assignedtableau[k][selected]=2;
  404f0c:	41 be 02 00 00 00    	mov    $0x2,%r14d
  404f12:	66 45 89 74 05 00    	mov    %r14w,0x0(%r13,%rax,1)
  404f18:	48 05 ca 00 00 00    	add    $0xca,%rax
		totnumassigns++;
		for(k=0;k<ASSIGNCOLS;k++)
			if((k!=selected) &&
			   (tableau[i][k]==0L))
				assignedtableau[i][k]=2;
		for(k=0;k<ASSIGNROWS;k++)
  404f1e:	83 c2 01             	add    $0x1,%edx
  404f21:	48 3d b2 4f 00 00    	cmp    $0x4fb2,%rax
  404f27:	75 d7                	jne    404f00 <Assignment+0x2e0>
** Now step through the array by row.  If you find any unassigned
** zeros, pick the first in the row.  Eliminate all zeros from
** that same row & column.  This occurs if there are multiple optima...
** possibly.
*/
for(i=0;i<ASSIGNROWS;i++)
  404f29:	83 c7 01             	add    $0x1,%edi
  404f2c:	48 81 c1 28 03 00 00 	add    $0x328,%rcx
  404f33:	48 81 c5 ca 00 00 00 	add    $0xca,%rbp
  404f3a:	66 83 ff 65          	cmp    $0x65,%di
  404f3e:	0f 85 40 ff ff ff    	jne    404e84 <Assignment+0x264>

/*
** Repeat following until the number of rows selected
** equals the number of rows in the tableau.
*/
while(first_assignments(arraybase,assignedtableau)!=ASSIGNROWS)
  404f44:	66 41 83 fb 65       	cmp    $0x65,%r11w
  404f49:	0f 84 eb 01 00 00    	je     40513a <Assignment+0x51a>
  404f4f:	31 c0                	xor    %eax,%eax
  404f51:	b9 19 00 00 00       	mov    $0x19,%ecx
  404f56:	4c 89 d7             	mov    %r10,%rdi
  404f59:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  404f5c:	45 31 f6             	xor    %r14d,%r14d
  404f5f:	b9 19 00 00 00       	mov    $0x19,%ecx
  404f64:	45 31 ff             	xor    %r15d,%r15d
  404f67:	66 44 89 37          	mov    %r14w,(%rdi)
  404f6b:	4c 89 c7             	mov    %r8,%rdi
  404f6e:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  404f71:	48 8d 84 24 b0 01 00 	lea    0x1b0(%rsp),%rax
  404f78:	00 
  404f79:	4c 89 d1             	mov    %r10,%rcx
  404f7c:	66 44 89 3f          	mov    %r15w,(%rdi)
  404f80:	4c 89 d7             	mov    %r10,%rdi
  404f83:	48 8d 90 ca 00 00 00 	lea    0xca(%rax),%rdx
  404f8a:	eb 11                	jmp    404f9d <Assignment+0x37d>
  404f8c:	0f 1f 40 00          	nopl   0x0(%rax)
  404f90:	48 83 c0 02          	add    $0x2,%rax
/*
** Scan rows, flag each row that has no assignment in it.
*/
for(i=0;i<ASSIGNROWS;i++)
{       numassigns=0;
	for(j=0;j<ASSIGNCOLS;j++)
  404f94:	48 39 c2             	cmp    %rax,%rdx
  404f97:	0f 84 33 02 00 00    	je     4051d0 <Assignment+0x5b0>
		if(assignedtableau[i][j]==1)
  404f9d:	66 83 38 01          	cmpw   $0x1,(%rax)
  404fa1:	75 ed                	jne    404f90 <Assignment+0x370>
  404fa3:	48 83 c1 02          	add    $0x2,%rcx
	linescol[i]=0;

/*
** Scan rows, flag each row that has no assignment in it.
*/
for(i=0;i<ASSIGNROWS;i++)
  404fa7:	48 39 14 24          	cmp    %rdx,(%rsp)
  404fab:	48 89 d0             	mov    %rdx,%rax
  404fae:	75 d3                	jne    404f83 <Assignment+0x363>
  404fb0:	48 8b 6c 24 08       	mov    0x8(%rsp),%rbp

/*
** Repeat following until the number of rows selected
** equals the number of rows in the tableau.
*/
while(first_assignments(arraybase,assignedtableau)!=ASSIGNROWS)
  404fb5:	4c 89 ca             	mov    %r9,%rdx
  404fb8:	4c 89 d1             	mov    %r10,%rcx
  404fbb:	eb 10                	jmp    404fcd <Assignment+0x3ad>
  404fbd:	48 83 c1 02          	add    $0x2,%rcx
  404fc1:	48 81 c2 28 03 00 00 	add    $0x328,%rdx
	newrows=0;
	/*
	** For each row checked above, scan for any zeros.  If found,
	** check the associated column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
  404fc8:	48 39 ce             	cmp    %rcx,%rsi
  404fcb:	74 39                	je     405006 <Assignment+0x3e6>
	{       if(linesrow[i]==1)
  404fcd:	66 83 39 01          	cmpw   $0x1,(%rcx)
  404fd1:	75 ea                	jne    404fbd <Assignment+0x39d>
  404fd3:	31 c0                	xor    %eax,%eax
  404fd5:	0f 1f 00             	nopl   (%rax)
			for(j=0;j<ASSIGNCOLS;j++)
				if(tableau[i][j]==0)
  404fd8:	48 83 3c 82 00       	cmpq   $0x0,(%rdx,%rax,4)
  404fdd:	75 0b                	jne    404fea <Assignment+0x3ca>
					linescol[j]=1;
  404fdf:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  404fe5:	66 45 89 2c 00       	mov    %r13w,(%r8,%rax,1)
  404fea:	48 83 c0 02          	add    $0x2,%rax
	** For each row checked above, scan for any zeros.  If found,
	** check the associated column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
	{       if(linesrow[i]==1)
			for(j=0;j<ASSIGNCOLS;j++)
  404fee:	48 3d ca 00 00 00    	cmp    $0xca,%rax
  404ff4:	75 e2                	jne    404fd8 <Assignment+0x3b8>
  404ff6:	48 83 c1 02          	add    $0x2,%rcx
  404ffa:	48 81 c2 28 03 00 00 	add    $0x328,%rdx
	newrows=0;
	/*
	** For each row checked above, scan for any zeros.  If found,
	** check the associated column.
	*/
	for(i=0;i<ASSIGNROWS;i++)
  405001:	48 39 ce             	cmp    %rcx,%rsi
  405004:	75 c7                	jne    404fcd <Assignment+0x3ad>
  405006:	4d 89 c3             	mov    %r8,%r11
  405009:	48 8d 9c 24 b0 01 00 	lea    0x1b0(%rsp),%rbx
  405010:	00 
  405011:	31 c9                	xor    %ecx,%ecx
  405013:	eb 11                	jmp    405026 <Assignment+0x406>
  405015:	49 83 c3 02          	add    $0x2,%r11
  405019:	48 83 c3 02          	add    $0x2,%rbx

	/*
	** Now scan checked columns.  If any contain assigned zeros, check
	** the associated row.
	*/
	for(j=0;j<ASSIGNCOLS;j++)
  40501d:	49 39 eb             	cmp    %rbp,%r11
  405020:	0f 84 d2 01 00 00    	je     4051f8 <Assignment+0x5d8>
		if(linescol[j]==1)
  405026:	66 41 83 3b 01       	cmpw   $0x1,(%r11)
  40502b:	75 e8                	jne    405015 <Assignment+0x3f5>
  40502d:	4c 89 d0             	mov    %r10,%rax
  405030:	48 89 da             	mov    %rbx,%rdx
  405033:	eb 13                	jmp    405048 <Assignment+0x428>
  405035:	0f 1f 00             	nopl   (%rax)
  405038:	48 83 c0 02          	add    $0x2,%rax
  40503c:	48 81 c2 ca 00 00 00 	add    $0xca,%rdx
			for(i=0;i<ASSIGNROWS;i++)
  405043:	48 39 f0             	cmp    %rsi,%rax
  405046:	74 cd                	je     405015 <Assignment+0x3f5>
				if((assignedtableau[i][j]==1) &&
  405048:	66 83 3a 01          	cmpw   $0x1,(%rdx)
  40504c:	75 ea                	jne    405038 <Assignment+0x418>
  40504e:	66 83 38 01          	cmpw   $0x1,(%rax)
  405052:	74 e4                	je     405038 <Assignment+0x418>
					(linesrow[i]!=1))
				{
					linesrow[i]=1;
  405054:	41 bc 01 00 00 00    	mov    $0x1,%r12d
					newrows++;
  40505a:	83 c1 01             	add    $0x1,%ecx
		if(linescol[j]==1)
			for(i=0;i<ASSIGNROWS;i++)
				if((assignedtableau[i][j]==1) &&
					(linesrow[i]!=1))
				{
					linesrow[i]=1;
  40505d:	66 44 89 20          	mov    %r12w,(%rax)
  405061:	eb d5                	jmp    405038 <Assignment+0x418>
** for that row.
*/
for(i=0;i<ASSIGNROWS;i++)
{
	currentmin=MAXPOSLONG;  /* Initialize minimum */
	for(j=0;j<ASSIGNCOLS;j++)
  405063:	31 c0                	xor    %eax,%eax
  405065:	bb 65 00 00 00       	mov    $0x65,%ebx
  40506a:	e9 20 fc ff ff       	jmpq   404c8f <Assignment+0x6f>
  40506f:	90                   	nop
	** Here, we'll take the trouble to see if the current
	** minimum is zero.  This is likely worth it, since the
	** preceding loop will have created at least one zero in
	** each row.  We can save ourselves a few iterations.
	*/
	if(currentmin!=0)
  405070:	48 89 f8             	mov    %rdi,%rax
		for(i=0;i<ASSIGNROWS;i++)
			tableau[i][j]-=currentmin;
  405073:	48 29 10             	sub    %rdx,(%rax)
  405076:	48 05 28 03 00 00    	add    $0x328,%rax
	** minimum is zero.  This is likely worth it, since the
	** preceding loop will have created at least one zero in
	** each row.  We can save ourselves a few iterations.
	*/
	if(currentmin!=0)
		for(i=0;i<ASSIGNROWS;i++)
  40507c:	48 39 f0             	cmp    %rsi,%rax
  40507f:	75 f2                	jne    405073 <Assignment+0x453>
  405081:	e9 8f fc ff ff       	jmpq   404d15 <Assignment+0xf5>
  405086:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40508d:	00 00 00 
					selected=i;
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[selected][j]=1;
  405090:	48 63 c7             	movslq %edi,%rax
  405093:	48 8d 94 24 b0 01 00 	lea    0x1b0(%rsp),%rdx
  40509a:	00 
				if(assignedtableau[i][j]==0)
				{       numzeros++;
					selected=i;
				}
		if(numzeros==1)
		{       numassigns++;
  40509b:	83 c5 01             	add    $0x1,%ebp
			totnumassigns++;
			assignedtableau[selected][j]=1;
  40509e:	4c 69 f8 ca 00 00 00 	imul   $0xca,%rax,%r15
				{       numzeros++;
					selected=i;
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
  4050a5:	41 83 c3 01          	add    $0x1,%r11d
			assignedtableau[selected][j]=1;
			for(k=0;k<ASSIGNCOLS;k++)
				if((k!=j) &&
				   (tableau[selected][k]==0))
  4050a9:	48 69 c0 28 03 00 00 	imul   $0x328,%rax,%rax
					selected=i;
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[selected][j]=1;
  4050b0:	49 01 d7             	add    %rdx,%r15
  4050b3:	49 63 d6             	movslq %r14d,%rdx
  4050b6:	66 41 c7 04 57 01 00 	movw   $0x1,(%r15,%rdx,2)
			for(k=0;k<ASSIGNCOLS;k++)
				if((k!=j) &&
				   (tableau[selected][k]==0))
  4050bd:	49 8d 14 01          	lea    (%r9,%rax,1),%rdx
  4050c1:	31 c0                	xor    %eax,%eax
  4050c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[selected][j]=1;
			for(k=0;k<ASSIGNCOLS;k++)
				if((k!=j) &&
  4050c8:	66 41 39 c5          	cmp    %ax,%r13w
  4050cc:	74 0e                	je     4050dc <Assignment+0x4bc>
  4050ce:	48 83 3c c2 00       	cmpq   $0x0,(%rdx,%rax,8)
  4050d3:	75 07                	jne    4050dc <Assignment+0x4bc>
				   (tableau[selected][k]==0))
					assignedtableau[selected][k]=2;
  4050d5:	66 41 c7 04 47 02 00 	movw   $0x2,(%r15,%rax,2)
  4050dc:	48 83 c0 01          	add    $0x1,%rax
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[selected][j]=1;
			for(k=0;k<ASSIGNCOLS;k++)
  4050e0:	48 83 f8 65          	cmp    $0x65,%rax
  4050e4:	75 e2                	jne    4050c8 <Assignment+0x4a8>
  4050e6:	e9 66 fd ff ff       	jmpq   404e51 <Assignment+0x231>
					selected=j;
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[i][selected]=1;
  4050eb:	48 63 c7             	movslq %edi,%rax
  4050ee:	b9 01 00 00 00       	mov    $0x1,%ecx
				if(assignedtableau[i][j]==0)
				{       numzeros++;
					selected=j;
				}
		if(numzeros==1)
		{       numassigns++;
  4050f3:	83 c5 01             	add    $0x1,%ebp
			totnumassigns++;
			assignedtableau[i][selected]=1;
  4050f6:	66 41 89 0c 44       	mov    %cx,(%r12,%rax,2)
  4050fb:	4d 8d 34 c1          	lea    (%r9,%rax,8),%r14
  4050ff:	4c 8d bc 44 b0 01 00 	lea    0x1b0(%rsp,%rax,2),%r15
  405106:	00 
				{       numzeros++;
					selected=j;
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
  405107:	41 83 c3 01          	add    $0x1,%r11d
			assignedtableau[i][selected]=1;
  40510b:	31 c0                	xor    %eax,%eax
			for(k=0;k<ASSIGNROWS;k++)
  40510d:	31 c9                	xor    %ecx,%ecx
  40510f:	90                   	nop
				if((k!=i) &&
  405110:	66 41 39 cd          	cmp    %cx,%r13w
  405114:	74 0e                	je     405124 <Assignment+0x504>
  405116:	49 83 3c 86 00       	cmpq   $0x0,(%r14,%rax,4)
  40511b:	75 07                	jne    405124 <Assignment+0x504>
				   (tableau[k][selected]==0))
					assignedtableau[k][selected]=2;
  40511d:	66 41 c7 04 07 02 00 	movw   $0x2,(%r15,%rax,1)
  405124:	48 05 ca 00 00 00    	add    $0xca,%rax
				}
		if(numzeros==1)
		{       numassigns++;
			totnumassigns++;
			assignedtableau[i][selected]=1;
			for(k=0;k<ASSIGNROWS;k++)
  40512a:	83 c1 01             	add    $0x1,%ecx
  40512d:	48 3d b2 4f 00 00    	cmp    $0x4fb2,%rax
  405133:	75 db                	jne    405110 <Assignment+0x4f0>
  405135:	e9 a6 fc ff ff       	jmpq   404de0 <Assignment+0x1c0>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40513a:	bf c0 dd 40 00       	mov    $0x40ddc0,%edi

#ifdef DEBUG
{
	int i,j;
	printf("\nColumn choices for each row\n");
	for(i=0;i<ASSIGNROWS;i++)
  40513f:	45 31 e4             	xor    %r12d,%r12d
  405142:	e8 49 bd ff ff       	callq  400e90 <puts@plt>
  405147:	44 89 e2             	mov    %r12d,%edx
  40514a:	be dd dd 40 00       	mov    $0x40dddd,%esi
  40514f:	bf 01 00 00 00       	mov    $0x1,%edi
  405154:	31 c0                	xor    %eax,%eax
  405156:	31 ed                	xor    %ebp,%ebp
  405158:	e8 b3 be ff ff       	callq  401010 <__printf_chk@plt>
  40515d:	eb 0a                	jmp    405169 <Assignment+0x549>
  40515f:	48 83 c5 01          	add    $0x1,%rbp
	{
	        printf("R%03d: ",i);
		for(j=0;j<ASSIGNCOLS;j++)
  405163:	48 83 fd 65          	cmp    $0x65,%rbp
  405167:	74 24                	je     40518d <Assignment+0x56d>
			if(assignedtableau[i][j]==1)
  405169:	66 83 3c 6b 01       	cmpw   $0x1,(%rbx,%rbp,2)
  40516e:	75 ef                	jne    40515f <Assignment+0x53f>
  405170:	89 ea                	mov    %ebp,%edx
  405172:	31 c0                	xor    %eax,%eax
  405174:	be e5 dd 40 00       	mov    $0x40dde5,%esi
  405179:	bf 01 00 00 00       	mov    $0x1,%edi
  40517e:	48 83 c5 01          	add    $0x1,%rbp
  405182:	e8 89 be ff ff       	callq  401010 <__printf_chk@plt>
	int i,j;
	printf("\nColumn choices for each row\n");
	for(i=0;i<ASSIGNROWS;i++)
	{
	        printf("R%03d: ",i);
		for(j=0;j<ASSIGNCOLS;j++)
  405187:	48 83 fd 65          	cmp    $0x65,%rbp
  40518b:	75 dc                	jne    405169 <Assignment+0x549>

#ifdef DEBUG
{
	int i,j;
	printf("\nColumn choices for each row\n");
	for(i=0;i<ASSIGNROWS;i++)
  40518d:	41 83 c4 01          	add    $0x1,%r12d
  405191:	48 81 c3 ca 00 00 00 	add    $0xca,%rbx
  405198:	41 83 fc 65          	cmp    $0x65,%r12d
  40519c:	75 a9                	jne    405147 <Assignment+0x527>
	}
}
#endif

return;
}
  40519e:	48 8b 84 24 68 51 00 	mov    0x5168(%rsp),%rax
  4051a5:	00 
  4051a6:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4051ad:	00 00 
  4051af:	0f 85 1c 01 00 00    	jne    4052d1 <Assignment+0x6b1>
  4051b5:	48 81 c4 78 51 00 00 	add    $0x5178,%rsp
  4051bc:	5b                   	pop    %rbx
  4051bd:	5d                   	pop    %rbp
  4051be:	41 5c                	pop    %r12
  4051c0:	41 5d                	pop    %r13
  4051c2:	41 5e                	pop    %r14
  4051c4:	41 5f                	pop    %r15
  4051c6:	c3                   	retq   
  4051c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4051ce:	00 00 
	for(j=0;j<ASSIGNCOLS;j++)
		if(assignedtableau[i][j]==1)
		{       numassigns++;
			break;
		}
	if(numassigns==0) linesrow[i]=1;
  4051d0:	41 bb 01 00 00 00    	mov    $0x1,%r11d
  4051d6:	48 83 c1 02          	add    $0x2,%rcx
  4051da:	48 89 d0             	mov    %rdx,%rax
  4051dd:	66 44 89 59 fe       	mov    %r11w,-0x2(%rcx)
	linescol[i]=0;

/*
** Scan rows, flag each row that has no assignment in it.
*/
for(i=0;i<ASSIGNROWS;i++)
  4051e2:	48 39 14 24          	cmp    %rdx,(%rsp)
  4051e6:	0f 85 97 fd ff ff    	jne    404f83 <Assignment+0x363>
  4051ec:	e9 bf fd ff ff       	jmpq   404fb0 <Assignment+0x390>
  4051f1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
					(linesrow[i]!=1))
				{
					linesrow[i]=1;
					newrows++;
				}
} while(newrows!=0);
  4051f8:	66 85 c9             	test   %cx,%cx
  4051fb:	0f 85 b4 fd ff ff    	jne    404fb5 <Assignment+0x395>
  405201:	48 89 6c 24 08       	mov    %rbp,0x8(%rsp)
  405206:	4d 89 cb             	mov    %r9,%r11
  405209:	4c 89 d3             	mov    %r10,%rbx
  40520c:	48 ba ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdx
  405213:	ff ff 7f 
** For all cells not covered by imaginary lines, determine smallest
** value.
*/
smallest=MAXPOSLONG;
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]!=0)
  405216:	66 83 3b 00          	cmpw   $0x0,(%rbx)
  40521a:	74 23                	je     40523f <Assignment+0x61f>
		for(j=0;j<ASSIGNCOLS;j++)
			if(linescol[j]!=1)
				if(tableau[i][j]<smallest)
  40521c:	31 c0                	xor    %eax,%eax
  40521e:	66 90                	xchg   %ax,%ax
*/
smallest=MAXPOSLONG;
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]!=0)
		for(j=0;j<ASSIGNCOLS;j++)
			if(linescol[j]!=1)
  405220:	66 41 83 3c 00 01    	cmpw   $0x1,(%r8,%rax,1)
  405226:	74 0b                	je     405233 <Assignment+0x613>
				if(tableau[i][j]<smallest)
  405228:	49 8b 0c 83          	mov    (%r11,%rax,4),%rcx
  40522c:	48 39 ca             	cmp    %rcx,%rdx
  40522f:	48 0f 4f d1          	cmovg  %rcx,%rdx
  405233:	48 83 c0 02          	add    $0x2,%rax
** value.
*/
smallest=MAXPOSLONG;
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]!=0)
		for(j=0;j<ASSIGNCOLS;j++)
  405237:	48 3d ca 00 00 00    	cmp    $0xca,%rax
  40523d:	75 e1                	jne    405220 <Assignment+0x600>
  40523f:	48 83 c3 02          	add    $0x2,%rbx
  405243:	49 81 c3 28 03 00 00 	add    $0x328,%r11
** linescol[n]==1 indicate cols covered by imaginary line
** For all cells not covered by imaginary lines, determine smallest
** value.
*/
smallest=MAXPOSLONG;
for(i=0;i<ASSIGNROWS;i++)
  40524a:	48 39 f3             	cmp    %rsi,%rbx
  40524d:	75 c7                	jne    405216 <Assignment+0x5f6>
  40524f:	4c 89 c9             	mov    %r9,%rcx
  405252:	4d 89 d3             	mov    %r10,%r11

/*
** Subtract smallest from all cells in the above set.
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]!=0)
  405255:	66 41 83 3b 00       	cmpw   $0x0,(%r11)
  40525a:	74 1c                	je     405278 <Assignment+0x658>
		for(j=0;j<ASSIGNCOLS;j++)
			if(linescol[j]!=1)
				tableau[i][j]-=smallest;
  40525c:	31 c0                	xor    %eax,%eax
  40525e:	66 90                	xchg   %ax,%ax
** Subtract smallest from all cells in the above set.
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]!=0)
		for(j=0;j<ASSIGNCOLS;j++)
			if(linescol[j]!=1)
  405260:	66 41 83 3c 00 01    	cmpw   $0x1,(%r8,%rax,1)
  405266:	74 04                	je     40526c <Assignment+0x64c>
				tableau[i][j]-=smallest;
  405268:	48 29 14 81          	sub    %rdx,(%rcx,%rax,4)
  40526c:	48 83 c0 02          	add    $0x2,%rax
/*
** Subtract smallest from all cells in the above set.
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]!=0)
		for(j=0;j<ASSIGNCOLS;j++)
  405270:	48 3d ca 00 00 00    	cmp    $0xca,%rax
  405276:	75 e8                	jne    405260 <Assignment+0x640>
  405278:	49 83 c3 02          	add    $0x2,%r11
  40527c:	48 81 c1 28 03 00 00 	add    $0x328,%rcx
					smallest=tableau[i][j];

/*
** Subtract smallest from all cells in the above set.
*/
for(i=0;i<ASSIGNROWS;i++)
  405283:	4c 39 db             	cmp    %r11,%rbx
  405286:	75 cd                	jne    405255 <Assignment+0x635>
  405288:	4c 89 c9             	mov    %r9,%rcx

/*
** Add smallest to all cells covered by two lines.
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]==0)
  40528b:	66 83 3f 00          	cmpw   $0x0,(%rdi)
  40528f:	75 2b                	jne    4052bc <Assignment+0x69c>
		for(j=0;j<ASSIGNCOLS;j++)
			if(linescol[j]==1)
				tableau[i][j]+=smallest;
  405291:	31 c0                	xor    %eax,%eax
  405293:	eb 0f                	jmp    4052a4 <Assignment+0x684>
  405295:	0f 1f 00             	nopl   (%rax)
  405298:	48 83 c0 02          	add    $0x2,%rax
/*
** Add smallest to all cells covered by two lines.
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]==0)
		for(j=0;j<ASSIGNCOLS;j++)
  40529c:	48 3d ca 00 00 00    	cmp    $0xca,%rax
  4052a2:	74 18                	je     4052bc <Assignment+0x69c>
			if(linescol[j]==1)
  4052a4:	66 41 83 3c 00 01    	cmpw   $0x1,(%r8,%rax,1)
  4052aa:	75 ec                	jne    405298 <Assignment+0x678>
				tableau[i][j]+=smallest;
  4052ac:	48 01 14 81          	add    %rdx,(%rcx,%rax,4)
  4052b0:	48 83 c0 02          	add    $0x2,%rax
/*
** Add smallest to all cells covered by two lines.
*/
for(i=0;i<ASSIGNROWS;i++)
	if(linesrow[i]==0)
		for(j=0;j<ASSIGNCOLS;j++)
  4052b4:	48 3d ca 00 00 00    	cmp    $0xca,%rax
  4052ba:	75 e8                	jne    4052a4 <Assignment+0x684>
  4052bc:	48 83 c7 02          	add    $0x2,%rdi
  4052c0:	48 81 c1 28 03 00 00 	add    $0x328,%rcx
				tableau[i][j]-=smallest;

/*
** Add smallest to all cells covered by two lines.
*/
for(i=0;i<ASSIGNROWS;i++)
  4052c7:	48 39 fb             	cmp    %rdi,%rbx
  4052ca:	75 bf                	jne    40528b <Assignment+0x66b>
  4052cc:	e9 7d fa ff ff       	jmpq   404d4e <Assignment+0x12e>
	}
}
#endif

return;
}
  4052d1:	e8 2a bc ff ff       	callq  400f00 <__stack_chk_fail@plt>
  4052d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4052dd:	00 00 00 

00000000004052e0 <DoBitfieldIteration>:
*/
static ulong DoBitfieldIteration(farulong *bitarraybase,
		farulong *bitoparraybase,
		long bitoparraysize,
		ulong *nbitops)
{
  4052e0:	41 57                	push   %r15
  4052e2:	41 56                	push   %r14
  4052e4:	49 89 ce             	mov    %rcx,%r14
  4052e7:	41 55                	push   %r13
  4052e9:	41 54                	push   %r12
  4052eb:	49 89 f5             	mov    %rsi,%r13
  4052ee:	55                   	push   %rbp
  4052ef:	53                   	push   %rbx
  4052f0:	48 89 fb             	mov    %rdi,%rbx
/*
** Reset random number generator so things repeat.
** Also reset the bit array we work on.
** added by Uwe F. Mayer
*/
randnum((int32)13);
  4052f3:	bf 0d 00 00 00       	mov    $0xd,%edi
*/
static ulong DoBitfieldIteration(farulong *bitarraybase,
		farulong *bitoparraybase,
		long bitoparraysize,
		ulong *nbitops)
{
  4052f8:	48 89 d5             	mov    %rdx,%rbp
  4052fb:	48 83 ec 08          	sub    $0x8,%rsp
ulong bitoffset;                /* Offset into bitmap */
ulong elapsed;                  /* Time to execute */
/*
** Clear # bitops counter
*/
*nbitops=0L;
  4052ff:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
/*
** Reset random number generator so things repeat.
** Also reset the bit array we work on.
** added by Uwe F. Mayer
*/
randnum((int32)13);
  405306:	e8 d5 f4 ff ff       	callq  4047e0 <randnum>
  40530b:	31 c0                	xor    %eax,%eax
for (i=0;i<global_bitopstruct.bitfieldarraysize;i++)
  40530d:	48 83 3d eb b4 20 00 	cmpq   $0x0,0x20b4eb(%rip)        # 610800 <global_bitopstruct+0x20>
  405314:	00 
  405315:	74 24                	je     40533b <DoBitfieldIteration+0x5b>
  405317:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40531e:	00 00 
{
#ifdef LONG64
	*(bitarraybase+i)=(ulong)0x5555555555555555;
  405320:	48 be 55 55 55 55 55 	movabs $0x5555555555555555,%rsi
  405327:	55 55 55 
  40532a:	48 89 34 c3          	mov    %rsi,(%rbx,%rax,8)
** Reset random number generator so things repeat.
** Also reset the bit array we work on.
** added by Uwe F. Mayer
*/
randnum((int32)13);
for (i=0;i<global_bitopstruct.bitfieldarraysize;i++)
  40532e:	48 83 c0 01          	add    $0x1,%rax
  405332:	48 39 05 c7 b4 20 00 	cmp    %rax,0x20b4c7(%rip)        # 610800 <global_bitopstruct+0x20>
  405339:	77 e5                	ja     405320 <DoBitfieldIteration+0x40>
	*(bitarraybase+i)=(ulong)0x5555555555555555;
#else
	*(bitarraybase+i)=(ulong)0x55555555;
#endif
}
randnum((int32)13);
  40533b:	bf 0d 00 00 00       	mov    $0xd,%edi
/* end of addition of code */

for (i=0;i<bitoparraysize;i++)
  405340:	45 31 ff             	xor    %r15d,%r15d
  405343:	4d 89 ec             	mov    %r13,%r12
	*(bitarraybase+i)=(ulong)0x5555555555555555;
#else
	*(bitarraybase+i)=(ulong)0x55555555;
#endif
}
randnum((int32)13);
  405346:	e8 95 f4 ff ff       	callq  4047e0 <randnum>
/* end of addition of code */

for (i=0;i<bitoparraysize;i++)
  40534b:	48 85 ed             	test   %rbp,%rbp
  40534e:	0f 8e 71 01 00 00    	jle    4054c5 <DoBitfieldIteration+0x1e5>
  405354:	0f 1f 40 00          	nopl   0x0(%rax)
{
	/* First item is offset */
        /* *(bitoparraybase+i+i)=bitoffset=abs_randwc(262140L); */
	*(bitoparraybase+i+i)=bitoffset=abs_randwc((int32)262140);
  405358:	bf fc ff 03 00       	mov    $0x3fffc,%edi
#endif
}
randnum((int32)13);
/* end of addition of code */

for (i=0;i<bitoparraysize;i++)
  40535d:	49 83 c7 01          	add    $0x1,%r15
  405361:	49 83 c4 10          	add    $0x10,%r12
{
	/* First item is offset */
        /* *(bitoparraybase+i+i)=bitoffset=abs_randwc(262140L); */
	*(bitoparraybase+i+i)=bitoffset=abs_randwc((int32)262140);
  405365:	e8 16 f4 ff ff       	callq  404780 <abs_randwc>

	/* Next item is run length */
	/* *nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc(262140L-bitoffset);*/
	*nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc((int32)262140-bitoffset);
  40536a:	bf fc ff 03 00       	mov    $0x3fffc,%edi

for (i=0;i<bitoparraysize;i++)
{
	/* First item is offset */
        /* *(bitoparraybase+i+i)=bitoffset=abs_randwc(262140L); */
	*(bitoparraybase+i+i)=bitoffset=abs_randwc((int32)262140);
  40536f:	89 c6                	mov    %eax,%esi
  405371:	49 89 74 24 f0       	mov    %rsi,-0x10(%r12)

	/* Next item is run length */
	/* *nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc(262140L-bitoffset);*/
	*nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc((int32)262140-bitoffset);
  405376:	29 c7                	sub    %eax,%edi
  405378:	e8 03 f4 ff ff       	callq  404780 <abs_randwc>
  40537d:	89 c0                	mov    %eax,%eax
  40537f:	49 89 44 24 f8       	mov    %rax,-0x8(%r12)
  405384:	49 01 06             	add    %rax,(%r14)
#endif
}
randnum((int32)13);
/* end of addition of code */

for (i=0;i<bitoparraysize;i++)
  405387:	4c 39 fd             	cmp    %r15,%rbp
  40538a:	75 cc                	jne    405358 <DoBitfieldIteration+0x78>
/*
** Array of offset and lengths built...do an iteration of
** the test.
** Start the stopwatch.
*/
elapsed=StartStopwatch();
  40538c:	31 c0                	xor    %eax,%eax
  40538e:	e8 1d 6e 00 00       	callq  40c1b0 <StartStopwatch>
  405393:	49 8d 75 08          	lea    0x8(%r13),%rsi
  405397:	48 89 c7             	mov    %rax,%rdi
  40539a:	45 31 c9             	xor    %r9d,%r9d
** Loop through array off offset/run length pairs.
** Execute operation based on modulus of index.
*/
for(i=0;i<bitoparraysize;i++)
{
	switch(i % 3)
  40539d:	49 ba 56 55 55 55 55 	movabs $0x5555555555555556,%r10
  4053a4:	55 55 55 
	bitnumb=bit_addr % 32;  /* bit number in word */
#endif
	if(val)
		bitmap[bindex]|=(1L<<bitnumb);
	else
		bitmap[bindex]&=~(1L<<bitnumb);
  4053a7:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  4053ad:	eb 21                	jmp    4053d0 <DoBitfieldIteration+0xf0>
  4053af:	90                   	nop
** Loop through array off offset/run length pairs.
** Execute operation based on modulus of index.
*/
for(i=0;i<bitoparraysize;i++)
{
	switch(i % 3)
  4053b0:	48 83 fa 02          	cmp    $0x2,%rdx
  4053b4:	0f 84 ce 00 00 00    	je     405488 <DoBitfieldIteration+0x1a8>
  4053ba:	48 85 d2             	test   %rdx,%rdx
  4053bd:	0f 84 85 00 00 00    	je     405448 <DoBitfieldIteration+0x168>

/*
** Loop through array off offset/run length pairs.
** Execute operation based on modulus of index.
*/
for(i=0;i<bitoparraysize;i++)
  4053c3:	49 83 c1 01          	add    $0x1,%r9
  4053c7:	48 83 c6 10          	add    $0x10,%rsi
  4053cb:	4c 39 cd             	cmp    %r9,%rbp
  4053ce:	74 60                	je     405430 <DoBitfieldIteration+0x150>
{
	switch(i % 3)
  4053d0:	4c 89 c8             	mov    %r9,%rax
  4053d3:	49 f7 ea             	imul   %r10
  4053d6:	4c 89 c8             	mov    %r9,%rax
  4053d9:	48 c1 f8 3f          	sar    $0x3f,%rax
  4053dd:	48 29 c2             	sub    %rax,%rdx
  4053e0:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax
  4053e4:	4c 89 ca             	mov    %r9,%rdx
  4053e7:	48 29 c2             	sub    %rax,%rdx
  4053ea:	48 83 fa 01          	cmp    $0x1,%rdx
  4053ee:	75 c0                	jne    4053b0 <DoBitfieldIteration+0xd0>
				*(bitoparraybase+i+i+1),
				1);
			break;

		case 1: /* Clear run of bits */
			ToggleBitRun(bitarraybase,
  4053f0:	4c 8b 26             	mov    (%rsi),%r12
  4053f3:	48 8b 46 f8          	mov    -0x8(%rsi),%rax
		uint val)               /* 1 or 0 */
{
unsigned long bindex;   /* Index into array */
unsigned long bitnumb;  /* Bit number */

while(nbits--)
  4053f7:	4d 85 e4             	test   %r12,%r12
  4053fa:	74 c7                	je     4053c3 <DoBitfieldIteration+0xe3>
  4053fc:	49 01 c4             	add    %rax,%r12
  4053ff:	90                   	nop
	bitnumb=bit_addr % 32;  /* bit number in word */
#endif
	if(val)
		bitmap[bindex]|=(1L<<bitnumb);
	else
		bitmap[bindex]&=~(1L<<bitnumb);
  405400:	48 89 c1             	mov    %rax,%rcx
  405403:	49 89 c3             	mov    %rax,%r11
  405406:	4c 89 c2             	mov    %r8,%rdx
  405409:	83 e1 3f             	and    $0x3f,%ecx
  40540c:	49 c1 eb 06          	shr    $0x6,%r11
	bit_addr++;
  405410:	48 83 c0 01          	add    $0x1,%rax
	bitnumb=bit_addr % 32;  /* bit number in word */
#endif
	if(val)
		bitmap[bindex]|=(1L<<bitnumb);
	else
		bitmap[bindex]&=~(1L<<bitnumb);
  405414:	48 d3 e2             	shl    %cl,%rdx
  405417:	48 f7 d2             	not    %rdx
  40541a:	4a 21 14 db          	and    %rdx,(%rbx,%r11,8)
		uint val)               /* 1 or 0 */
{
unsigned long bindex;   /* Index into array */
unsigned long bitnumb;  /* Bit number */

while(nbits--)
  40541e:	4c 39 e0             	cmp    %r12,%rax
  405421:	75 dd                	jne    405400 <DoBitfieldIteration+0x120>

/*
** Loop through array off offset/run length pairs.
** Execute operation based on modulus of index.
*/
for(i=0;i<bitoparraysize;i++)
  405423:	49 83 c1 01          	add    $0x1,%r9
  405427:	48 83 c6 10          	add    $0x10,%rsi
  40542b:	4c 39 cd             	cmp    %r9,%rbp
  40542e:	75 a0                	jne    4053d0 <DoBitfieldIteration+0xf0>

/*
** Return elapsed time
*/
return(StopStopwatch(elapsed));
}
  405430:	48 83 c4 08          	add    $0x8,%rsp
  405434:	5b                   	pop    %rbx
  405435:	5d                   	pop    %rbp
  405436:	41 5c                	pop    %r12
  405438:	41 5d                	pop    %r13
  40543a:	41 5e                	pop    %r14
  40543c:	41 5f                	pop    %r15
}

/*
** Return elapsed time
*/
return(StopStopwatch(elapsed));
  40543e:	e9 7d 6d 00 00       	jmpq   40c1c0 <StopStopwatch>
  405443:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
	switch(i % 3)
	{

		case 0: /* Set run of bits */
			ToggleBitRun(bitarraybase,
  405448:	48 8b 16             	mov    (%rsi),%rdx
  40544b:	48 8b 46 f8          	mov    -0x8(%rsi),%rax
		uint val)               /* 1 or 0 */
{
unsigned long bindex;   /* Index into array */
unsigned long bitnumb;  /* Bit number */

while(nbits--)
  40544f:	48 85 d2             	test   %rdx,%rdx
  405452:	4c 8d 1c 02          	lea    (%rdx,%rax,1),%r11
  405456:	0f 84 67 ff ff ff    	je     4053c3 <DoBitfieldIteration+0xe3>
  40545c:	0f 1f 40 00          	nopl   0x0(%rax)
#else
	bindex=bit_addr>>5;     /* Index is number /32 */
	bitnumb=bit_addr % 32;  /* bit number in word */
#endif
	if(val)
		bitmap[bindex]|=(1L<<bitnumb);
  405460:	48 89 c2             	mov    %rax,%rdx
  405463:	48 89 c1             	mov    %rax,%rcx
  405466:	4d 89 c6             	mov    %r8,%r14
  405469:	48 c1 ea 06          	shr    $0x6,%rdx
  40546d:	83 e1 3f             	and    $0x3f,%ecx
	else
		bitmap[bindex]&=~(1L<<bitnumb);
	bit_addr++;
  405470:	48 83 c0 01          	add    $0x1,%rax
#else
	bindex=bit_addr>>5;     /* Index is number /32 */
	bitnumb=bit_addr % 32;  /* bit number in word */
#endif
	if(val)
		bitmap[bindex]|=(1L<<bitnumb);
  405474:	49 d3 e6             	shl    %cl,%r14
  405477:	4c 09 34 d3          	or     %r14,(%rbx,%rdx,8)
		uint val)               /* 1 or 0 */
{
unsigned long bindex;   /* Index into array */
unsigned long bitnumb;  /* Bit number */

while(nbits--)
  40547b:	4c 39 d8             	cmp    %r11,%rax
  40547e:	75 e0                	jne    405460 <DoBitfieldIteration+0x180>
  405480:	e9 3e ff ff ff       	jmpq   4053c3 <DoBitfieldIteration+0xe3>
  405485:	0f 1f 00             	nopl   (%rax)
				*(bitoparraybase+i+i+1),
				0);
			break;

		case 2: /* Complement run of bits */
			FlipBitRun(bitarraybase,
  405488:	4c 8b 1e             	mov    (%rsi),%r11
  40548b:	48 8b 46 f8          	mov    -0x8(%rsi),%rax
		ulong nbits)                    /* # of bits to flip */
{
unsigned long bindex;   /* Index into array */
unsigned long bitnumb;  /* Bit number */

while(nbits--)
  40548f:	4d 85 db             	test   %r11,%r11
  405492:	0f 84 2b ff ff ff    	je     4053c3 <DoBitfieldIteration+0xe3>
  405498:	49 01 c3             	add    %rax,%r11
  40549b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	bitnumb=bit_addr % 64;  /* Bit number in longword */
#else
	bindex=bit_addr>>5;     /* Index is number /32 */
	bitnumb=bit_addr % 32;  /* Bit number in longword */
#endif
	bitmap[bindex]^=(1L<<bitnumb);
  4054a0:	48 89 c2             	mov    %rax,%rdx
  4054a3:	48 89 c1             	mov    %rax,%rcx
  4054a6:	4d 89 c7             	mov    %r8,%r15
  4054a9:	48 c1 ea 06          	shr    $0x6,%rdx
  4054ad:	83 e1 3f             	and    $0x3f,%ecx
	bit_addr++;
  4054b0:	48 83 c0 01          	add    $0x1,%rax
	bitnumb=bit_addr % 64;  /* Bit number in longword */
#else
	bindex=bit_addr>>5;     /* Index is number /32 */
	bitnumb=bit_addr % 32;  /* Bit number in longword */
#endif
	bitmap[bindex]^=(1L<<bitnumb);
  4054b4:	49 d3 e7             	shl    %cl,%r15
  4054b7:	4c 31 3c d3          	xor    %r15,(%rbx,%rdx,8)
		ulong nbits)                    /* # of bits to flip */
{
unsigned long bindex;   /* Index into array */
unsigned long bitnumb;  /* Bit number */

while(nbits--)
  4054bb:	4c 39 d8             	cmp    %r11,%rax
  4054be:	75 e0                	jne    4054a0 <DoBitfieldIteration+0x1c0>
  4054c0:	e9 fe fe ff ff       	jmpq   4053c3 <DoBitfieldIteration+0xe3>
/*
** Array of offset and lengths built...do an iteration of
** the test.
** Start the stopwatch.
*/
elapsed=StartStopwatch();
  4054c5:	31 c0                	xor    %eax,%eax
  4054c7:	e8 e4 6c 00 00       	callq  40c1b0 <StartStopwatch>
  4054cc:	48 89 c7             	mov    %rax,%rdi
  4054cf:	e9 5c ff ff ff       	jmpq   405430 <DoBitfieldIteration+0x150>
  4054d4:	66 90                	xchg   %ax,%ax
  4054d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4054dd:	00 00 00 

00000000004054e0 <stradjust>:
static void stradjust(farulong *optrarray,      /* Offset pointer array */
	faruchar *strarray,                     /* String array */
	ulong nstrings,                         /* # of strings */
	ulong i,                                /* Offset to adjust */
	uchar l)                                /* New length */
{
  4054e0:	41 57                	push   %r15
  4054e2:	41 56                	push   %r14
  4054e4:	41 55                	push   %r13
  4054e6:	41 54                	push   %r12
/*
** See if the adjustment is being made to the last
** string in the string array.  If so, we don't have to
** do anything more than adjust the length field.
*/
if(i==(nstrings-1L))
  4054e8:	4c 8d 62 ff          	lea    -0x1(%rdx),%r12
static void stradjust(farulong *optrarray,      /* Offset pointer array */
	faruchar *strarray,                     /* String array */
	ulong nstrings,                         /* # of strings */
	ulong i,                                /* Offset to adjust */
	uchar l)                                /* New length */
{
  4054ec:	55                   	push   %rbp
  4054ed:	53                   	push   %rbx
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  4054ee:	48 8d 1c cd 00 00 00 	lea    0x0(,%rcx,8),%rbx
  4054f5:	00 
  4054f6:	4c 8d 0c 1f          	lea    (%rdi,%rbx,1),%r9
static void stradjust(farulong *optrarray,      /* Offset pointer array */
	faruchar *strarray,                     /* String array */
	ulong nstrings,                         /* # of strings */
	ulong i,                                /* Offset to adjust */
	uchar l)                                /* New length */
{
  4054fa:	48 83 ec 28          	sub    $0x28,%rsp
/*
** See if the adjustment is being made to the last
** string in the string array.  If so, we don't have to
** do anything more than adjust the length field.
*/
if(i==(nstrings-1L))
  4054fe:	4c 39 e1             	cmp    %r12,%rcx
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  405501:	4d 8b 19             	mov    (%r9),%r11
  405504:	4e 8d 14 1e          	lea    (%rsi,%r11,1),%r10
/*
** See if the adjustment is being made to the last
** string in the string array.  If so, we don't have to
** do anything more than adjust the length field.
*/
if(i==(nstrings-1L))
  405508:	0f 84 62 01 00 00    	je     405670 <stradjust+0x190>
  40550e:	49 89 d6             	mov    %rdx,%r14
** Calculate the total # of bytes in string array from
** location i+1 to end of array.  Whether we're moving "up" or
** down, this is how many bytes we'll have to move.
*/
nbytes=*(optrarray+nstrings-1L) +
	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
  405511:	48 8b 54 d7 f8       	mov    -0x8(%rdi,%rdx,8),%rdx
  405516:	49 89 cd             	mov    %rcx,%r13
  405519:	48 89 f1             	mov    %rsi,%rcx
	*(optrarray+i+1L);
  40551c:	48 8d 5c 1f 08       	lea    0x8(%rdi,%rbx,1),%rbx
  405521:	48 89 fd             	mov    %rdi,%rbp
  405524:	41 0f b6 c0          	movzbl %r8b,%eax
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  405528:	45 0f b6 3a          	movzbl (%r10),%r15d
** location i+1 to end of array.  Whether we're moving "up" or
** down, this is how many bytes we'll have to move.
*/
nbytes=*(optrarray+nstrings-1L) +
	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
	*(optrarray+i+1L);
  40552c:	4d 8d 55 01          	lea    0x1(%r13),%r10
** string position i+1.  Destination is string position i+l
** (i+"ell"...don't confuse 1 and l).
** Hand this straight to memmove and let it handle the
** "overlap" problem.
*/
MoveMemory((farvoid *)(strarray+*(optrarray+i)+l+1),
  405530:	0f b6 3c 11          	movzbl (%rcx,%rdx,1),%edi
** location i+1 to end of array.  Whether we're moving "up" or
** down, this is how many bytes we'll have to move.
*/
nbytes=*(optrarray+nstrings-1L) +
	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
	*(optrarray+i+1L);
  405534:	48 8b 33             	mov    (%rbx),%rsi
  405537:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
  40553c:	44 89 44 24 14       	mov    %r8d,0x14(%rsp)
  405541:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
** string position i+1.  Destination is string position i+l
** (i+"ell"...don't confuse 1 and l).
** Hand this straight to memmove and let it handle the
** "overlap" problem.
*/
MoveMemory((farvoid *)(strarray+*(optrarray+i)+l+1),
  405546:	48 89 0c 24          	mov    %rcx,(%rsp)
  40554a:	48 8d 54 3a 01       	lea    0x1(%rdx,%rdi,1),%rdx
  40554f:	49 8d 7c 03 01       	lea    0x1(%r11,%rax,1),%rdi
  405554:	48 29 f2             	sub    %rsi,%rdx
  405557:	48 01 cf             	add    %rcx,%rdi
  40555a:	48 01 ce             	add    %rcx,%rsi
  40555d:	e8 8e 69 00 00       	callq  40bef0 <MoveMemory>

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  405562:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
  405567:	48 8b 0c 24          	mov    (%rsp),%rcx
  40556b:	44 8b 44 24 14       	mov    0x14(%rsp),%r8d
  405570:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
  405575:	4d 39 d6             	cmp    %r10,%r14
  405578:	0f 86 d3 00 00 00    	jbe    405651 <stradjust+0x171>
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  40557e:	41 0f b6 d0          	movzbl %r8b,%edx
  405582:	48 c1 e3 3c          	shl    $0x3c,%rbx
  405586:	4d 29 ec             	sub    %r13,%r12
  405589:	44 29 fa             	sub    %r15d,%edx
  40558c:	48 c1 eb 3f          	shr    $0x3f,%rbx
  405590:	89 d0                	mov    %edx,%eax
  405592:	c1 f8 1f             	sar    $0x1f,%eax
  405595:	89 c6                	mov    %eax,%esi
  405597:	31 d6                	xor    %edx,%esi
  405599:	29 c6                	sub    %eax,%esi
  40559b:	85 d2                	test   %edx,%edx
  40559d:	48 63 f6             	movslq %esi,%rsi
  4055a0:	0f 88 e2 00 00 00    	js     405688 <stradjust+0x1a8>
  4055a6:	4c 39 e3             	cmp    %r12,%rbx
  4055a9:	48 89 d8             	mov    %rbx,%rax
  4055ac:	49 0f 47 c4          	cmova  %r12,%rax
adjamount=(unsigned char)abs(direction);
  4055b0:	49 83 fc 03          	cmp    $0x3,%r12
  4055b4:	49 0f 46 c4          	cmovbe %r12,%rax
  4055b8:	48 85 c0             	test   %rax,%rax
  4055bb:	0f 84 7f 01 00 00    	je     405740 <stradjust+0x260>
*/
for(j=i+1;j<nstrings;j++)
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  4055c1:	4a 01 74 d5 00       	add    %rsi,0x0(%rbp,%r10,8)
  4055c6:	48 83 f8 01          	cmp    $0x1,%rax

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4055ca:	49 8d 7d 02          	lea    0x2(%r13),%rdi
  4055ce:	74 18                	je     4055e8 <stradjust+0x108>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  4055d0:	48 01 74 fd 00       	add    %rsi,0x0(%rbp,%rdi,8)
  4055d5:	48 83 f8 03          	cmp    $0x3,%rax

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4055d9:	49 8d 7d 03          	lea    0x3(%r13),%rdi
  4055dd:	75 09                	jne    4055e8 <stradjust+0x108>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  4055df:	48 01 74 fd 00       	add    %rsi,0x0(%rbp,%rdi,8)

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4055e4:	49 8d 7d 04          	lea    0x4(%r13),%rdi
  4055e8:	49 39 c4             	cmp    %rax,%r12
  4055eb:	74 64                	je     405651 <stradjust+0x171>
  4055ed:	49 29 c4             	sub    %rax,%r12
  4055f0:	4d 29 ee             	sub    %r13,%r14
  4055f3:	4d 8d 5c 24 fe       	lea    -0x2(%r12),%r11
  4055f8:	49 29 c6             	sub    %rax,%r14
  4055fb:	49 d1 eb             	shr    %r11
  4055fe:	49 83 c3 01          	add    $0x1,%r11
  405602:	49 83 fe 02          	cmp    $0x2,%r14
  405606:	4b 8d 1c 1b          	lea    (%r11,%r11,1),%rbx
  40560a:	74 40                	je     40564c <stradjust+0x16c>
  40560c:	48 89 34 24          	mov    %rsi,(%rsp)
  405610:	4c 01 d0             	add    %r10,%rax
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
adjamount=(unsigned char)abs(direction);
  405613:	31 d2                	xor    %edx,%edx
  405615:	f3 0f 7e 0c 24       	movq   (%rsp),%xmm1
  40561a:	4c 8d 54 c5 00       	lea    0x0(%rbp,%rax,8),%r10
  40561f:	66 0f 6c c9          	punpcklqdq %xmm1,%xmm1
  405623:	31 c0                	xor    %eax,%eax
  405625:	0f 1f 00             	nopl   (%rax)
*/
for(j=i+1;j<nstrings;j++)
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  405628:	66 41 0f 6f 04 02    	movdqa (%r10,%rax,1),%xmm0
  40562e:	48 83 c2 01          	add    $0x1,%rdx
  405632:	66 0f d4 c1          	paddq  %xmm1,%xmm0
  405636:	41 0f 29 04 02       	movaps %xmm0,(%r10,%rax,1)
  40563b:	48 83 c0 10          	add    $0x10,%rax
  40563f:	49 39 d3             	cmp    %rdx,%r11
  405642:	77 e4                	ja     405628 <stradjust+0x148>
  405644:	48 01 df             	add    %rbx,%rdi
  405647:	49 39 dc             	cmp    %rbx,%r12
  40564a:	74 05                	je     405651 <stradjust+0x171>
  40564c:	48 01 74 fd 00       	add    %rsi,0x0(%rbp,%rdi,8)

/*
** Store the new length and go home.
*/
*(strarray+*(optrarray+i))=l;
  405651:	49 8b 01             	mov    (%r9),%rax
  405654:	44 88 04 01          	mov    %r8b,(%rcx,%rax,1)
return;
}
  405658:	48 83 c4 28          	add    $0x28,%rsp
  40565c:	5b                   	pop    %rbx
  40565d:	5d                   	pop    %rbp
  40565e:	41 5c                	pop    %r12
  405660:	41 5d                	pop    %r13
  405662:	41 5e                	pop    %r14
  405664:	41 5f                	pop    %r15
  405666:	c3                   	retq   
  405667:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40566e:	00 00 
** See if the adjustment is being made to the last
** string in the string array.  If so, we don't have to
** do anything more than adjust the length field.
*/
if(i==(nstrings-1L))
{       *(strarray+*(optrarray+i))=l;
  405670:	45 88 02             	mov    %r8b,(%r10)
/*
** Store the new length and go home.
*/
*(strarray+*(optrarray+i))=l;
return;
}
  405673:	48 83 c4 28          	add    $0x28,%rsp
  405677:	5b                   	pop    %rbx
  405678:	5d                   	pop    %rbp
  405679:	41 5c                	pop    %r12
  40567b:	41 5d                	pop    %r13
  40567d:	41 5e                	pop    %r14
  40567f:	41 5f                	pop    %r15
  405681:	c3                   	retq   
  405682:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  405688:	4c 39 e3             	cmp    %r12,%rbx
  40568b:	49 0f 47 dc          	cmova  %r12,%rbx
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
adjamount=(unsigned char)abs(direction);
  40568f:	49 83 fc 03          	cmp    $0x3,%r12
  405693:	49 0f 46 dc          	cmovbe %r12,%rbx
  405697:	48 85 db             	test   %rbx,%rbx
  40569a:	0f 84 b0 00 00 00    	je     405750 <stradjust+0x270>
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  4056a0:	4a 29 74 d5 00       	sub    %rsi,0x0(%rbp,%r10,8)
  4056a5:	48 83 fb 01          	cmp    $0x1,%rbx

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4056a9:	49 8d 45 02          	lea    0x2(%r13),%rax
  4056ad:	74 18                	je     4056c7 <stradjust+0x1e7>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  4056af:	48 29 74 c5 00       	sub    %rsi,0x0(%rbp,%rax,8)
  4056b4:	48 83 fb 03          	cmp    $0x3,%rbx

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4056b8:	49 8d 45 03          	lea    0x3(%r13),%rax
  4056bc:	75 09                	jne    4056c7 <stradjust+0x1e7>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  4056be:	48 29 74 c5 00       	sub    %rsi,0x0(%rbp,%rax,8)

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4056c3:	49 8d 45 04          	lea    0x4(%r13),%rax
  4056c7:	49 39 dc             	cmp    %rbx,%r12
  4056ca:	74 85                	je     405651 <stradjust+0x171>
  4056cc:	49 29 dc             	sub    %rbx,%r12
  4056cf:	4d 29 ee             	sub    %r13,%r14
  4056d2:	49 8d 54 24 fe       	lea    -0x2(%r12),%rdx
  4056d7:	49 29 de             	sub    %rbx,%r14
  4056da:	48 d1 ea             	shr    %rdx
  4056dd:	48 83 c2 01          	add    $0x1,%rdx
  4056e1:	49 83 fe 02          	cmp    $0x2,%r14
  4056e5:	48 8d 3c 12          	lea    (%rdx,%rdx,1),%rdi
  4056e9:	74 43                	je     40572e <stradjust+0x24e>
  4056eb:	48 89 34 24          	mov    %rsi,(%rsp)
  4056ef:	4c 01 d3             	add    %r10,%rbx
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
adjamount=(unsigned char)abs(direction);
  4056f2:	45 31 db             	xor    %r11d,%r11d
  4056f5:	f3 0f 7e 0c 24       	movq   (%rsp),%xmm1
  4056fa:	48 8d 5c dd 00       	lea    0x0(%rbp,%rbx,8),%rbx
  4056ff:	66 0f 6c c9          	punpcklqdq %xmm1,%xmm1
  405703:	45 31 d2             	xor    %r10d,%r10d
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  405706:	66 42 0f 6f 04 13    	movdqa (%rbx,%r10,1),%xmm0
  40570c:	49 83 c3 01          	add    $0x1,%r11
  405710:	66 0f fb c1          	psubq  %xmm1,%xmm0
  405714:	42 0f 29 04 13       	movaps %xmm0,(%rbx,%r10,1)
  405719:	49 83 c2 10          	add    $0x10,%r10
  40571d:	49 39 d3             	cmp    %rdx,%r11
  405720:	72 e4                	jb     405706 <stradjust+0x226>
  405722:	48 01 f8             	add    %rdi,%rax
  405725:	49 39 fc             	cmp    %rdi,%r12
  405728:	0f 84 23 ff ff ff    	je     405651 <stradjust+0x171>
  40572e:	48 29 74 c5 00       	sub    %rsi,0x0(%rbp,%rax,8)
  405733:	e9 19 ff ff ff       	jmpq   405651 <stradjust+0x171>
  405738:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40573f:	00 
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
adjamount=(unsigned char)abs(direction);
  405740:	4c 89 d7             	mov    %r10,%rdi
  405743:	e9 a5 fe ff ff       	jmpq   4055ed <stradjust+0x10d>
  405748:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40574f:	00 
  405750:	4c 89 d0             	mov    %r10,%rax
  405753:	e9 74 ff ff ff       	jmpq   4056cc <stradjust+0x1ec>
  405758:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40575f:	00 

0000000000405760 <DoHuffIteration>:
	farchar *comparray,
	farchar *decomparray,
	ulong arraysize,
	ulong nloops,
	huff_node *hufftree)
{
  405760:	41 57                	push   %r15
  405762:	41 56                	push   %r14
  405764:	4d 89 c6             	mov    %r8,%r14
  405767:	41 55                	push   %r13
  405769:	41 54                	push   %r12
  40576b:	4d 89 cd             	mov    %r9,%r13
  40576e:	55                   	push   %rbp
  40576f:	53                   	push   %rbx
  405770:	49 89 fc             	mov    %rdi,%r12
  405773:	48 89 f3             	mov    %rsi,%rbx
  405776:	48 89 cd             	mov    %rcx,%rbp
  405779:	48 83 ec 68          	sub    $0x68,%rsp
  40577d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  405784:	00 00 
  405786:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  40578b:	31 c0                	xor    %eax,%eax
  40578d:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
#endif

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  405792:	e8 19 6a 00 00       	callq  40c1b0 <StartStopwatch>

/*
** Do everything for nloops
*/
while(nloops--)
  405797:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
  40579c:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
#endif

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  4057a2:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
long bitstringlen;              /* Length of bitstring */
int c;                          /* Character from plaintext */
char bitstring[30];             /* Holds bitstring */
ulong elapsed;                  /* For stopwatch */
#ifdef DEBUG
int status=0;
  4057a7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
  4057ae:	00 
  4057af:	f3 0f 10 1d d1 8a 00 	movss  0x8ad1(%rip),%xmm3        # 40e288 <jtable.3055+0x14f8>
  4057b6:	00 
elapsed=StartStopwatch();

/*
** Do everything for nloops
*/
while(nloops--)
  4057b7:	0f 84 93 03 00 00    	je     405b50 <DoHuffIteration+0x3f0>
  4057bd:	49 8d 55 04          	lea    0x4(%r13),%rdx
  4057c1:	31 c0                	xor    %eax,%eax
  4057c3:	48 89 d1             	mov    %rdx,%rcx
  4057c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4057cd:	00 00 00 
** nodes greater than node #255.
*/
for(i=0;i<256;i++)
{
	hufftree[i].freq=(float)0.0;
	hufftree[i].c=(unsigned char)i;
  4057d0:	88 41 fc             	mov    %al,-0x4(%rcx)
** Calculate the frequency of each byte value. Store the
** results in what will become the "leaves" of the
** Huffman tree.  Interior nodes will be built in those
** nodes greater than node #255.
*/
for(i=0;i<256;i++)
  4057d3:	83 c0 01             	add    $0x1,%eax
{
	hufftree[i].freq=(float)0.0;
  4057d6:	c7 01 00 00 00 00    	movl   $0x0,(%rcx)
  4057dc:	48 83 c1 14          	add    $0x14,%rcx
** Calculate the frequency of each byte value. Store the
** results in what will become the "leaves" of the
** Huffman tree.  Interior nodes will be built in those
** nodes greater than node #255.
*/
for(i=0;i<256;i++)
  4057e0:	3d 00 01 00 00       	cmp    $0x100,%eax
  4057e5:	75 e9                	jne    4057d0 <DoHuffIteration+0x70>
{
	hufftree[i].freq=(float)0.0;
	hufftree[i].c=(unsigned char)i;
}

for(j=0;j<arraysize;j++)
  4057e7:	48 85 ed             	test   %rbp,%rbp
  4057ea:	4c 89 e0             	mov    %r12,%rax
  4057ed:	49 8d 34 2c          	lea    (%r12,%rbp,1),%rsi
  4057f1:	f3 0f 10 0d 93 8a 00 	movss  0x8a93(%rip),%xmm1        # 40e28c <jtable.3055+0x14fc>
  4057f8:	00 
  4057f9:	74 29                	je     405824 <DoHuffIteration+0xc4>
  4057fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	hufftree[(int)plaintext[j]].freq+=(float)1.0;
  405800:	48 0f be 08          	movsbq (%rax),%rcx
  405804:	48 83 c0 01          	add    $0x1,%rax
{
	hufftree[i].freq=(float)0.0;
	hufftree[i].c=(unsigned char)i;
}

for(j=0;j<arraysize;j++)
  405808:	48 39 f0             	cmp    %rsi,%rax
	hufftree[(int)plaintext[j]].freq+=(float)1.0;
  40580b:	48 8d 0c 89          	lea    (%rcx,%rcx,4),%rcx
  40580f:	49 8d 4c 8d 00       	lea    0x0(%r13,%rcx,4),%rcx
  405814:	f3 0f 10 41 04       	movss  0x4(%rcx),%xmm0
  405819:	f3 0f 58 c1          	addss  %xmm1,%xmm0
  40581d:	f3 0f 11 41 04       	movss  %xmm0,0x4(%rcx)
{
	hufftree[i].freq=(float)0.0;
	hufftree[i].c=(unsigned char)i;
}

for(j=0;j<arraysize;j++)
  405822:	75 dc                	jne    405800 <DoHuffIteration+0xa0>
  405824:	66 0f ef c9          	pxor   %xmm1,%xmm1
  405828:	49 8d b5 04 14 00 00 	lea    0x1404(%r13),%rsi
elapsed=StartStopwatch();

/*
** Do everything for nloops
*/
while(nloops--)
  40582f:	48 89 d0             	mov    %rdx,%rax
  405832:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

for(j=0;j<arraysize;j++)
	hufftree[(int)plaintext[j]].freq+=(float)1.0;

for(i=0;i<256;i++)
	if(hufftree[i].freq != (float)0.0)
  405838:	f3 0f 10 00          	movss  (%rax),%xmm0
  40583c:	0f 2e c1             	ucomiss %xmm1,%xmm0
  40583f:	7a 02                	jp     405843 <DoHuffIteration+0xe3>
  405841:	74 11                	je     405854 <DoHuffIteration+0xf4>
		hufftree[i].freq/=(float)arraysize;
  405843:	66 0f ef d2          	pxor   %xmm2,%xmm2
  405847:	f3 48 0f 2a d5       	cvtsi2ss %rbp,%xmm2
  40584c:	f3 0f 5e c2          	divss  %xmm2,%xmm0
  405850:	f3 0f 11 00          	movss  %xmm0,(%rax)
  405854:	48 83 c0 14          	add    $0x14,%rax
}

for(j=0;j<arraysize;j++)
	hufftree[(int)plaintext[j]].freq+=(float)1.0;

for(i=0;i<256;i++)
  405858:	48 39 f0             	cmp    %rsi,%rax
  40585b:	75 db                	jne    405838 <DoHuffIteration+0xd8>
}

__fortify_function void
__NTH (bzero (void *__dest, size_t __len))
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __bos0 (__dest));
  40585d:	49 8d bd 08 14 00 00 	lea    0x1408(%r13),%rdi
  405864:	44 89 e8             	mov    %r13d,%eax
  405867:	49 c7 85 00 14 00 00 	movq   $0x0,0x1400(%r13)
  40586e:	00 00 00 00 
  405872:	49 c7 85 f8 27 00 00 	movq   $0x0,0x27f8(%r13)
  405879:	00 00 00 00 
  40587d:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  405881:	29 f8                	sub    %edi,%eax
  405883:	8d 88 00 28 00 00    	lea    0x2800(%rax),%ecx
  405889:	31 c0                	xor    %eax,%eax
  40588b:	c1 e9 03             	shr    $0x3,%ecx
  40588e:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  405891:	49 8d 8d 04 28 00 00 	lea    0x2804(%r13),%rcx
  405898:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40589f:	00 
/*
** Build the huffman tree.  First clear all the parent
** pointers and left/right pointers.  Also, discard all
** nodes that have a frequency of true 0.  */
for(i=0;i<512;i++)
{       if(hufftree[i].freq==(float)0.0)
  4058a0:	0f 2e 0a             	ucomiss (%rdx),%xmm1
  4058a3:	7a 07                	jp     4058ac <DoHuffIteration+0x14c>
		hufftree[i].parent=EXCLUDED;
  4058a5:	b8 00 7d 00 00       	mov    $0x7d00,%eax
/*
** Build the huffman tree.  First clear all the parent
** pointers and left/right pointers.  Also, discard all
** nodes that have a frequency of true 0.  */
for(i=0;i<512;i++)
{       if(hufftree[i].freq==(float)0.0)
  4058aa:	74 13                	je     4058bf <DoHuffIteration+0x15f>
		hufftree[i].parent=EXCLUDED;
	else
		hufftree[i].parent=hufftree[i].left=hufftree[i].right=-1;
  4058ac:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
  4058b3:	c7 42 08 ff ff ff ff 	movl   $0xffffffff,0x8(%rdx)
  4058ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4058bf:	89 42 04             	mov    %eax,0x4(%rdx)
  4058c2:	48 83 c2 14          	add    $0x14,%rdx
bzero((char *)&(hufftree[256]),sizeof(huff_node)*256);
/*
** Build the huffman tree.  First clear all the parent
** pointers and left/right pointers.  Also, discard all
** nodes that have a frequency of true 0.  */
for(i=0;i<512;i++)
  4058c6:	48 39 ca             	cmp    %rcx,%rdx
  4058c9:	75 d5                	jne    4058a0 <DoHuffIteration+0x140>
  4058cb:	4d 8d 45 08          	lea    0x8(%r13),%r8
  4058cf:	b9 00 01 00 00       	mov    $0x100,%ecx
  4058d4:	0f 1f 40 00          	nopl   0x0(%rax)
  4058d8:	44 8d 59 ff          	lea    -0x1(%rcx),%r11d
  4058dc:	4c 89 c7             	mov    %r8,%rdi
  4058df:	4c 89 c0             	mov    %r8,%rax
*/
root=255;                       /* Starting root node-1 */
while(1)
{
	lowfreq1=(float)2.0; lowfreq2=(float)2.0;
	lowidx1=-1; lowidx2=-1;
  4058e2:	41 b9 ff ff ff ff    	mov    $0xffffffff,%r9d
** frequency.
*/
root=255;                       /* Starting root node-1 */
while(1)
{
	lowfreq1=(float)2.0; lowfreq2=(float)2.0;
  4058e8:	0f 28 c3             	movaps %xmm3,%xmm0
	lowidx1=-1; lowidx2=-1;
	/*
	** Find first lowest frequency.
	*/
	for(i=0;i<=root;i++)
  4058eb:	31 d2                	xor    %edx,%edx
  4058ed:	eb 0c                	jmp    4058fb <DoHuffIteration+0x19b>
  4058ef:	90                   	nop
  4058f0:	83 c2 01             	add    $0x1,%edx
  4058f3:	48 83 c0 14          	add    $0x14,%rax
  4058f7:	39 ca                	cmp    %ecx,%edx
  4058f9:	74 25                	je     405920 <DoHuffIteration+0x1c0>
		if(hufftree[i].parent<0)
  4058fb:	44 8b 30             	mov    (%rax),%r14d
  4058fe:	45 85 f6             	test   %r14d,%r14d
  405901:	79 ed                	jns    4058f0 <DoHuffIteration+0x190>
			if(hufftree[i].freq<lowfreq1)
  405903:	f3 0f 10 48 fc       	movss  -0x4(%rax),%xmm1
  405908:	0f 2e c1             	ucomiss %xmm1,%xmm0
  40590b:	76 e3                	jbe    4058f0 <DoHuffIteration+0x190>
  40590d:	41 89 d1             	mov    %edx,%r9d
	lowfreq1=(float)2.0; lowfreq2=(float)2.0;
	lowidx1=-1; lowidx2=-1;
	/*
	** Find first lowest frequency.
	*/
	for(i=0;i<=root;i++)
  405910:	83 c2 01             	add    $0x1,%edx
  405913:	48 83 c0 14          	add    $0x14,%rax
  405917:	39 ca                	cmp    %ecx,%edx
		if(hufftree[i].parent<0)
			if(hufftree[i].freq<lowfreq1)
			{       lowfreq1=hufftree[i].freq;
  405919:	0f 28 c1             	movaps %xmm1,%xmm0
	lowfreq1=(float)2.0; lowfreq2=(float)2.0;
	lowidx1=-1; lowidx2=-1;
	/*
	** Find first lowest frequency.
	*/
	for(i=0;i<=root;i++)
  40591c:	75 dd                	jne    4058fb <DoHuffIteration+0x19b>
  40591e:	66 90                	xchg   %ax,%ax

	/*
	** Did we find a lowest value?  If not, the
	** tree is done.
	*/
	if(lowidx1==-1) break;
  405920:	41 83 f9 ff          	cmp    $0xffffffff,%r9d
  405924:	74 71                	je     405997 <DoHuffIteration+0x237>
  405926:	0f 28 cb             	movaps %xmm3,%xmm1
  405929:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  40592e:	31 c0                	xor    %eax,%eax

	/*
	** Find next lowest frequency
	*/
	for(i=0;i<=root;i++)
		if((hufftree[i].parent<0) && (i!=lowidx1))
  405930:	44 8b 17             	mov    (%rdi),%r10d
  405933:	45 85 d2             	test   %r10d,%r10d
  405936:	79 14                	jns    40594c <DoHuffIteration+0x1ec>
  405938:	41 39 c1             	cmp    %eax,%r9d
  40593b:	74 0f                	je     40594c <DoHuffIteration+0x1ec>
			if(hufftree[i].freq<lowfreq2)
  40593d:	f3 0f 10 57 fc       	movss  -0x4(%rdi),%xmm2
  405942:	0f 2e ca             	ucomiss %xmm2,%xmm1
  405945:	76 05                	jbe    40594c <DoHuffIteration+0x1ec>
			{       lowfreq2=hufftree[i].freq;
  405947:	0f 28 ca             	movaps %xmm2,%xmm1
  40594a:	89 c2                	mov    %eax,%edx
	if(lowidx1==-1) break;

	/*
	** Find next lowest frequency
	*/
	for(i=0;i<=root;i++)
  40594c:	83 c0 01             	add    $0x1,%eax
  40594f:	48 83 c7 14          	add    $0x14,%rdi
  405953:	39 c8                	cmp    %ecx,%eax
  405955:	75 d9                	jne    405930 <DoHuffIteration+0x1d0>
	/*
	** If we could only find one item, then that
	** item is surely the root, and (as above) the
	** tree is done.
	*/
	if(lowidx2==-1) break;
  405957:	83 fa ff             	cmp    $0xffffffff,%edx
  40595a:	74 3b                	je     405997 <DoHuffIteration+0x237>
	/*
	** Attach the two new nodes to the current root, and
	** advance the current root.
	*/
	root++;                 /* New root */
	hufftree[lowidx1].parent=root;
  40595c:	49 63 c1             	movslq %r9d,%rax
	hufftree[lowidx2].parent=root;
	hufftree[root].freq=lowfreq1+lowfreq2;
  40595f:	f3 0f 58 c1          	addss  %xmm1,%xmm0
  405963:	48 83 c6 14          	add    $0x14,%rsi
	/*
	** Attach the two new nodes to the current root, and
	** advance the current root.
	*/
	root++;                 /* New root */
	hufftree[lowidx1].parent=root;
  405967:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  40596b:	41 89 4c 85 08       	mov    %ecx,0x8(%r13,%rax,4)
	hufftree[lowidx2].parent=root;
  405970:	48 63 c2             	movslq %edx,%rax
  405973:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  405977:	41 89 4c 85 08       	mov    %ecx,0x8(%r13,%rax,4)
	hufftree[root].freq=lowfreq1+lowfreq2;
  40597c:	f3 0f 11 46 ec       	movss  %xmm0,-0x14(%rsi)
	hufftree[root].left=lowidx1;
  405981:	44 89 4e f4          	mov    %r9d,-0xc(%rsi)
	hufftree[root].right=lowidx2;
  405985:	89 56 f8             	mov    %edx,-0x8(%rsi)
	hufftree[root].parent=-2;       /* Show root */
  405988:	c7 46 f0 fe ff ff ff 	movl   $0xfffffffe,-0x10(%rsi)
  40598f:	83 c1 01             	add    $0x1,%ecx
}
  405992:	e9 41 ff ff ff       	jmpq   4058d8 <DoHuffIteration+0x178>

/*
** Huffman tree built...compress the plaintext
*/
bitoffset=0L;                           /* Initialize bit offset */
for(i=0;i<arraysize;i++)
  405997:	45 31 f6             	xor    %r14d,%r14d
  40599a:	48 85 ed             	test   %rbp,%rbp
  40599d:	4d 89 e2             	mov    %r12,%r10
  4059a0:	4d 8d 3c 2c          	lea    (%r12,%rbp,1),%r15
  4059a4:	4c 8d 44 24 2f       	lea    0x2f(%rsp),%r8
** Set or clear
*/
if(bitchar=='1')
	comparray[byteoffset]|=(1<<bitnumb);
else
	comparray[byteoffset]&=~(1<<bitnumb);
  4059a9:	41 b9 01 00 00 00    	mov    $0x1,%r9d

/*
** Huffman tree built...compress the plaintext
*/
bitoffset=0L;                           /* Initialize bit offset */
for(i=0;i<arraysize;i++)
  4059af:	0f 84 d5 01 00 00    	je     405b8a <DoHuffIteration+0x42a>
  4059b5:	0f 1f 00             	nopl   (%rax)
{
	c=(int)plaintext[i];                 /* Fetch character */
  4059b8:	49 0f be 32          	movsbq (%r10),%rsi
	/*
	** Build a bit string for byte c
	*/
	bitstringlen=0;
	while(hufftree[c].parent!=-2)
  4059bc:	48 8d 04 b6          	lea    (%rsi,%rsi,4),%rax
  4059c0:	41 8b 44 85 08       	mov    0x8(%r13,%rax,4),%eax
  4059c5:	83 f8 fe             	cmp    $0xfffffffe,%eax
  4059c8:	0f 84 8c 00 00 00    	je     405a5a <DoHuffIteration+0x2fa>
  4059ce:	31 ff                	xor    %edi,%edi
  4059d0:	eb 09                	jmp    4059db <DoHuffIteration+0x27b>
  4059d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	{       if(hufftree[hufftree[c].parent].left==c)
			bitstring[bitstringlen]='0';
		else
			bitstring[bitstringlen]='1';
		c=hufftree[c].parent;
		bitstringlen++;
  4059d8:	48 89 d7             	mov    %rdx,%rdi
	/*
	** Build a bit string for byte c
	*/
	bitstringlen=0;
	while(hufftree[c].parent!=-2)
	{       if(hufftree[hufftree[c].parent].left==c)
  4059db:	48 63 d0             	movslq %eax,%rdx
  4059de:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
  4059e2:	49 8d 4c 95 00       	lea    0x0(%r13,%rdx,4),%rcx
  4059e7:	39 71 0c             	cmp    %esi,0xc(%rcx)
  4059ea:	89 c6                	mov    %eax,%esi
  4059ec:	8b 41 08             	mov    0x8(%rcx),%eax
  4059ef:	0f 95 c2             	setne  %dl
  4059f2:	83 c2 30             	add    $0x30,%edx
	c=(int)plaintext[i];                 /* Fetch character */
	/*
	** Build a bit string for byte c
	*/
	bitstringlen=0;
	while(hufftree[c].parent!=-2)
  4059f5:	83 f8 fe             	cmp    $0xfffffffe,%eax
  4059f8:	88 54 3c 30          	mov    %dl,0x30(%rsp,%rdi,1)
	{       if(hufftree[hufftree[c].parent].left==c)
			bitstring[bitstringlen]='0';
		else
			bitstring[bitstringlen]='1';
		c=hufftree[c].parent;
		bitstringlen++;
  4059fc:	48 8d 57 01          	lea    0x1(%rdi),%rdx
	c=(int)plaintext[i];                 /* Fetch character */
	/*
	** Build a bit string for byte c
	*/
	bitstringlen=0;
	while(hufftree[c].parent!=-2)
  405a00:	75 d6                	jne    4059d8 <DoHuffIteration+0x278>
  405a02:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
  405a07:	4c 89 f6             	mov    %r14,%rsi
  405a0a:	48 89 3c 24          	mov    %rdi,(%rsp)
  405a0e:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
  405a12:	eb 16                	jmp    405a2a <DoHuffIteration+0x2ca>
  405a14:	0f 1f 40 00          	nopl   0x0(%rax)
  405a18:	48 83 ea 01          	sub    $0x1,%rdx
** Set or clear
*/
if(bitchar=='1')
	comparray[byteoffset]|=(1<<bitnumb);
else
	comparray[byteoffset]&=~(1<<bitnumb);
  405a1c:	f7 d1                	not    %ecx
	** Step backwards through the bit string, setting
	** bits in the compressed array as you go.
	*/
	while(bitstringlen--)
	{       SetCompBit((u8 *)comparray,(u32)bitoffset,bitstring[bitstringlen]);
		bitoffset++;
  405a1e:	48 83 c6 01          	add    $0x1,%rsi
** Set or clear
*/
if(bitchar=='1')
	comparray[byteoffset]|=(1<<bitnumb);
else
	comparray[byteoffset]&=~(1<<bitnumb);
  405a22:	20 0c 03             	and    %cl,(%rbx,%rax,1)

	/*
	** Step backwards through the bit string, setting
	** bits in the compressed array as you go.
	*/
	while(bitstringlen--)
  405a25:	4c 39 c2             	cmp    %r8,%rdx
  405a28:	74 27                	je     405a51 <DoHuffIteration+0x2f1>
/*
** First calculate which element in the comparray to
** alter. and the bitnumber.
*/
byteoffset=bitoffset>>3;
bitnumb=bitoffset % 8;
  405a2a:	89 f1                	mov    %esi,%ecx

/*
** First calculate which element in the comparray to
** alter. and the bitnumber.
*/
byteoffset=bitoffset>>3;
  405a2c:	89 f0                	mov    %esi,%eax

/*
** Set or clear
*/
if(bitchar=='1')
	comparray[byteoffset]|=(1<<bitnumb);
  405a2e:	44 89 cf             	mov    %r9d,%edi
/*
** First calculate which element in the comparray to
** alter. and the bitnumber.
*/
byteoffset=bitoffset>>3;
bitnumb=bitoffset % 8;
  405a31:	83 e1 07             	and    $0x7,%ecx

/*
** First calculate which element in the comparray to
** alter. and the bitnumber.
*/
byteoffset=bitoffset>>3;
  405a34:	c1 e8 03             	shr    $0x3,%eax

/*
** Set or clear
*/
if(bitchar=='1')
	comparray[byteoffset]|=(1<<bitnumb);
  405a37:	d3 e7                	shl    %cl,%edi
bitnumb=bitoffset % 8;

/*
** Set or clear
*/
if(bitchar=='1')
  405a39:	80 3a 31             	cmpb   $0x31,(%rdx)
	comparray[byteoffset]|=(1<<bitnumb);
  405a3c:	89 f9                	mov    %edi,%ecx
bitnumb=bitoffset % 8;

/*
** Set or clear
*/
if(bitchar=='1')
  405a3e:	75 d8                	jne    405a18 <DoHuffIteration+0x2b8>
  405a40:	48 83 ea 01          	sub    $0x1,%rdx
	comparray[byteoffset]|=(1<<bitnumb);
  405a44:	40 08 3c 03          	or     %dil,(%rbx,%rax,1)
	** Step backwards through the bit string, setting
	** bits in the compressed array as you go.
	*/
	while(bitstringlen--)
	{       SetCompBit((u8 *)comparray,(u32)bitoffset,bitstring[bitstringlen]);
		bitoffset++;
  405a48:	48 83 c6 01          	add    $0x1,%rsi

	/*
	** Step backwards through the bit string, setting
	** bits in the compressed array as you go.
	*/
	while(bitstringlen--)
  405a4c:	4c 39 c2             	cmp    %r8,%rdx
  405a4f:	75 d9                	jne    405a2a <DoHuffIteration+0x2ca>
  405a51:	48 8b 3c 24          	mov    (%rsp),%rdi
  405a55:	4e 8d 74 37 01       	lea    0x1(%rdi,%r14,1),%r14
  405a5a:	49 83 c2 01          	add    $0x1,%r10

/*
** Huffman tree built...compress the plaintext
*/
bitoffset=0L;                           /* Initialize bit offset */
for(i=0;i<arraysize;i++)
  405a5e:	4d 39 fa             	cmp    %r15,%r10
  405a61:	0f 85 51 ff ff ff    	jne    4059b8 <DoHuffIteration+0x258>
  405a67:	4d 63 db             	movslq %r11d,%r11
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
  405a6a:	8b 7c 24 10          	mov    0x10(%rsp),%edi

/*
** Huffman tree built...compress the plaintext
*/
bitoffset=0L;                           /* Initialize bit offset */
for(i=0;i<arraysize;i++)
  405a6e:	45 31 c9             	xor    %r9d,%r9d
  405a71:	4b 8d 04 9b          	lea    (%r11,%r11,4),%rax
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
  405a75:	4c 89 34 24          	mov    %r14,(%rsp)
  405a79:	48 89 6c 24 20       	mov    %rbp,0x20(%rsp)
  405a7e:	4d 89 e6             	mov    %r12,%r14

/*
** Huffman tree built...compress the plaintext
*/
bitoffset=0L;                           /* Initialize bit offset */
for(i=0;i<arraysize;i++)
  405a81:	45 31 ff             	xor    %r15d,%r15d
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
  405a84:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  405a8a:	4d 8d 54 85 00       	lea    0x0(%r13,%rax,4),%r10
  405a8f:	4d 89 cc             	mov    %r9,%r12
  405a92:	4c 89 d5             	mov    %r10,%rbp
  405a95:	0f 1f 00             	nopl   (%rax)
maxbitoffset=bitoffset;
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
  405a98:	48 63 45 0c          	movslq 0xc(%rbp),%rax
  405a9c:	48 89 ee             	mov    %rbp,%rsi
  405a9f:	83 f8 ff             	cmp    $0xffffffff,%eax
  405aa2:	74 39                	je     405add <DoHuffIteration+0x37d>
  405aa4:	0f 1f 40 00          	nopl   0x0(%rax)
bitnumb=bitoffset % 8;

/*
** Fetch
*/
return((1<<bitnumb) & comparray[byteoffset] );
  405aa8:	44 89 fa             	mov    %r15d,%edx
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
  405aab:	44 89 f9             	mov    %r15d,%ecx
bitnumb=bitoffset % 8;

/*
** Fetch
*/
return((1<<bitnumb) & comparray[byteoffset] );
  405aae:	c1 ea 03             	shr    $0x3,%edx
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
  405ab1:	83 e1 07             	and    $0x7,%ecx
  405ab4:	44 0f b6 0c 13       	movzbl (%rbx,%rdx,1),%r9d
  405ab9:	44 89 c2             	mov    %r8d,%edx
  405abc:	d3 e2                	shl    %cl,%edx
  405abe:	41 85 d1             	test   %edx,%r9d
  405ac1:	74 04                	je     405ac7 <DoHuffIteration+0x367>
			i=hufftree[i].left;
		else
			i=hufftree[i].right;
  405ac3:	48 63 46 10          	movslq 0x10(%rsi),%rax
maxbitoffset=bitoffset;
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
  405ac7:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
			i=hufftree[i].left;
		else
			i=hufftree[i].right;
		bitoffset++;
  405acb:	49 83 c7 01          	add    $0x1,%r15
maxbitoffset=bitoffset;
bitoffset=0;
textoffset=0;
do {
	i=root;
	while(hufftree[i].left!=-1)
  405acf:	49 8d 74 85 00       	lea    0x0(%r13,%rax,4),%rsi
  405ad4:	48 63 46 0c          	movslq 0xc(%rsi),%rax
  405ad8:	83 f8 ff             	cmp    $0xffffffff,%eax
  405adb:	75 cb                	jne    405aa8 <DoHuffIteration+0x348>
			i=hufftree[i].left;
		else
			i=hufftree[i].right;
		bitoffset++;
	}
	decomparray[textoffset]=hufftree[i].c;
  405add:	0f b6 06             	movzbl (%rsi),%eax
  405ae0:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  405ae5:	42 88 04 22          	mov    %al,(%rdx,%r12,1)

#ifdef DEBUG
	if(hufftree[i].c != plaintext[textoffset])
  405ae9:	0f b6 16             	movzbl (%rsi),%edx
  405aec:	43 0f be 04 26       	movsbl (%r14,%r12,1),%eax
  405af1:	39 c2                	cmp    %eax,%edx
  405af3:	74 2f                	je     405b24 <DoHuffIteration+0x3c4>
  405af5:	bf 01 00 00 00       	mov    $0x1,%edi
  405afa:	4c 89 e2             	mov    %r12,%rdx
  405afd:	be eb dd 40 00       	mov    $0x40ddeb,%esi
  405b02:	31 c0                	xor    %eax,%eax
  405b04:	f3 0f 11 5c 24 14    	movss  %xmm3,0x14(%rsp)
  405b0a:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
  405b0f:	e8 fc b4 ff ff       	callq  401010 <__printf_chk@plt>
	{
		/* Show error */
		printf("Error at textoffset %ld\n",textoffset);
		status=1;
  405b14:	44 8b 44 24 10       	mov    0x10(%rsp),%r8d
  405b19:	bf 01 00 00 00       	mov    $0x1,%edi
  405b1e:	f3 0f 10 5c 24 14    	movss  0x14(%rsp),%xmm3
	}
#endif
	textoffset++;
  405b24:	49 83 c4 01          	add    $0x1,%r12
} while(bitoffset<maxbitoffset);
  405b28:	4c 39 3c 24          	cmp    %r15,(%rsp)
  405b2c:	0f 8f 66 ff ff ff    	jg     405a98 <DoHuffIteration+0x338>
  405b32:	48 83 6c 24 18 01    	subq   $0x1,0x18(%rsp)
  405b38:	89 7c 24 10          	mov    %edi,0x10(%rsp)
  405b3c:	4d 89 f4             	mov    %r14,%r12
elapsed=StartStopwatch();

/*
** Do everything for nloops
*/
while(nloops--)
  405b3f:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
  405b45:	48 8b 6c 24 20       	mov    0x20(%rsp),%rbp
  405b4a:	0f 85 6d fc ff ff    	jne    4057bd <DoHuffIteration+0x5d>

/*
** All done
*/
#ifdef DEBUG
  if (status==0) printf("Huffman: OK\n");
  405b50:	8b 44 24 10          	mov    0x10(%rsp),%eax
  405b54:	85 c0                	test   %eax,%eax
  405b56:	75 0a                	jne    405b62 <DoHuffIteration+0x402>
  405b58:	bf 04 de 40 00       	mov    $0x40de04,%edi
  405b5d:	e8 2e b3 ff ff       	callq  400e90 <puts@plt>
#endif
return(StopStopwatch(elapsed));
  405b62:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
  405b67:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  405b6e:	00 00 
  405b70:	75 20                	jne    405b92 <DoHuffIteration+0x432>
  405b72:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
}
  405b77:	48 83 c4 68          	add    $0x68,%rsp
  405b7b:	5b                   	pop    %rbx
  405b7c:	5d                   	pop    %rbp
  405b7d:	41 5c                	pop    %r12
  405b7f:	41 5d                	pop    %r13
  405b81:	41 5e                	pop    %r14
  405b83:	41 5f                	pop    %r15
** All done
*/
#ifdef DEBUG
  if (status==0) printf("Huffman: OK\n");
#endif
return(StopStopwatch(elapsed));
  405b85:	e9 36 66 00 00       	jmpq   40c1c0 <StopStopwatch>

/*
** Huffman tree built...compress the plaintext
*/
bitoffset=0L;                           /* Initialize bit offset */
for(i=0;i<arraysize;i++)
  405b8a:	49 89 ee             	mov    %rbp,%r14
  405b8d:	e9 d5 fe ff ff       	jmpq   405a67 <DoHuffIteration+0x307>
** All done
*/
#ifdef DEBUG
  if (status==0) printf("Huffman: OK\n");
#endif
return(StopStopwatch(elapsed));
  405b92:	e8 69 b3 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  405b97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  405b9e:	00 00 

0000000000405ba0 <DoNNetIteration>:
*********************
** Do a single iteration of the neural net benchmark.
** By iteration, we mean a "learning" pass.
*/
static ulong DoNNetIteration(ulong nloops)
{
  405ba0:	41 57                	push   %r15
  405ba2:	41 56                	push   %r14
** the learning cycle is the weight randomization and
** zeroing of changes.  This should reduce clock jitter,
** since we don't have to stop and start the clock for
** each iteration.
*/
elapsed=StartStopwatch();
  405ba4:	31 c0                	xor    %eax,%eax
*********************
** Do a single iteration of the neural net benchmark.
** By iteration, we mean a "learning" pass.
*/
static ulong DoNNetIteration(ulong nloops)
{
  405ba6:	41 55                	push   %r13
  405ba8:	41 54                	push   %r12
  405baa:	55                   	push   %rbp
  405bab:	53                   	push   %rbx
  405bac:	48 89 fb             	mov    %rdi,%rbx
  405baf:	48 83 ec 68          	sub    $0x68,%rsp
** the learning cycle is the weight randomization and
** zeroing of changes.  This should reduce clock jitter,
** since we don't have to stop and start the clock for
** each iteration.
*/
elapsed=StartStopwatch();
  405bb3:	e8 f8 65 00 00       	callq  40c1b0 <StartStopwatch>
while(nloops--)
  405bb8:	48 85 db             	test   %rbx,%rbx
** the learning cycle is the weight randomization and
** zeroing of changes.  This should reduce clock jitter,
** since we don't have to stop and start the clock for
** each iteration.
*/
elapsed=StartStopwatch();
  405bbb:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
while(nloops--)
  405bc0:	0f 84 73 17 00 00    	je     407339 <DoNNetIteration+0x1799>
  405bc6:	66 44 0f 28 2d 41 87 	movapd 0x8741(%rip),%xmm13        # 40e310 <jtable.3055+0x1580>
  405bcd:	00 00 
  405bcf:	48 89 5c 24 58       	mov    %rbx,0x58(%rsp)
  405bd4:	bb 60 14 61 00       	mov    $0x611460,%ebx
  405bd9:	48 8d ab 18 01 00 00 	lea    0x118(%rbx),%rbp
for (neurode = 0; neurode<MID_SIZE; neurode++)
{
	for(i=0; i<IN_SIZE; i++)
	{
	        /* value=(double)abs_randwc(100000L); */
		value=(double)abs_randwc((int32)100000);
  405be0:	bf a0 86 01 00       	mov    $0x186a0,%edi
  405be5:	48 83 c3 08          	add    $0x8,%rbx
  405be9:	44 0f 29 2c 24       	movaps %xmm13,(%rsp)
  405bee:	e8 8d eb ff ff       	callq  404780 <abs_randwc>
		value=value/(double)100000.0 - (double) 0.5;
  405bf3:	66 0f ef c0          	pxor   %xmm0,%xmm0
  405bf7:	89 c0                	mov    %eax,%eax
**        srand(i);
*/

for (neurode = 0; neurode<MID_SIZE; neurode++)
{
	for(i=0; i<IN_SIZE; i++)
  405bf9:	66 44 0f 28 2c 24    	movapd (%rsp),%xmm13
	{
	        /* value=(double)abs_randwc(100000L); */
		value=(double)abs_randwc((int32)100000);
		value=value/(double)100000.0 - (double) 0.5;
  405bff:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  405c04:	f2 0f 5e 05 84 86 00 	divsd  0x8684(%rip),%xmm0        # 40e290 <jtable.3055+0x1500>
  405c0b:	00 
		mid_wts[neurode][i] = value/2;
  405c0c:	f2 0f 5c 05 84 86 00 	subsd  0x8684(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  405c13:	00 
  405c14:	f2 0f 59 05 7c 86 00 	mulsd  0x867c(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  405c1b:	00 
  405c1c:	f2 0f 11 43 f8       	movsd  %xmm0,-0x8(%rbx)
**        srand(i);
*/

for (neurode = 0; neurode<MID_SIZE; neurode++)
{
	for(i=0; i<IN_SIZE; i++)
  405c21:	48 39 dd             	cmp    %rbx,%rbp
  405c24:	75 ba                	jne    405be0 <DoNNetIteration+0x40>
**        printf("\n Please enter a random number seed (1..32767):  ");
**        scanf("%d", &i);
**        srand(i);
*/

for (neurode = 0; neurode<MID_SIZE; neurode++)
  405c26:	48 81 fd 20 1d 61 00 	cmp    $0x611d20,%rbp
  405c2d:	48 89 eb             	mov    %rbp,%rbx
  405c30:	75 a7                	jne    405bd9 <DoNNetIteration+0x39>
  405c32:	bb e0 40 61 00       	mov    $0x6140e0,%ebx
  405c37:	48 8d 6b 40          	lea    0x40(%rbx),%rbp
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for(i=0; i<MID_SIZE; i++)
	{
	        /* value=(double)abs_randwc(100000L); */
		value=(double)abs_randwc((int32)100000);
  405c3b:	bf a0 86 01 00       	mov    $0x186a0,%edi
  405c40:	48 83 c3 08          	add    $0x8,%rbx
  405c44:	44 0f 29 2c 24       	movaps %xmm13,(%rsp)
  405c49:	e8 32 eb ff ff       	callq  404780 <abs_randwc>
		value=value/(double)10000.0 - (double) 0.5;
  405c4e:	66 0f ef c0          	pxor   %xmm0,%xmm0
  405c52:	89 c0                	mov    %eax,%eax
		mid_wts[neurode][i] = value/2;
	}
}
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for(i=0; i<MID_SIZE; i++)
  405c54:	66 44 0f 28 2c 24    	movapd (%rsp),%xmm13
	{
	        /* value=(double)abs_randwc(100000L); */
		value=(double)abs_randwc((int32)100000);
		value=value/(double)10000.0 - (double) 0.5;
  405c5a:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  405c5f:	f2 0f 5e 05 39 86 00 	divsd  0x8639(%rip),%xmm0        # 40e2a0 <jtable.3055+0x1510>
  405c66:	00 
		out_wts[neurode][i] = value/2;
  405c67:	f2 0f 5c 05 29 86 00 	subsd  0x8629(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  405c6e:	00 
  405c6f:	f2 0f 59 05 21 86 00 	mulsd  0x8621(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  405c76:	00 
  405c77:	f2 0f 11 43 f8       	movsd  %xmm0,-0x8(%rbx)
		mid_wts[neurode][i] = value/2;
	}
}
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for(i=0; i<MID_SIZE; i++)
  405c7c:	48 39 dd             	cmp    %rbx,%rbp
  405c7f:	75 ba                	jne    405c3b <DoNNetIteration+0x9b>
		value=(double)abs_randwc((int32)100000);
		value=value/(double)100000.0 - (double) 0.5;
		mid_wts[neurode][i] = value/2;
	}
}
for (neurode=0; neurode<OUT_SIZE; neurode++)
  405c81:	48 81 fd e0 42 61 00 	cmp    $0x6142e0,%rbp
  405c88:	48 89 eb             	mov    %rbp,%rbx
  405c8b:	75 aa                	jne    405c37 <DoNNetIteration+0x97>
  405c8d:	ba c0 2a 61 00       	mov    $0x612ac0,%edx
  405c92:	be a0 35 61 00       	mov    $0x6135a0,%esi
  405c97:	31 c0                	xor    %eax,%eax
  405c99:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
  405c9d:	48 89 d1             	mov    %rdx,%rcx
  405ca0:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  405ca7:	48 c7 82 10 01 00 00 	movq   $0x0,0x110(%rdx)
  405cae:	00 00 00 00 
  405cb2:	48 81 c2 18 01 00 00 	add    $0x118,%rdx
  405cb9:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  405cbd:	48 29 f9             	sub    %rdi,%rcx
  405cc0:	81 c1 18 01 00 00    	add    $0x118,%ecx
  405cc6:	c1 e9 03             	shr    $0x3,%ecx
  405cc9:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  405ccc:	48 8d 7e 08          	lea    0x8(%rsi),%rdi
  405cd0:	48 89 f1             	mov    %rsi,%rcx
  405cd3:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
  405cda:	48 c7 86 10 01 00 00 	movq   $0x0,0x110(%rsi)
  405ce1:	00 00 00 00 
  405ce5:	48 81 c6 18 01 00 00 	add    $0x118,%rsi
  405cec:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  405cf0:	48 29 f9             	sub    %rdi,%rcx
  405cf3:	81 c1 18 01 00 00    	add    $0x118,%ecx
  405cf9:	c1 e9 03             	shr    $0x3,%ecx
**/
static void zero_changes()
{
int i,j;

for (i = 0; i<MID_SIZE; i++)
  405cfc:	48 81 fa 80 33 61 00 	cmp    $0x613380,%rdx
  405d03:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  405d06:	75 91                	jne    405c99 <DoNNetIteration+0xf9>

for (i = 0; i< OUT_SIZE; i++)
{
	for (j=0; j<MID_SIZE; j++)
	{
		out_wt_change[i][j] = 0.0;
  405d08:	66 0f ef c0          	pxor   %xmm0,%xmm0
  405d0c:	0f 29 05 8d d6 20 00 	movaps %xmm0,0x20d68d(%rip)        # 6133a0 <out_wt_change>
  405d13:	0f 29 05 96 d6 20 00 	movaps %xmm0,0x20d696(%rip)        # 6133b0 <out_wt_change+0x10>
  405d1a:	0f 29 05 9f d6 20 00 	movaps %xmm0,0x20d69f(%rip)        # 6133c0 <out_wt_change+0x20>
  405d21:	0f 29 05 a8 d6 20 00 	movaps %xmm0,0x20d6a8(%rip)        # 6133d0 <out_wt_change+0x30>
  405d28:	0f 29 05 b1 d6 20 00 	movaps %xmm0,0x20d6b1(%rip)        # 6133e0 <out_wt_change+0x40>
  405d2f:	0f 29 05 ba d6 20 00 	movaps %xmm0,0x20d6ba(%rip)        # 6133f0 <out_wt_change+0x50>
  405d36:	0f 29 05 c3 d6 20 00 	movaps %xmm0,0x20d6c3(%rip)        # 613400 <out_wt_change+0x60>
  405d3d:	0f 29 05 cc d6 20 00 	movaps %xmm0,0x20d6cc(%rip)        # 613410 <out_wt_change+0x70>
  405d44:	0f 29 05 d5 d6 20 00 	movaps %xmm0,0x20d6d5(%rip)        # 613420 <out_wt_change+0x80>
  405d4b:	0f 29 05 de d6 20 00 	movaps %xmm0,0x20d6de(%rip)        # 613430 <out_wt_change+0x90>
  405d52:	0f 29 05 e7 d6 20 00 	movaps %xmm0,0x20d6e7(%rip)        # 613440 <out_wt_change+0xa0>
  405d59:	0f 29 05 f0 d6 20 00 	movaps %xmm0,0x20d6f0(%rip)        # 613450 <out_wt_change+0xb0>
  405d60:	0f 29 05 f9 d6 20 00 	movaps %xmm0,0x20d6f9(%rip)        # 613460 <out_wt_change+0xc0>
  405d67:	0f 29 05 02 d7 20 00 	movaps %xmm0,0x20d702(%rip)        # 613470 <out_wt_change+0xd0>
  405d6e:	0f 29 05 0b d7 20 00 	movaps %xmm0,0x20d70b(%rip)        # 613480 <out_wt_change+0xe0>
  405d75:	0f 29 05 14 d7 20 00 	movaps %xmm0,0x20d714(%rip)        # 613490 <out_wt_change+0xf0>
  405d7c:	0f 29 05 1d d7 20 00 	movaps %xmm0,0x20d71d(%rip)        # 6134a0 <out_wt_change+0x100>
  405d83:	0f 29 05 26 d7 20 00 	movaps %xmm0,0x20d726(%rip)        # 6134b0 <out_wt_change+0x110>
  405d8a:	0f 29 05 2f d7 20 00 	movaps %xmm0,0x20d72f(%rip)        # 6134c0 <out_wt_change+0x120>
  405d91:	0f 29 05 38 d7 20 00 	movaps %xmm0,0x20d738(%rip)        # 6134d0 <out_wt_change+0x130>
  405d98:	0f 29 05 41 d7 20 00 	movaps %xmm0,0x20d741(%rip)        # 6134e0 <out_wt_change+0x140>
  405d9f:	0f 29 05 4a d7 20 00 	movaps %xmm0,0x20d74a(%rip)        # 6134f0 <out_wt_change+0x150>
  405da6:	0f 29 05 53 d7 20 00 	movaps %xmm0,0x20d753(%rip)        # 613500 <out_wt_change+0x160>
  405dad:	0f 29 05 5c d7 20 00 	movaps %xmm0,0x20d75c(%rip)        # 613510 <out_wt_change+0x170>
  405db4:	0f 29 05 65 d7 20 00 	movaps %xmm0,0x20d765(%rip)        # 613520 <out_wt_change+0x180>
  405dbb:	0f 29 05 6e d7 20 00 	movaps %xmm0,0x20d76e(%rip)        # 613530 <out_wt_change+0x190>
  405dc2:	0f 29 05 77 d7 20 00 	movaps %xmm0,0x20d777(%rip)        # 613540 <out_wt_change+0x1a0>
  405dc9:	0f 29 05 80 d7 20 00 	movaps %xmm0,0x20d780(%rip)        # 613550 <out_wt_change+0x1b0>
  405dd0:	0f 29 05 89 d7 20 00 	movaps %xmm0,0x20d789(%rip)        # 613560 <out_wt_change+0x1c0>
  405dd7:	0f 29 05 92 d7 20 00 	movaps %xmm0,0x20d792(%rip)        # 613570 <out_wt_change+0x1d0>
  405dde:	0f 29 05 9b d7 20 00 	movaps %xmm0,0x20d79b(%rip)        # 613580 <out_wt_change+0x1e0>
  405de5:	0f 29 05 a4 d7 20 00 	movaps %xmm0,0x20d7a4(%rip)        # 613590 <out_wt_change+0x1f0>
		out_wt_cum_change[i][j] = 0.0;
  405dec:	0f 29 05 cd e0 20 00 	movaps %xmm0,0x20e0cd(%rip)        # 613ec0 <out_wt_cum_change>
  405df3:	0f 29 05 d6 e0 20 00 	movaps %xmm0,0x20e0d6(%rip)        # 613ed0 <out_wt_cum_change+0x10>
  405dfa:	0f 29 05 df e0 20 00 	movaps %xmm0,0x20e0df(%rip)        # 613ee0 <out_wt_cum_change+0x20>
  405e01:	0f 29 05 e8 e0 20 00 	movaps %xmm0,0x20e0e8(%rip)        # 613ef0 <out_wt_cum_change+0x30>
  405e08:	0f 29 05 f1 e0 20 00 	movaps %xmm0,0x20e0f1(%rip)        # 613f00 <out_wt_cum_change+0x40>
  405e0f:	0f 29 05 fa e0 20 00 	movaps %xmm0,0x20e0fa(%rip)        # 613f10 <out_wt_cum_change+0x50>
  405e16:	0f 29 05 03 e1 20 00 	movaps %xmm0,0x20e103(%rip)        # 613f20 <out_wt_cum_change+0x60>
  405e1d:	0f 29 05 0c e1 20 00 	movaps %xmm0,0x20e10c(%rip)        # 613f30 <out_wt_cum_change+0x70>
  405e24:	0f 29 05 15 e1 20 00 	movaps %xmm0,0x20e115(%rip)        # 613f40 <out_wt_cum_change+0x80>
  405e2b:	0f 29 05 1e e1 20 00 	movaps %xmm0,0x20e11e(%rip)        # 613f50 <out_wt_cum_change+0x90>
  405e32:	0f 29 05 27 e1 20 00 	movaps %xmm0,0x20e127(%rip)        # 613f60 <out_wt_cum_change+0xa0>
  405e39:	0f 29 05 30 e1 20 00 	movaps %xmm0,0x20e130(%rip)        # 613f70 <out_wt_cum_change+0xb0>
  405e40:	0f 29 05 39 e1 20 00 	movaps %xmm0,0x20e139(%rip)        # 613f80 <out_wt_cum_change+0xc0>
  405e47:	0f 29 05 42 e1 20 00 	movaps %xmm0,0x20e142(%rip)        # 613f90 <out_wt_cum_change+0xd0>
  405e4e:	0f 29 05 4b e1 20 00 	movaps %xmm0,0x20e14b(%rip)        # 613fa0 <out_wt_cum_change+0xe0>
  405e55:	0f 29 05 54 e1 20 00 	movaps %xmm0,0x20e154(%rip)        # 613fb0 <out_wt_cum_change+0xf0>
  405e5c:	0f 29 05 5d e1 20 00 	movaps %xmm0,0x20e15d(%rip)        # 613fc0 <out_wt_cum_change+0x100>
  405e63:	0f 29 05 66 e1 20 00 	movaps %xmm0,0x20e166(%rip)        # 613fd0 <out_wt_cum_change+0x110>
  405e6a:	0f 29 05 6f e1 20 00 	movaps %xmm0,0x20e16f(%rip)        # 613fe0 <out_wt_cum_change+0x120>
  405e71:	0f 29 05 78 e1 20 00 	movaps %xmm0,0x20e178(%rip)        # 613ff0 <out_wt_cum_change+0x130>
  405e78:	0f 29 05 81 e1 20 00 	movaps %xmm0,0x20e181(%rip)        # 614000 <out_wt_cum_change+0x140>
  405e7f:	0f 29 05 8a e1 20 00 	movaps %xmm0,0x20e18a(%rip)        # 614010 <out_wt_cum_change+0x150>
  405e86:	0f 29 05 93 e1 20 00 	movaps %xmm0,0x20e193(%rip)        # 614020 <out_wt_cum_change+0x160>
  405e8d:	0f 29 05 9c e1 20 00 	movaps %xmm0,0x20e19c(%rip)        # 614030 <out_wt_cum_change+0x170>
  405e94:	0f 29 05 a5 e1 20 00 	movaps %xmm0,0x20e1a5(%rip)        # 614040 <out_wt_cum_change+0x180>
  405e9b:	0f 29 05 ae e1 20 00 	movaps %xmm0,0x20e1ae(%rip)        # 614050 <out_wt_cum_change+0x190>
  405ea2:	0f 29 05 b7 e1 20 00 	movaps %xmm0,0x20e1b7(%rip)        # 614060 <out_wt_cum_change+0x1a0>
  405ea9:	0f 29 05 c0 e1 20 00 	movaps %xmm0,0x20e1c0(%rip)        # 614070 <out_wt_cum_change+0x1b0>
  405eb0:	0f 29 05 c9 e1 20 00 	movaps %xmm0,0x20e1c9(%rip)        # 614080 <out_wt_cum_change+0x1c0>
  405eb7:	0f 29 05 d2 e1 20 00 	movaps %xmm0,0x20e1d2(%rip)        # 614090 <out_wt_cum_change+0x1d0>
  405ebe:	0f 29 05 db e1 20 00 	movaps %xmm0,0x20e1db(%rip)        # 6140a0 <out_wt_cum_change+0x1e0>
  405ec5:	0f 29 05 e4 e1 20 00 	movaps %xmm0,0x20e1e4(%rip)        # 6140b0 <out_wt_cum_change+0x1f0>
elapsed=StartStopwatch();
while(nloops--)
{
	randomize_wts();
	zero_changes();
	iteration_count=1;
  405ecc:	c7 05 52 be 20 00 01 	movl   $0x1,0x20be52(%rip)        # 611d28 <iteration_count>
  405ed3:	00 00 00 
	learned = F;
  405ed6:	c7 05 a0 d4 20 00 00 	movl   $0x0,0x20d4a0(%rip)        # 613380 <learned>
  405edd:	00 00 00 
  405ee0:	8b 05 2a b5 20 00    	mov    0x20b52a(%rip),%eax        # 611410 <numpats>
	numpasses = 0;
  405ee6:	c7 05 b0 df 20 00 00 	movl   $0x0,0x20dfb0(%rip)        # 613ea0 <numpasses>
  405eed:	00 00 00 
	while (learned == F)
	{
		for (patt=0; patt<numpats; patt++)
  405ef0:	85 c0                	test   %eax,%eax
  405ef2:	0f 8e 87 15 00 00    	jle    40747f <DoNNetIteration+0x18df>
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
		/*
		** Zero it out for next pass accumulation.
		*/
		mid_wt_cum_change[i][j] = 0.0;
  405ef8:	66 45 0f ef db       	pxor   %xmm11,%xmm11
  405efd:	bd 78 1d 61 00       	mov    $0x611d78,%ebp
	iteration_count=1;
	learned = F;
	numpasses = 0;
	while (learned == F)
	{
		for (patt=0; patt<numpats; patt++)
  405f02:	31 db                	xor    %ebx,%ebx
  405f04:	f2 44 0f 10 25 a3 83 	movsd  0x83a3(%rip),%xmm12        # 40e2b0 <jtable.3055+0x1520>
  405f0b:	00 00 
  405f0d:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  405f14:	00 00 
  405f16:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%rsp)
  405f1d:	00 
		{
			worst_error = 0.0;      /* reset this every pass through data */
  405f1e:	48 c7 05 97 b3 20 00 	movq   $0x0,0x20b397(%rip)        # 6112c0 <worst_error>
  405f25:	00 00 00 00 
  405f29:	41 b8 a0 35 61 00    	mov    $0x6135a0,%r8d
  405f2f:	45 31 d2             	xor    %r10d,%r10d
**/
static void move_wt_changes()
{
int i,j;

for (i = 0; i<MID_SIZE; i++)
  405f32:	45 31 c9             	xor    %r9d,%r9d
  405f35:	0f 1f 00             	nopl   (%rax)
  405f38:	41 f6 c0 08          	test   $0x8,%r8b
  405f3c:	0f 84 16 14 00 00    	je     407358 <DoNNetIteration+0x17b8>
	for (j = 0; j<IN_SIZE; j++)
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
  405f42:	f2 41 0f 10 00       	movsd  (%r8),%xmm0
static void move_wt_changes()
{
int i,j;

for (i = 0; i<MID_SIZE; i++)
	for (j = 0; j<IN_SIZE; j++)
  405f47:	bf 01 00 00 00       	mov    $0x1,%edi
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
		/*
		** Zero it out for next pass accumulation.
		*/
		mid_wt_cum_change[i][j] = 0.0;
  405f4c:	49 c7 00 00 00 00 00 	movq   $0x0,(%r8)
  405f53:	b8 01 00 00 00       	mov    $0x1,%eax
  405f58:	41 bb 22 00 00 00    	mov    $0x22,%r11d
int i,j;

for (i = 0; i<MID_SIZE; i++)
	for (j = 0; j<IN_SIZE; j++)
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
  405f5e:	f2 42 0f 11 04 d5 c0 	movsd  %xmm0,0x612ac0(,%r10,8)
  405f65:	2a 61 00 
  405f68:	49 8d 34 02          	lea    (%r10,%rax,1),%rsi
	iteration_count=1;
	learned = F;
	numpasses = 0;
	while (learned == F)
	{
		for (patt=0; patt<numpats; patt++)
  405f6c:	31 d2                	xor    %edx,%edx
  405f6e:	31 c0                	xor    %eax,%eax
  405f70:	48 c1 e6 03          	shl    $0x3,%rsi
  405f74:	48 8d 8e a0 35 61 00 	lea    0x6135a0(%rsi),%rcx
  405f7b:	48 81 c6 c0 2a 61 00 	add    $0x612ac0,%rsi
  405f82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
int i,j;

for (i = 0; i<MID_SIZE; i++)
	for (j = 0; j<IN_SIZE; j++)
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
  405f88:	66 0f 28 04 01       	movapd (%rcx,%rax,1),%xmm0
  405f8d:	83 c2 01             	add    $0x1,%edx
  405f90:	0f 11 04 06          	movups %xmm0,(%rsi,%rax,1)
		/*
		** Zero it out for next pass accumulation.
		*/
		mid_wt_cum_change[i][j] = 0.0;
  405f94:	44 0f 29 1c 01       	movaps %xmm11,(%rcx,%rax,1)
  405f99:	48 83 c0 10          	add    $0x10,%rax
  405f9d:	83 fa 10             	cmp    $0x10,%edx
  405fa0:	76 e6                	jbe    405f88 <DoNNetIteration+0x3e8>
  405fa2:	41 83 fb 22          	cmp    $0x22,%r11d
  405fa6:	8d 47 22             	lea    0x22(%rdi),%eax
  405fa9:	74 2e                	je     405fd9 <DoNNetIteration+0x439>
int i,j;

for (i = 0; i<MID_SIZE; i++)
	for (j = 0; j<IN_SIZE; j++)
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
  405fab:	49 63 d1             	movslq %r9d,%rdx
  405fae:	48 98                	cltq   
  405fb0:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
  405fb4:	48 8d 04 d0          	lea    (%rax,%rdx,8),%rax
  405fb8:	48 29 d0             	sub    %rdx,%rax
  405fbb:	f2 0f 10 04 c5 a0 35 	movsd  0x6135a0(,%rax,8),%xmm0
  405fc2:	61 00 
		/*
		** Zero it out for next pass accumulation.
		*/
		mid_wt_cum_change[i][j] = 0.0;
  405fc4:	48 c7 04 c5 a0 35 61 	movq   $0x0,0x6135a0(,%rax,8)
  405fcb:	00 00 00 00 00 
int i,j;

for (i = 0; i<MID_SIZE; i++)
	for (j = 0; j<IN_SIZE; j++)
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
  405fd0:	f2 0f 11 04 c5 c0 2a 	movsd  %xmm0,0x612ac0(,%rax,8)
  405fd7:	61 00 
**/
static void move_wt_changes()
{
int i,j;

for (i = 0; i<MID_SIZE; i++)
  405fd9:	41 83 c1 01          	add    $0x1,%r9d
  405fdd:	49 81 c0 18 01 00 00 	add    $0x118,%r8
  405fe4:	49 83 c2 23          	add    $0x23,%r10
  405fe8:	41 83 f9 08          	cmp    $0x8,%r9d
  405fec:	0f 85 46 ff ff ff    	jne    405f38 <DoNNetIteration+0x398>
	}

for (i = 0; i<OUT_SIZE; i++)
	for (j=0; j<MID_SIZE; j++)
	{
		out_wt_change[i][j] = out_wt_cum_change[i][j];
  405ff2:	66 0f 28 05 c6 de 20 	movapd 0x20dec6(%rip),%xmm0        # 613ec0 <out_wt_cum_change>
  405ff9:	00 
		out_wt_cum_change[i][j] = 0.0;
  405ffa:	66 0f ef e4          	pxor   %xmm4,%xmm4
  405ffe:	4c 8d 2c dd 00 00 00 	lea    0x0(,%rbx,8),%r13
  406005:	00 
  406006:	41 be 60 3e 61 00    	mov    $0x613e60,%r14d
  40600c:	45 31 e4             	xor    %r12d,%r12d
	}

for (i = 0; i<OUT_SIZE; i++)
	for (j=0; j<MID_SIZE; j++)
	{
		out_wt_change[i][j] = out_wt_cum_change[i][j];
  40600f:	0f 29 05 8a d3 20 00 	movaps %xmm0,0x20d38a(%rip)        # 6133a0 <out_wt_change>
  406016:	66 0f 28 05 b2 de 20 	movapd 0x20deb2(%rip),%xmm0        # 613ed0 <out_wt_cum_change+0x10>
  40601d:	00 
  40601e:	0f 29 05 8b d3 20 00 	movaps %xmm0,0x20d38b(%rip)        # 6133b0 <out_wt_change+0x10>
  406025:	66 0f 28 05 b3 de 20 	movapd 0x20deb3(%rip),%xmm0        # 613ee0 <out_wt_cum_change+0x20>
  40602c:	00 
  40602d:	0f 29 05 8c d3 20 00 	movaps %xmm0,0x20d38c(%rip)        # 6133c0 <out_wt_change+0x20>
  406034:	66 0f 28 05 b4 de 20 	movapd 0x20deb4(%rip),%xmm0        # 613ef0 <out_wt_cum_change+0x30>
  40603b:	00 
  40603c:	0f 29 05 8d d3 20 00 	movaps %xmm0,0x20d38d(%rip)        # 6133d0 <out_wt_change+0x30>
  406043:	66 0f 28 05 b5 de 20 	movapd 0x20deb5(%rip),%xmm0        # 613f00 <out_wt_cum_change+0x40>
  40604a:	00 
  40604b:	0f 29 05 8e d3 20 00 	movaps %xmm0,0x20d38e(%rip)        # 6133e0 <out_wt_change+0x40>
  406052:	66 0f 28 05 b6 de 20 	movapd 0x20deb6(%rip),%xmm0        # 613f10 <out_wt_cum_change+0x50>
  406059:	00 
  40605a:	0f 29 05 8f d3 20 00 	movaps %xmm0,0x20d38f(%rip)        # 6133f0 <out_wt_change+0x50>
  406061:	66 0f 28 05 b7 de 20 	movapd 0x20deb7(%rip),%xmm0        # 613f20 <out_wt_cum_change+0x60>
  406068:	00 
  406069:	0f 29 05 90 d3 20 00 	movaps %xmm0,0x20d390(%rip)        # 613400 <out_wt_change+0x60>
  406070:	66 0f 28 05 b8 de 20 	movapd 0x20deb8(%rip),%xmm0        # 613f30 <out_wt_cum_change+0x70>
  406077:	00 
  406078:	0f 29 05 91 d3 20 00 	movaps %xmm0,0x20d391(%rip)        # 613410 <out_wt_change+0x70>
  40607f:	66 0f 28 05 b9 de 20 	movapd 0x20deb9(%rip),%xmm0        # 613f40 <out_wt_cum_change+0x80>
  406086:	00 
  406087:	0f 29 05 92 d3 20 00 	movaps %xmm0,0x20d392(%rip)        # 613420 <out_wt_change+0x80>
  40608e:	66 0f 28 05 ba de 20 	movapd 0x20deba(%rip),%xmm0        # 613f50 <out_wt_cum_change+0x90>
  406095:	00 
  406096:	0f 29 05 93 d3 20 00 	movaps %xmm0,0x20d393(%rip)        # 613430 <out_wt_change+0x90>
  40609d:	66 0f 28 05 bb de 20 	movapd 0x20debb(%rip),%xmm0        # 613f60 <out_wt_cum_change+0xa0>
  4060a4:	00 
  4060a5:	0f 29 05 94 d3 20 00 	movaps %xmm0,0x20d394(%rip)        # 613440 <out_wt_change+0xa0>
  4060ac:	66 0f 28 05 bc de 20 	movapd 0x20debc(%rip),%xmm0        # 613f70 <out_wt_cum_change+0xb0>
  4060b3:	00 
  4060b4:	0f 29 05 95 d3 20 00 	movaps %xmm0,0x20d395(%rip)        # 613450 <out_wt_change+0xb0>
  4060bb:	66 0f 28 05 bd de 20 	movapd 0x20debd(%rip),%xmm0        # 613f80 <out_wt_cum_change+0xc0>
  4060c2:	00 
  4060c3:	0f 29 05 96 d3 20 00 	movaps %xmm0,0x20d396(%rip)        # 613460 <out_wt_change+0xc0>
  4060ca:	66 0f 28 05 be de 20 	movapd 0x20debe(%rip),%xmm0        # 613f90 <out_wt_cum_change+0xd0>
  4060d1:	00 
  4060d2:	0f 29 05 97 d3 20 00 	movaps %xmm0,0x20d397(%rip)        # 613470 <out_wt_change+0xd0>
  4060d9:	66 0f 28 05 bf de 20 	movapd 0x20debf(%rip),%xmm0        # 613fa0 <out_wt_cum_change+0xe0>
  4060e0:	00 
  4060e1:	0f 29 05 98 d3 20 00 	movaps %xmm0,0x20d398(%rip)        # 613480 <out_wt_change+0xe0>
  4060e8:	66 0f 28 05 c0 de 20 	movapd 0x20dec0(%rip),%xmm0        # 613fb0 <out_wt_cum_change+0xf0>
  4060ef:	00 
  4060f0:	0f 29 05 99 d3 20 00 	movaps %xmm0,0x20d399(%rip)        # 613490 <out_wt_change+0xf0>
  4060f7:	66 0f 28 05 c1 de 20 	movapd 0x20dec1(%rip),%xmm0        # 613fc0 <out_wt_cum_change+0x100>
  4060fe:	00 
  4060ff:	0f 29 05 9a d3 20 00 	movaps %xmm0,0x20d39a(%rip)        # 6134a0 <out_wt_change+0x100>
  406106:	66 0f 28 05 c2 de 20 	movapd 0x20dec2(%rip),%xmm0        # 613fd0 <out_wt_cum_change+0x110>
  40610d:	00 
  40610e:	0f 29 05 9b d3 20 00 	movaps %xmm0,0x20d39b(%rip)        # 6134b0 <out_wt_change+0x110>
  406115:	66 0f 28 05 c3 de 20 	movapd 0x20dec3(%rip),%xmm0        # 613fe0 <out_wt_cum_change+0x120>
  40611c:	00 
  40611d:	0f 29 05 9c d3 20 00 	movaps %xmm0,0x20d39c(%rip)        # 6134c0 <out_wt_change+0x120>
  406124:	66 0f 28 05 c4 de 20 	movapd 0x20dec4(%rip),%xmm0        # 613ff0 <out_wt_cum_change+0x130>
  40612b:	00 
  40612c:	0f 29 05 9d d3 20 00 	movaps %xmm0,0x20d39d(%rip)        # 6134d0 <out_wt_change+0x130>
  406133:	66 0f 28 05 c5 de 20 	movapd 0x20dec5(%rip),%xmm0        # 614000 <out_wt_cum_change+0x140>
  40613a:	00 
  40613b:	0f 29 05 9e d3 20 00 	movaps %xmm0,0x20d39e(%rip)        # 6134e0 <out_wt_change+0x140>
  406142:	66 0f 28 05 c6 de 20 	movapd 0x20dec6(%rip),%xmm0        # 614010 <out_wt_cum_change+0x150>
  406149:	00 
  40614a:	0f 29 05 9f d3 20 00 	movaps %xmm0,0x20d39f(%rip)        # 6134f0 <out_wt_change+0x150>
  406151:	66 0f 28 05 c7 de 20 	movapd 0x20dec7(%rip),%xmm0        # 614020 <out_wt_cum_change+0x160>
  406158:	00 
  406159:	0f 29 05 a0 d3 20 00 	movaps %xmm0,0x20d3a0(%rip)        # 613500 <out_wt_change+0x160>
  406160:	66 0f 28 05 c8 de 20 	movapd 0x20dec8(%rip),%xmm0        # 614030 <out_wt_cum_change+0x170>
  406167:	00 
  406168:	0f 29 05 a1 d3 20 00 	movaps %xmm0,0x20d3a1(%rip)        # 613510 <out_wt_change+0x170>
  40616f:	66 0f 28 05 c9 de 20 	movapd 0x20dec9(%rip),%xmm0        # 614040 <out_wt_cum_change+0x180>
  406176:	00 
  406177:	0f 29 05 a2 d3 20 00 	movaps %xmm0,0x20d3a2(%rip)        # 613520 <out_wt_change+0x180>
  40617e:	66 0f 28 05 ca de 20 	movapd 0x20deca(%rip),%xmm0        # 614050 <out_wt_cum_change+0x190>
  406185:	00 
  406186:	0f 29 05 a3 d3 20 00 	movaps %xmm0,0x20d3a3(%rip)        # 613530 <out_wt_change+0x190>
  40618d:	66 0f 28 05 cb de 20 	movapd 0x20decb(%rip),%xmm0        # 614060 <out_wt_cum_change+0x1a0>
  406194:	00 
  406195:	0f 29 05 a4 d3 20 00 	movaps %xmm0,0x20d3a4(%rip)        # 613540 <out_wt_change+0x1a0>
  40619c:	66 0f 28 05 cc de 20 	movapd 0x20decc(%rip),%xmm0        # 614070 <out_wt_cum_change+0x1b0>
  4061a3:	00 
  4061a4:	0f 29 05 a5 d3 20 00 	movaps %xmm0,0x20d3a5(%rip)        # 613550 <out_wt_change+0x1b0>
  4061ab:	66 0f 28 05 cd de 20 	movapd 0x20decd(%rip),%xmm0        # 614080 <out_wt_cum_change+0x1c0>
  4061b2:	00 
  4061b3:	0f 29 05 a6 d3 20 00 	movaps %xmm0,0x20d3a6(%rip)        # 613560 <out_wt_change+0x1c0>
  4061ba:	66 0f 28 05 ce de 20 	movapd 0x20dece(%rip),%xmm0        # 614090 <out_wt_cum_change+0x1d0>
  4061c1:	00 
  4061c2:	0f 29 05 a7 d3 20 00 	movaps %xmm0,0x20d3a7(%rip)        # 613570 <out_wt_change+0x1d0>
  4061c9:	66 0f 28 05 cf de 20 	movapd 0x20decf(%rip),%xmm0        # 6140a0 <out_wt_cum_change+0x1e0>
  4061d0:	00 
  4061d1:	0f 29 05 a8 d3 20 00 	movaps %xmm0,0x20d3a8(%rip)        # 613580 <out_wt_change+0x1e0>
  4061d8:	66 0f 28 05 d0 de 20 	movapd 0x20ded0(%rip),%xmm0        # 6140b0 <out_wt_cum_change+0x1f0>
  4061df:	00 
  4061e0:	0f 29 05 a9 d3 20 00 	movaps %xmm0,0x20d3a9(%rip)        # 613590 <out_wt_change+0x1f0>
		out_wt_cum_change[i][j] = 0.0;
  4061e7:	0f 29 25 d2 dc 20 00 	movaps %xmm4,0x20dcd2(%rip)        # 613ec0 <out_wt_cum_change>
  4061ee:	0f 29 25 db dc 20 00 	movaps %xmm4,0x20dcdb(%rip)        # 613ed0 <out_wt_cum_change+0x10>
  4061f5:	0f 29 25 e4 dc 20 00 	movaps %xmm4,0x20dce4(%rip)        # 613ee0 <out_wt_cum_change+0x20>
  4061fc:	0f 29 25 ed dc 20 00 	movaps %xmm4,0x20dced(%rip)        # 613ef0 <out_wt_cum_change+0x30>
  406203:	0f 29 25 f6 dc 20 00 	movaps %xmm4,0x20dcf6(%rip)        # 613f00 <out_wt_cum_change+0x40>
  40620a:	0f 29 25 ff dc 20 00 	movaps %xmm4,0x20dcff(%rip)        # 613f10 <out_wt_cum_change+0x50>
  406211:	0f 29 25 08 dd 20 00 	movaps %xmm4,0x20dd08(%rip)        # 613f20 <out_wt_cum_change+0x60>
  406218:	0f 29 25 11 dd 20 00 	movaps %xmm4,0x20dd11(%rip)        # 613f30 <out_wt_cum_change+0x70>
  40621f:	0f 29 25 1a dd 20 00 	movaps %xmm4,0x20dd1a(%rip)        # 613f40 <out_wt_cum_change+0x80>
  406226:	0f 29 25 23 dd 20 00 	movaps %xmm4,0x20dd23(%rip)        # 613f50 <out_wt_cum_change+0x90>
  40622d:	0f 29 25 2c dd 20 00 	movaps %xmm4,0x20dd2c(%rip)        # 613f60 <out_wt_cum_change+0xa0>
  406234:	0f 29 25 35 dd 20 00 	movaps %xmm4,0x20dd35(%rip)        # 613f70 <out_wt_cum_change+0xb0>
  40623b:	0f 29 25 3e dd 20 00 	movaps %xmm4,0x20dd3e(%rip)        # 613f80 <out_wt_cum_change+0xc0>
  406242:	0f 29 25 47 dd 20 00 	movaps %xmm4,0x20dd47(%rip)        # 613f90 <out_wt_cum_change+0xd0>
  406249:	0f 29 25 50 dd 20 00 	movaps %xmm4,0x20dd50(%rip)        # 613fa0 <out_wt_cum_change+0xe0>
  406250:	0f 29 25 59 dd 20 00 	movaps %xmm4,0x20dd59(%rip)        # 613fb0 <out_wt_cum_change+0xf0>
  406257:	0f 29 25 62 dd 20 00 	movaps %xmm4,0x20dd62(%rip)        # 613fc0 <out_wt_cum_change+0x100>
  40625e:	0f 29 25 6b dd 20 00 	movaps %xmm4,0x20dd6b(%rip)        # 613fd0 <out_wt_cum_change+0x110>
  406265:	0f 29 25 74 dd 20 00 	movaps %xmm4,0x20dd74(%rip)        # 613fe0 <out_wt_cum_change+0x120>
  40626c:	0f 29 25 7d dd 20 00 	movaps %xmm4,0x20dd7d(%rip)        # 613ff0 <out_wt_cum_change+0x130>
  406273:	0f 29 25 86 dd 20 00 	movaps %xmm4,0x20dd86(%rip)        # 614000 <out_wt_cum_change+0x140>
  40627a:	0f 29 25 8f dd 20 00 	movaps %xmm4,0x20dd8f(%rip)        # 614010 <out_wt_cum_change+0x150>
  406281:	0f 29 25 98 dd 20 00 	movaps %xmm4,0x20dd98(%rip)        # 614020 <out_wt_cum_change+0x160>
  406288:	0f 29 25 a1 dd 20 00 	movaps %xmm4,0x20dda1(%rip)        # 614030 <out_wt_cum_change+0x170>
  40628f:	0f 29 25 aa dd 20 00 	movaps %xmm4,0x20ddaa(%rip)        # 614040 <out_wt_cum_change+0x180>
  406296:	0f 29 25 b3 dd 20 00 	movaps %xmm4,0x20ddb3(%rip)        # 614050 <out_wt_cum_change+0x190>
  40629d:	0f 29 25 bc dd 20 00 	movaps %xmm4,0x20ddbc(%rip)        # 614060 <out_wt_cum_change+0x1a0>
  4062a4:	0f 29 25 c5 dd 20 00 	movaps %xmm4,0x20ddc5(%rip)        # 614070 <out_wt_cum_change+0x1b0>
  4062ab:	0f 29 25 ce dd 20 00 	movaps %xmm4,0x20ddce(%rip)        # 614080 <out_wt_cum_change+0x1c0>
  4062b2:	0f 29 25 d7 dd 20 00 	movaps %xmm4,0x20ddd7(%rip)        # 614090 <out_wt_cum_change+0x1d0>
  4062b9:	0f 29 25 e0 dd 20 00 	movaps %xmm4,0x20dde0(%rip)        # 6140a0 <out_wt_cum_change+0x1e0>
  4062c0:	0f 29 25 e9 dd 20 00 	movaps %xmm4,0x20dde9(%rip)        # 6140b0 <out_wt_cum_change+0x1f0>
  4062c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4062ce:	00 00 
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
		/*
		** Zero it out for next pass accumulation.
		*/
		mid_wt_cum_change[i][j] = 0.0;
  4062d0:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4062d4:	31 c0                	xor    %eax,%eax
  4062d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4062dd:	00 00 00 
for (neurode=0;neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<IN_SIZE; i++)
	{       /* compute weighted sum of input signals */
		sum += mid_wts[neurode][i]*in_pats[patt][i];
  4062e0:	f2 41 0f 10 8c 04 60 	movsd  0x611460(%r12,%rax,1),%xmm1
  4062e7:	14 61 00 
  4062ea:	f2 41 0f 59 8c 05 c0 	mulsd  0x611fc0(%r13,%rax,1),%xmm1
  4062f1:	1f 61 00 
  4062f4:	48 83 c0 08          	add    $0x8,%rax
int     neurode, i;

for (neurode=0;neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<IN_SIZE; i++)
  4062f8:	48 3d 18 01 00 00    	cmp    $0x118,%rax
	{       /* compute weighted sum of input signals */
		sum += mid_wts[neurode][i]*in_pats[patt][i];
  4062fe:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
int     neurode, i;

for (neurode=0;neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<IN_SIZE; i++)
  406302:	75 dc                	jne    4062e0 <DoNNetIteration+0x740>
		sum += mid_wts[neurode][i]*in_pats[patt][i];
	}
	/*
	** apply sigmoid function f(x) = 1/(1+exp(-x)) to weighted sum
	*/
	sum = 1.0/(1.0+exp(-sum));
  406304:	66 0f 57 05 f4 7f 00 	xorpd  0x7ff4(%rip),%xmm0        # 40e300 <jtable.3055+0x1570>
  40630b:	00 
  40630c:	f2 44 0f 11 24 24    	movsd  %xmm12,(%rsp)
  406312:	44 0f 29 6c 24 20    	movaps %xmm13,0x20(%rsp)
  406318:	49 81 c4 18 01 00 00 	add    $0x118,%r12
  40631f:	49 83 c6 08          	add    $0x8,%r14
  406323:	44 0f 29 5c 24 10    	movaps %xmm11,0x10(%rsp)
  406329:	e8 92 ab ff ff       	callq  400ec0 <exp@plt>
	mid_out[neurode] = sum;
  40632e:	f2 0f 58 05 3a 7a 00 	addsd  0x7a3a(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  406335:	00 
  406336:	f2 0f 10 25 32 7a 00 	movsd  0x7a32(%rip),%xmm4        # 40dd70 <jtable.3055+0xfe0>
  40633d:	00 
static void  do_mid_forward(int patt)
{
double  sum;
int     neurode, i;

for (neurode=0;neurode<MID_SIZE; neurode++)
  40633e:	f2 44 0f 10 24 24    	movsd  (%rsp),%xmm12
  406344:	66 44 0f 28 5c 24 10 	movapd 0x10(%rsp),%xmm11
  40634b:	66 44 0f 28 6c 24 20 	movapd 0x20(%rsp),%xmm13
	}
	/*
	** apply sigmoid function f(x) = 1/(1+exp(-x)) to weighted sum
	*/
	sum = 1.0/(1.0+exp(-sum));
	mid_out[neurode] = sum;
  406352:	f2 0f 5e e0          	divsd  %xmm0,%xmm4
  406356:	f2 41 0f 11 66 f8    	movsd  %xmm4,-0x8(%r14)
static void  do_mid_forward(int patt)
{
double  sum;
int     neurode, i;

for (neurode=0;neurode<MID_SIZE; neurode++)
  40635c:	49 81 fc c0 08 00 00 	cmp    $0x8c0,%r12
  406363:	0f 85 67 ff ff ff    	jne    4062d0 <DoNNetIteration+0x730>
  406369:	41 bd e0 12 61 00    	mov    $0x6112e0,%r13d
  40636f:	41 bc e0 40 61 00    	mov    $0x6140e0,%r12d
  406375:	0f 1f 00             	nopl   (%rax)
	for (i=0; i<MID_SIZE; i++)
	{       /*
		** compute weighted sum of input signals
		** from middle layer
		*/
		sum += out_wts[neurode][i]*mid_out[i];
  406378:	f2 41 0f 10 14 24    	movsd  (%r12),%xmm2
  40637e:	49 83 c4 40          	add    $0x40,%r12
  406382:	49 83 c5 08          	add    $0x8,%r13
  406386:	f2 41 0f 10 4c 24 c8 	movsd  -0x38(%r12),%xmm1
  40638d:	f2 0f 59 15 cb da 20 	mulsd  0x20dacb(%rip),%xmm2        # 613e60 <mid_out>
  406394:	00 
  406395:	f2 44 0f 11 24 24    	movsd  %xmm12,(%rsp)
  40639b:	f2 0f 59 0d c5 da 20 	mulsd  0x20dac5(%rip),%xmm1        # 613e68 <mid_out+0x8>
  4063a2:	00 
  4063a3:	66 0f ef db          	pxor   %xmm3,%xmm3
  4063a7:	f2 41 0f 10 44 24 d0 	movsd  -0x30(%r12),%xmm0
  4063ae:	44 0f 29 6c 24 20    	movaps %xmm13,0x20(%rsp)
  4063b4:	f2 0f 59 05 b4 da 20 	mulsd  0x20dab4(%rip),%xmm0        # 613e70 <mid_out+0x10>
  4063bb:	00 
  4063bc:	f2 0f 58 da          	addsd  %xmm2,%xmm3
  4063c0:	66 0f 28 d1          	movapd %xmm1,%xmm2
  4063c4:	f2 41 0f 10 4c 24 e8 	movsd  -0x18(%r12),%xmm1
  4063cb:	44 0f 29 5c 24 10    	movaps %xmm11,0x10(%rsp)
  4063d1:	f2 0f 58 d3          	addsd  %xmm3,%xmm2
  4063d5:	f2 0f 59 0d ab da 20 	mulsd  0x20daab(%rip),%xmm1        # 613e88 <mid_out+0x28>
  4063dc:	00 
  4063dd:	f2 41 0f 10 5c 24 d8 	movsd  -0x28(%r12),%xmm3
  4063e4:	f2 0f 58 c2          	addsd  %xmm2,%xmm0
  4063e8:	f2 41 0f 10 54 24 e0 	movsd  -0x20(%r12),%xmm2
  4063ef:	f2 0f 59 1d 81 da 20 	mulsd  0x20da81(%rip),%xmm3        # 613e78 <mid_out+0x18>
  4063f6:	00 
  4063f7:	f2 0f 59 15 81 da 20 	mulsd  0x20da81(%rip),%xmm2        # 613e80 <mid_out+0x20>
  4063fe:	00 
  4063ff:	f2 0f 58 d8          	addsd  %xmm0,%xmm3
  406403:	66 0f 28 c3          	movapd %xmm3,%xmm0
  406407:	66 0f 28 da          	movapd %xmm2,%xmm3
  40640b:	66 0f 28 d1          	movapd %xmm1,%xmm2
  40640f:	f2 0f 58 d8          	addsd  %xmm0,%xmm3
  406413:	f2 41 0f 10 44 24 f0 	movsd  -0x10(%r12),%xmm0
  40641a:	f2 0f 59 05 6e da 20 	mulsd  0x20da6e(%rip),%xmm0        # 613e90 <mid_out+0x30>
  406421:	00 
  406422:	f2 0f 58 d3          	addsd  %xmm3,%xmm2
  406426:	f2 0f 58 c2          	addsd  %xmm2,%xmm0
  40642a:	66 0f 28 c8          	movapd %xmm0,%xmm1
	}
	/*
	** Apply f(x) = 1/(1+exp(-x)) to weighted input
	*/
	sum = 1.0/(1.0+exp(-sum));
  40642e:	f2 41 0f 10 44 24 f8 	movsd  -0x8(%r12),%xmm0
  406435:	f2 0f 59 05 5b da 20 	mulsd  0x20da5b(%rip),%xmm0        # 613e98 <mid_out+0x38>
  40643c:	00 
  40643d:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  406441:	66 0f 57 05 b7 7e 00 	xorpd  0x7eb7(%rip),%xmm0        # 40e300 <jtable.3055+0x1570>
  406448:	00 
  406449:	e8 72 aa ff ff       	callq  400ec0 <exp@plt>
	out_out[neurode] = sum;
  40644e:	f2 0f 58 05 1a 79 00 	addsd  0x791a(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  406455:	00 
  406456:	f2 0f 10 35 12 79 00 	movsd  0x7912(%rip),%xmm6        # 40dd70 <jtable.3055+0xfe0>
  40645d:	00 
static void  do_out_forward()
{
double sum;
int neurode, i;

for (neurode=0; neurode<OUT_SIZE; neurode++)
  40645e:	b8 e0 42 61 00       	mov    $0x6142e0,%eax
  406463:	f2 44 0f 10 24 24    	movsd  (%rsp),%xmm12
  406469:	66 44 0f 28 5c 24 10 	movapd 0x10(%rsp),%xmm11
  406470:	66 44 0f 28 6c 24 20 	movapd 0x20(%rsp),%xmm13
	}
	/*
	** Apply f(x) = 1/(1+exp(-x)) to weighted input
	*/
	sum = 1.0/(1.0+exp(-sum));
	out_out[neurode] = sum;
  406477:	f2 0f 5e f0          	divsd  %xmm0,%xmm6
  40647b:	f2 41 0f 11 75 f8    	movsd  %xmm6,-0x8(%r13)
static void  do_out_forward()
{
double sum;
int neurode, i;

for (neurode=0; neurode<OUT_SIZE; neurode++)
  406481:	4c 39 e0             	cmp    %r12,%rax
  406484:	0f 85 ee fe ff ff    	jne    406378 <DoNNetIteration+0x7d8>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40648a:	f2 0f 10 65 c8       	movsd  -0x38(%rbp),%xmm4
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  40648f:	66 0f ef f6          	pxor   %xmm6,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406493:	f2 0f 5c 25 45 ae 20 	subsd  0x20ae45(%rip),%xmm4        # 6112e0 <out_out>
  40649a:	00 
  40649b:	66 0f 28 c6          	movapd %xmm6,%xmm0
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  40649f:	66 0f 2e f4          	ucomisd %xmm4,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4064a3:	f2 0f 11 25 75 af 20 	movsd  %xmm4,0x20af75(%rip)        # 611420 <out_error>
  4064aa:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4064ab:	0f 87 11 0f 00 00    	ja     4073c2 <DoNNetIteration+0x1822>
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
		if (error > tot_error)
  4064b1:	66 0f 28 ec          	movapd %xmm4,%xmm5
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  4064b5:	f2 0f 58 c4          	addsd  %xmm4,%xmm0
		if (error > tot_error)
  4064b9:	f2 0f 5f ee          	maxsd  %xmm6,%xmm5

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4064bd:	f2 0f 10 5d d0       	movsd  -0x30(%rbp),%xmm3
  4064c2:	f2 0f 5c 1d 1e ae 20 	subsd  0x20ae1e(%rip),%xmm3        # 6112e8 <out_out+0x8>
  4064c9:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4064ca:	66 0f 2e f3          	ucomisd %xmm3,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4064ce:	f2 0f 11 1d 52 af 20 	movsd  %xmm3,0x20af52(%rip)        # 611428 <out_error+0x8>
  4064d5:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4064d6:	0f 87 c9 0e 00 00    	ja     4073a5 <DoNNetIteration+0x1805>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4064dc:	66 0f 28 f3          	movapd %xmm3,%xmm6
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  4064e0:	f2 0f 58 c3          	addsd  %xmm3,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4064e4:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  4064e8:	66 0f 28 ee          	movapd %xmm6,%xmm5
  4064ec:	66 0f ef f6          	pxor   %xmm6,%xmm6
  4064f0:	f2 0f 10 55 d8       	movsd  -0x28(%rbp),%xmm2
  4064f5:	f2 0f 5c 15 f3 ad 20 	subsd  0x20adf3(%rip),%xmm2        # 6112f0 <out_out+0x10>
  4064fc:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4064fd:	66 0f 2e f2          	ucomisd %xmm2,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406501:	f2 0f 11 15 27 af 20 	movsd  %xmm2,0x20af27(%rip)        # 611430 <out_error+0x10>
  406508:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406509:	0f 87 2b 0f 00 00    	ja     40743a <DoNNetIteration+0x189a>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40650f:	66 0f 28 f2          	movapd %xmm2,%xmm6
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  406513:	f2 0f 58 c2          	addsd  %xmm2,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406517:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  40651b:	66 0f 28 ee          	movapd %xmm6,%xmm5
  40651f:	66 0f ef f6          	pxor   %xmm6,%xmm6
  406523:	f2 0f 10 4d e0       	movsd  -0x20(%rbp),%xmm1
  406528:	f2 0f 5c 0d c8 ad 20 	subsd  0x20adc8(%rip),%xmm1        # 6112f8 <out_out+0x18>
  40652f:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406530:	66 0f 2e f1          	ucomisd %xmm1,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406534:	f2 0f 11 0d fc ae 20 	movsd  %xmm1,0x20aefc(%rip)        # 611438 <out_error+0x18>
  40653b:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  40653c:	0f 87 db 0e 00 00    	ja     40741d <DoNNetIteration+0x187d>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406542:	66 0f 28 f1          	movapd %xmm1,%xmm6
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  406546:	f2 0f 58 c1          	addsd  %xmm1,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40654a:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  40654e:	66 0f 28 ee          	movapd %xmm6,%xmm5
  406552:	f2 44 0f 10 4d e8    	movsd  -0x18(%rbp),%xmm9
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406558:	66 0f ef f6          	pxor   %xmm6,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40655c:	f2 44 0f 5c 0d 9b ad 	subsd  0x20ad9b(%rip),%xmm9        # 611300 <out_out+0x20>
  406563:	20 00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406565:	66 41 0f 2e f1       	ucomisd %xmm9,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40656a:	f2 44 0f 11 0d cd ae 	movsd  %xmm9,0x20aecd(%rip)        # 611440 <out_error+0x20>
  406571:	20 00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406573:	0f 87 85 0e 00 00    	ja     4073fe <DoNNetIteration+0x185e>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406579:	66 41 0f 28 f1       	movapd %xmm9,%xmm6
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  40657e:	f2 41 0f 58 c1       	addsd  %xmm9,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406583:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  406587:	66 0f 28 ee          	movapd %xmm6,%xmm5
  40658b:	f2 44 0f 10 45 f0    	movsd  -0x10(%rbp),%xmm8
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406591:	66 0f ef f6          	pxor   %xmm6,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406595:	f2 44 0f 5c 05 6a ad 	subsd  0x20ad6a(%rip),%xmm8        # 611308 <out_out+0x28>
  40659c:	20 00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  40659e:	66 41 0f 2e f0       	ucomisd %xmm8,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065a3:	f2 44 0f 11 05 9c ae 	movsd  %xmm8,0x20ae9c(%rip)        # 611448 <out_error+0x28>
  4065aa:	20 00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4065ac:	0f 87 2d 0e 00 00    	ja     4073df <DoNNetIteration+0x183f>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065b2:	66 41 0f 28 f0       	movapd %xmm8,%xmm6
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  4065b7:	f2 41 0f 58 c0       	addsd  %xmm8,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065bc:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  4065c0:	66 0f 28 ee          	movapd %xmm6,%xmm5
  4065c4:	f2 0f 10 7d f8       	movsd  -0x8(%rbp),%xmm7
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4065c9:	66 0f ef f6          	pxor   %xmm6,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065cd:	f2 0f 5c 3d 3b ad 20 	subsd  0x20ad3b(%rip),%xmm7        # 611310 <out_out+0x30>
  4065d4:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4065d5:	66 0f 2e f7          	ucomisd %xmm7,%xmm6

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065d9:	f2 0f 11 3d 6f ae 20 	movsd  %xmm7,0x20ae6f(%rip)        # 611450 <out_error+0x30>
  4065e0:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4065e1:	0f 87 a1 0d 00 00    	ja     407388 <DoNNetIteration+0x17e8>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065e7:	66 0f 28 f7          	movapd %xmm7,%xmm6
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  4065eb:	f2 0f 58 c7          	addsd  %xmm7,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  4065ef:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  4065f3:	66 0f 28 ee          	movapd %xmm6,%xmm5
  4065f7:	f2 0f 10 75 00       	movsd  0x0(%rbp),%xmm6
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  4065fc:	66 45 0f ef f6       	pxor   %xmm14,%xmm14

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406601:	f2 0f 5c 35 0f ad 20 	subsd  0x20ad0f(%rip),%xmm6        # 611318 <out_out+0x38>
  406608:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406609:	66 44 0f 2e f6       	ucomisd %xmm6,%xmm14

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40660e:	f2 0f 11 35 42 ae 20 	movsd  %xmm6,0x20ae42(%rip)        # 611458 <out_error+0x38>
  406615:	00 
	** while we're here, also compute magnitude
	** of total error and worst error in this pass.
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
  406616:	0f 87 4b 0d 00 00    	ja     407367 <DoNNetIteration+0x17c7>

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  40661c:	66 44 0f 28 f6       	movapd %xmm6,%xmm14
		if (-error > tot_error)
			tot_error = -error; /* worst error this pattern */
	}
	else
	{
		sum += error;
  406621:	f2 0f 58 c6          	addsd  %xmm6,%xmm0

tot_error = 0.0;
sum = 0.0;
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
  406625:	f2 44 0f 5f f5       	maxsd  %xmm5,%xmm14
  40662a:	66 41 0f 28 ee       	movapd %xmm14,%xmm5
		sum += error;
		if (error > tot_error)
			tot_error = error; /* worst error this pattern */
	}
}
avg_out_error[patt] = sum/OUT_SIZE;
  40662f:	f2 0f 59 05 71 7c 00 	mulsd  0x7c71(%rip),%xmm0        # 40e2a8 <jtable.3055+0x1518>
  406636:	00 
  406637:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  40663c:	b9 a0 33 61 00       	mov    $0x6133a0,%ecx

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406641:	f2 44 0f 10 15 de da 	movsd  0x20dade(%rip),%xmm10        # 614128 <out_wts+0x48>
  406648:	20 00 
  40664a:	ba c0 3e 61 00       	mov    $0x613ec0,%edx
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  40664f:	f2 44 0f 10 3d 10 d8 	movsd  0x20d810(%rip),%xmm15        # 613e68 <mid_out+0x8>
  406656:	20 00 
  406658:	31 f6                	xor    %esi,%esi
		if (error > tot_error)
			tot_error = error; /* worst error this pattern */
	}
}
avg_out_error[patt] = sum/OUT_SIZE;
tot_out_error[patt] = tot_error;
  40665a:	f2 0f 11 a8 20 13 61 	movsd  %xmm5,0x611320(%rax)
  406661:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406662:	66 0f ef ed          	pxor   %xmm5,%xmm5
  406666:	f2 44 0f 59 d3       	mulsd  %xmm3,%xmm10
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  40666b:	f2 44 0f 11 7c 24 20 	movsd  %xmm15,0x20(%rsp)
		sum += error;
		if (error > tot_error)
			tot_error = error; /* worst error this pattern */
	}
}
avg_out_error[patt] = sum/OUT_SIZE;
  406672:	f2 0f 11 80 c0 13 61 	movsd  %xmm0,0x6113c0(%rax)
  406679:	00 
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  40667a:	b8 e0 40 61 00       	mov    $0x6140e0,%eax

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  40667f:	f2 0f 10 05 59 da 20 	movsd  0x20da59(%rip),%xmm0        # 6140e0 <out_wts>
  406686:	00 
  406687:	f2 0f 59 c4          	mulsd  %xmm4,%xmm0
  40668b:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
  40668f:	f2 0f 10 2d 89 da 20 	movsd  0x20da89(%rip),%xmm5        # 614120 <out_wts+0x40>
  406696:	00 
  406697:	f2 0f 59 eb          	mulsd  %xmm3,%xmm5
  40669b:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
  40669f:	f2 0f 10 2d b9 da 20 	movsd  0x20dab9(%rip),%xmm5        # 614160 <out_wts+0x80>
  4066a6:	00 
  4066a7:	f2 0f 59 ea          	mulsd  %xmm2,%xmm5
  4066ab:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
  4066af:	f2 0f 10 2d e9 da 20 	movsd  0x20dae9(%rip),%xmm5        # 6141a0 <out_wts+0xc0>
  4066b6:	00 
  4066b7:	f2 0f 59 e9          	mulsd  %xmm1,%xmm5
  4066bb:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
  4066bf:	f2 0f 10 2d 19 db 20 	movsd  0x20db19(%rip),%xmm5        # 6141e0 <out_wts+0x100>
  4066c6:	00 
  4066c7:	f2 41 0f 59 e9       	mulsd  %xmm9,%xmm5
  4066cc:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
  4066d0:	f2 0f 10 2d 48 db 20 	movsd  0x20db48(%rip),%xmm5        # 614220 <out_wts+0x140>
  4066d7:	00 
  4066d8:	f2 41 0f 59 e8       	mulsd  %xmm8,%xmm5
  4066dd:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
  4066e1:	f2 0f 10 2d 77 db 20 	movsd  0x20db77(%rip),%xmm5        # 614260 <out_wts+0x180>
  4066e8:	00 
  4066e9:	f2 0f 59 ef          	mulsd  %xmm7,%xmm5
  4066ed:	f2 0f 58 c5          	addsd  %xmm5,%xmm0
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  4066f1:	f2 0f 10 2d 67 d7 20 	movsd  0x20d767(%rip),%xmm5        # 613e60 <mid_out>
  4066f8:	00 
  4066f9:	66 44 0f 28 f5       	movapd %xmm5,%xmm14
  4066fe:	f2 0f 10 2d 9a db 20 	movsd  0x20db9a(%rip),%xmm5        # 6142a0 <out_wts+0x1c0>
  406705:	00 
  406706:	f2 44 0f 11 74 24 48 	movsd  %xmm14,0x48(%rsp)
  40670d:	f2 0f 59 ee          	mulsd  %xmm6,%xmm5
  406711:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
  406715:	f2 0f 10 05 53 76 00 	movsd  0x7653(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  40671c:	00 
  40671d:	f2 41 0f 5c c6       	subsd  %xmm14,%xmm0
  406722:	f2 41 0f 59 c6       	mulsd  %xmm14,%xmm0
  406727:	f2 0f 59 c5          	mulsd  %xmm5,%xmm0

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  40672b:	f2 0f 10 2d b5 d9 20 	movsd  0x20d9b5(%rip),%xmm5        # 6140e8 <out_wts+0x8>
  406732:	00 
  406733:	f2 0f 59 ec          	mulsd  %xmm4,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406737:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
  40673c:	f2 0f 11 05 3c ac 20 	movsd  %xmm0,0x20ac3c(%rip)        # 611380 <mid_error>
  406743:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406744:	66 0f ef c0          	pxor   %xmm0,%xmm0
  406748:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
  40674c:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406751:	f2 44 0f 10 15 0e da 	movsd  0x20da0e(%rip),%xmm10        # 614168 <out_wts+0x88>
  406758:	20 00 
  40675a:	f2 44 0f 59 d2       	mulsd  %xmm2,%xmm10
  40675f:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406764:	f2 44 0f 10 15 3b da 	movsd  0x20da3b(%rip),%xmm10        # 6141a8 <out_wts+0xc8>
  40676b:	20 00 
  40676d:	f2 44 0f 59 d1       	mulsd  %xmm1,%xmm10
  406772:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406777:	f2 44 0f 10 15 68 da 	movsd  0x20da68(%rip),%xmm10        # 6141e8 <out_wts+0x108>
  40677e:	20 00 
  406780:	f2 45 0f 59 d1       	mulsd  %xmm9,%xmm10
  406785:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  40678a:	f2 44 0f 10 15 95 da 	movsd  0x20da95(%rip),%xmm10        # 614228 <out_wts+0x148>
  406791:	20 00 
  406793:	f2 45 0f 59 d0       	mulsd  %xmm8,%xmm10
  406798:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  40679d:	f2 44 0f 10 15 c2 da 	movsd  0x20dac2(%rip),%xmm10        # 614268 <out_wts+0x188>
  4067a4:	20 00 
  4067a6:	f2 44 0f 59 d7       	mulsd  %xmm7,%xmm10
  4067ab:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  4067b0:	f2 44 0f 10 15 ef da 	movsd  0x20daef(%rip),%xmm10        # 6142a8 <out_wts+0x1c8>
  4067b7:	20 00 
  4067b9:	f2 44 0f 59 d6       	mulsd  %xmm6,%xmm10
  4067be:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4067c3:	f2 44 0f 10 15 a4 75 	movsd  0x75a4(%rip),%xmm10        # 40dd70 <jtable.3055+0xfe0>
  4067ca:	00 00 
  4067cc:	f2 45 0f 5c d7       	subsd  %xmm15,%xmm10
  4067d1:	f2 45 0f 59 d7       	mulsd  %xmm15,%xmm10
  4067d6:	f2 41 0f 59 ea       	mulsd  %xmm10,%xmm5

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  4067db:	f2 44 0f 10 15 4c d9 	movsd  0x20d94c(%rip),%xmm10        # 614130 <out_wts+0x50>
  4067e2:	20 00 
  4067e4:	f2 44 0f 59 d3       	mulsd  %xmm3,%xmm10
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  4067e9:	f2 0f 11 2d 97 ab 20 	movsd  %xmm5,0x20ab97(%rip)        # 611388 <mid_error+0x8>
  4067f0:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  4067f1:	f2 0f 10 2d f7 d8 20 	movsd  0x20d8f7(%rip),%xmm5        # 6140f0 <out_wts+0x10>
  4067f8:	00 
  4067f9:	f2 0f 59 ec          	mulsd  %xmm4,%xmm5
  4067fd:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
  406801:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406806:	f2 44 0f 10 15 61 d9 	movsd  0x20d961(%rip),%xmm10        # 614170 <out_wts+0x90>
  40680d:	20 00 
  40680f:	f2 44 0f 59 d2       	mulsd  %xmm2,%xmm10
  406814:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406819:	f2 44 0f 10 15 8e d9 	movsd  0x20d98e(%rip),%xmm10        # 6141b0 <out_wts+0xd0>
  406820:	20 00 
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406822:	f2 0f 10 05 46 75 00 	movsd  0x7546(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  406829:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  40682a:	f2 44 0f 59 d1       	mulsd  %xmm1,%xmm10
  40682f:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406834:	f2 44 0f 10 15 b3 d9 	movsd  0x20d9b3(%rip),%xmm10        # 6141f0 <out_wts+0x110>
  40683b:	20 00 
  40683d:	f2 45 0f 59 d1       	mulsd  %xmm9,%xmm10
  406842:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406847:	f2 44 0f 10 15 e0 d9 	movsd  0x20d9e0(%rip),%xmm10        # 614230 <out_wts+0x150>
  40684e:	20 00 
  406850:	f2 45 0f 59 d0       	mulsd  %xmm8,%xmm10
  406855:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  40685a:	f2 44 0f 10 15 0d da 	movsd  0x20da0d(%rip),%xmm10        # 614270 <out_wts+0x190>
  406861:	20 00 
  406863:	f2 44 0f 59 d7       	mulsd  %xmm7,%xmm10
  406868:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  40686d:	f2 44 0f 10 15 fa d5 	movsd  0x20d5fa(%rip),%xmm10        # 613e70 <mid_out+0x10>
  406874:	20 00 
  406876:	66 45 0f 28 f2       	movapd %xmm10,%xmm14
  40687b:	f2 44 0f 10 15 2c da 	movsd  0x20da2c(%rip),%xmm10        # 6142b0 <out_wts+0x1d0>
  406882:	20 00 
  406884:	f2 41 0f 5c c6       	subsd  %xmm14,%xmm0
  406889:	f2 44 0f 11 74 24 10 	movsd  %xmm14,0x10(%rsp)
  406890:	f2 44 0f 59 d6       	mulsd  %xmm6,%xmm10
  406895:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  40689a:	66 44 0f 28 d0       	movapd %xmm0,%xmm10

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  40689f:	66 0f ef c0          	pxor   %xmm0,%xmm0
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  4068a3:	f2 45 0f 59 d6       	mulsd  %xmm14,%xmm10
  4068a8:	f2 41 0f 59 ea       	mulsd  %xmm10,%xmm5

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  4068ad:	f2 44 0f 10 15 82 d8 	movsd  0x20d882(%rip),%xmm10        # 614138 <out_wts+0x58>
  4068b4:	20 00 
  4068b6:	f2 44 0f 59 d3       	mulsd  %xmm3,%xmm10
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  4068bb:	f2 0f 11 2d cd aa 20 	movsd  %xmm5,0x20aacd(%rip)        # 611390 <mid_error+0x10>
  4068c2:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  4068c3:	f2 0f 10 2d 2d d8 20 	movsd  0x20d82d(%rip),%xmm5        # 6140f8 <out_wts+0x18>
  4068ca:	00 
  4068cb:	f2 0f 59 ec          	mulsd  %xmm4,%xmm5
  4068cf:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  4068d3:	f2 0f 10 05 95 74 00 	movsd  0x7495(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  4068da:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  4068db:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4068e0:	f2 44 0f 10 15 8f d8 	movsd  0x20d88f(%rip),%xmm10        # 614178 <out_wts+0x98>
  4068e7:	20 00 
  4068e9:	f2 44 0f 59 d2       	mulsd  %xmm2,%xmm10
  4068ee:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4068f3:	f2 44 0f 10 15 bc d8 	movsd  0x20d8bc(%rip),%xmm10        # 6141b8 <out_wts+0xd8>
  4068fa:	20 00 
  4068fc:	f2 44 0f 59 d1       	mulsd  %xmm1,%xmm10
  406901:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406906:	f2 44 0f 10 15 e9 d8 	movsd  0x20d8e9(%rip),%xmm10        # 6141f8 <out_wts+0x118>
  40690d:	20 00 
  40690f:	f2 45 0f 59 d1       	mulsd  %xmm9,%xmm10
  406914:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406919:	f2 44 0f 10 15 16 d9 	movsd  0x20d916(%rip),%xmm10        # 614238 <out_wts+0x158>
  406920:	20 00 
  406922:	f2 45 0f 59 d0       	mulsd  %xmm8,%xmm10
  406927:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  40692c:	f2 44 0f 10 15 43 d9 	movsd  0x20d943(%rip),%xmm10        # 614278 <out_wts+0x198>
  406933:	20 00 
  406935:	f2 44 0f 59 d7       	mulsd  %xmm7,%xmm10
  40693a:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  40693f:	f2 44 0f 10 15 30 d5 	movsd  0x20d530(%rip),%xmm10        # 613e78 <mid_out+0x18>
  406946:	20 00 
  406948:	66 45 0f 28 fa       	movapd %xmm10,%xmm15
  40694d:	f2 44 0f 10 15 62 d9 	movsd  0x20d962(%rip),%xmm10        # 6142b8 <out_wts+0x1d8>
  406954:	20 00 
  406956:	f2 41 0f 5c c7       	subsd  %xmm15,%xmm0
  40695b:	f2 44 0f 11 7c 24 40 	movsd  %xmm15,0x40(%rsp)
  406962:	f2 44 0f 59 d6       	mulsd  %xmm6,%xmm10
  406967:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  40696c:	66 44 0f 28 d0       	movapd %xmm0,%xmm10

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406971:	66 0f ef c0          	pxor   %xmm0,%xmm0
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406975:	f2 45 0f 59 d7       	mulsd  %xmm15,%xmm10
  40697a:	f2 44 0f 10 3d fd d4 	movsd  0x20d4fd(%rip),%xmm15        # 613e80 <mid_out+0x20>
  406981:	20 00 
  406983:	f2 41 0f 59 ea       	mulsd  %xmm10,%xmm5

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406988:	f2 44 0f 10 15 af d7 	movsd  0x20d7af(%rip),%xmm10        # 614140 <out_wts+0x60>
  40698f:	20 00 
  406991:	f2 44 0f 59 d3       	mulsd  %xmm3,%xmm10
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406996:	f2 0f 11 2d fa a9 20 	movsd  %xmm5,0x20a9fa(%rip)        # 611398 <mid_error+0x18>
  40699d:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  40699e:	f2 0f 10 2d 5a d7 20 	movsd  0x20d75a(%rip),%xmm5        # 614100 <out_wts+0x20>
  4069a5:	00 
  4069a6:	f2 0f 59 ec          	mulsd  %xmm4,%xmm5
  4069aa:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
  4069ae:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4069b3:	f2 44 0f 10 15 c4 d7 	movsd  0x20d7c4(%rip),%xmm10        # 614180 <out_wts+0xa0>
  4069ba:	20 00 
  4069bc:	f2 44 0f 59 d2       	mulsd  %xmm2,%xmm10
  4069c1:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4069c6:	f2 44 0f 10 15 f1 d7 	movsd  0x20d7f1(%rip),%xmm10        # 6141c0 <out_wts+0xe0>
  4069cd:	20 00 
  4069cf:	f2 44 0f 59 d1       	mulsd  %xmm1,%xmm10
  4069d4:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4069d9:	f2 44 0f 10 15 1e d8 	movsd  0x20d81e(%rip),%xmm10        # 614200 <out_wts+0x120>
  4069e0:	20 00 
  4069e2:	f2 45 0f 59 d1       	mulsd  %xmm9,%xmm10
  4069e7:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4069ec:	f2 44 0f 10 15 4b d8 	movsd  0x20d84b(%rip),%xmm10        # 614240 <out_wts+0x160>
  4069f3:	20 00 
  4069f5:	f2 45 0f 59 d0       	mulsd  %xmm8,%xmm10
  4069fa:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  4069ff:	f2 44 0f 10 15 78 d8 	movsd  0x20d878(%rip),%xmm10        # 614280 <out_wts+0x1a0>
  406a06:	20 00 
  406a08:	f2 44 0f 59 d7       	mulsd  %xmm7,%xmm10
  406a0d:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406a12:	f2 44 0f 10 15 a5 d8 	movsd  0x20d8a5(%rip),%xmm10        # 6142c0 <out_wts+0x1e0>
  406a19:	20 00 
  406a1b:	f2 44 0f 59 d6       	mulsd  %xmm6,%xmm10
  406a20:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406a25:	f2 44 0f 10 15 42 73 	movsd  0x7342(%rip),%xmm10        # 40dd70 <jtable.3055+0xfe0>
  406a2c:	00 00 
  406a2e:	f2 45 0f 5c d7       	subsd  %xmm15,%xmm10
  406a33:	f2 45 0f 59 d7       	mulsd  %xmm15,%xmm10
  406a38:	f2 41 0f 59 ea       	mulsd  %xmm10,%xmm5
  406a3d:	f2 0f 11 2d 5b a9 20 	movsd  %xmm5,0x20a95b(%rip)        # 6113a0 <mid_error+0x20>
  406a44:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406a45:	f2 0f 10 2d bb d6 20 	movsd  0x20d6bb(%rip),%xmm5        # 614108 <out_wts+0x28>
  406a4c:	00 
  406a4d:	f2 44 0f 10 15 f2 d6 	movsd  0x20d6f2(%rip),%xmm10        # 614148 <out_wts+0x68>
  406a54:	20 00 
  406a56:	f2 0f 59 ec          	mulsd  %xmm4,%xmm5
  406a5a:	f2 44 0f 59 d3       	mulsd  %xmm3,%xmm10
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406a5f:	f2 44 0f 10 35 20 d4 	movsd  0x20d420(%rip),%xmm14        # 613e88 <mid_out+0x28>
  406a66:	20 00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406a68:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
  406a6c:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406a71:	f2 44 0f 10 15 0e d7 	movsd  0x20d70e(%rip),%xmm10        # 614188 <out_wts+0xa8>
  406a78:	20 00 
  406a7a:	f2 44 0f 59 d2       	mulsd  %xmm2,%xmm10
  406a7f:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406a84:	f2 44 0f 10 15 3b d7 	movsd  0x20d73b(%rip),%xmm10        # 6141c8 <out_wts+0xe8>
  406a8b:	20 00 
  406a8d:	f2 44 0f 59 d1       	mulsd  %xmm1,%xmm10
  406a92:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406a97:	f2 44 0f 10 15 68 d7 	movsd  0x20d768(%rip),%xmm10        # 614208 <out_wts+0x128>
  406a9e:	20 00 
  406aa0:	f2 45 0f 59 d1       	mulsd  %xmm9,%xmm10
  406aa5:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406aaa:	f2 44 0f 10 15 95 d7 	movsd  0x20d795(%rip),%xmm10        # 614248 <out_wts+0x168>
  406ab1:	20 00 
  406ab3:	f2 45 0f 59 d0       	mulsd  %xmm8,%xmm10
  406ab8:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406abd:	f2 44 0f 10 15 c2 d7 	movsd  0x20d7c2(%rip),%xmm10        # 614288 <out_wts+0x1a8>
  406ac4:	20 00 
  406ac6:	f2 44 0f 59 d7       	mulsd  %xmm7,%xmm10
  406acb:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406ad0:	f2 44 0f 10 15 ef d7 	movsd  0x20d7ef(%rip),%xmm10        # 6142c8 <out_wts+0x1e8>
  406ad7:	20 00 
  406ad9:	f2 44 0f 59 d6       	mulsd  %xmm6,%xmm10
  406ade:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406ae3:	f2 44 0f 10 15 84 72 	movsd  0x7284(%rip),%xmm10        # 40dd70 <jtable.3055+0xfe0>
  406aea:	00 00 
  406aec:	f2 45 0f 5c d6       	subsd  %xmm14,%xmm10
  406af1:	f2 45 0f 59 d6       	mulsd  %xmm14,%xmm10
  406af6:	f2 41 0f 59 ea       	mulsd  %xmm10,%xmm5

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406afb:	f2 44 0f 10 15 4c d6 	movsd  0x20d64c(%rip),%xmm10        # 614150 <out_wts+0x70>
  406b02:	20 00 
  406b04:	f2 44 0f 59 d3       	mulsd  %xmm3,%xmm10
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406b09:	f2 0f 11 2d 97 a8 20 	movsd  %xmm5,0x20a897(%rip)        # 6113a8 <mid_error+0x28>
  406b10:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406b11:	f2 0f 59 1d 3f d6 20 	mulsd  0x20d63f(%rip),%xmm3        # 614158 <out_wts+0x78>
  406b18:	00 
  406b19:	f2 0f 10 2d ef d5 20 	movsd  0x20d5ef(%rip),%xmm5        # 614110 <out_wts+0x30>
  406b20:	00 
  406b21:	f2 0f 59 ec          	mulsd  %xmm4,%xmm5
  406b25:	f2 0f 59 25 eb d5 20 	mulsd  0x20d5eb(%rip),%xmm4        # 614118 <out_wts+0x38>
  406b2c:	00 
  406b2d:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406b31:	f2 0f 10 05 97 d7 20 	movsd  0x20d797(%rip),%xmm0        # 6142d0 <out_wts+0x1f0>
  406b38:	00 
  406b39:	f2 0f 59 c6          	mulsd  %xmm6,%xmm0
  406b3d:	f2 0f 59 35 93 d7 20 	mulsd  0x20d793(%rip),%xmm6        # 6142d8 <out_wts+0x1f8>
  406b44:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406b45:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406b4a:	f2 44 0f 10 15 3d d6 	movsd  0x20d63d(%rip),%xmm10        # 614190 <out_wts+0xb0>
  406b51:	20 00 
  406b53:	f2 44 0f 59 d2       	mulsd  %xmm2,%xmm10
  406b58:	f2 0f 59 15 38 d6 20 	mulsd  0x20d638(%rip),%xmm2        # 614198 <out_wts+0xb8>
  406b5f:	00 
  406b60:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406b65:	f2 44 0f 10 15 62 d6 	movsd  0x20d662(%rip),%xmm10        # 6141d0 <out_wts+0xf0>
  406b6c:	20 00 
  406b6e:	f2 44 0f 59 d1       	mulsd  %xmm1,%xmm10
  406b73:	f2 0f 59 0d 5d d6 20 	mulsd  0x20d65d(%rip),%xmm1        # 6141d8 <out_wts+0xf8>
  406b7a:	00 
  406b7b:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406b80:	f2 44 0f 10 15 87 d6 	movsd  0x20d687(%rip),%xmm10        # 614210 <out_wts+0x130>
  406b87:	20 00 
  406b89:	f2 45 0f 59 d1       	mulsd  %xmm9,%xmm10
  406b8e:	f2 44 0f 59 0d 81 d6 	mulsd  0x20d681(%rip),%xmm9        # 614218 <out_wts+0x138>
  406b95:	20 00 
  406b97:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406b9c:	f2 44 0f 10 15 ab d6 	movsd  0x20d6ab(%rip),%xmm10        # 614250 <out_wts+0x170>
  406ba3:	20 00 
  406ba5:	f2 45 0f 59 d0       	mulsd  %xmm8,%xmm10
  406baa:	f2 44 0f 59 05 a5 d6 	mulsd  0x20d6a5(%rip),%xmm8        # 614258 <out_wts+0x178>
  406bb1:	20 00 
  406bb3:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
  406bb8:	f2 44 0f 10 15 cf d6 	movsd  0x20d6cf(%rip),%xmm10        # 614290 <out_wts+0x1b0>
  406bbf:	20 00 
  406bc1:	f2 44 0f 59 d7       	mulsd  %xmm7,%xmm10
  406bc6:	f2 0f 59 3d ca d6 20 	mulsd  0x20d6ca(%rip),%xmm7        # 614298 <out_wts+0x1b8>
  406bcd:	00 
  406bce:	f2 41 0f 58 ea       	addsd  %xmm10,%xmm5
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406bd3:	f2 44 0f 10 15 b4 d2 	movsd  0x20d2b4(%rip),%xmm10        # 613e90 <mid_out+0x30>
  406bda:	20 00 
  406bdc:	f2 0f 58 e8          	addsd  %xmm0,%xmm5
  406be0:	f2 0f 10 05 88 71 00 	movsd  0x7188(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  406be7:	00 
  406be8:	f2 41 0f 5c c2       	subsd  %xmm10,%xmm0
  406bed:	f2 41 0f 59 c2       	mulsd  %xmm10,%xmm0
  406bf2:	f2 0f 59 e8          	mulsd  %xmm0,%xmm5

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406bf6:	66 0f ef c0          	pxor   %xmm0,%xmm0
  406bfa:	f2 0f 58 e0          	addsd  %xmm0,%xmm4
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406bfe:	f2 0f 11 2d aa a7 20 	movsd  %xmm5,0x20a7aa(%rip)        # 6113b0 <mid_error+0x30>
  406c05:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406c06:	f2 0f 58 dc          	addsd  %xmm4,%xmm3
  406c0a:	f2 0f 58 da          	addsd  %xmm2,%xmm3
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406c0e:	f2 0f 10 15 82 d2 20 	movsd  0x20d282(%rip),%xmm2        # 613e98 <mid_out+0x38>
  406c15:	00 

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406c16:	f2 0f 58 d9          	addsd  %xmm1,%xmm3
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406c1a:	f2 0f 10 0d 4e 71 00 	movsd  0x714e(%rip),%xmm1        # 40dd70 <jtable.3055+0xfe0>
  406c21:	00 
  406c22:	f2 0f 5c ca          	subsd  %xmm2,%xmm1

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406c26:	f2 41 0f 58 d9       	addsd  %xmm9,%xmm3
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406c2b:	f2 0f 59 ca          	mulsd  %xmm2,%xmm1

for (neurode=0; neurode<MID_SIZE; neurode++)
{
	sum = 0.0;
	for (i=0; i<OUT_SIZE; i++)
		sum += out_wts[i][neurode]*out_error[i];
  406c2f:	f2 44 0f 58 c3       	addsd  %xmm3,%xmm8
  406c34:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406c39:	f2 0f 58 f7          	addsd  %xmm7,%xmm6
  406c3d:	f2 0f 59 f1          	mulsd  %xmm1,%xmm6
  406c41:	f2 0f 11 35 6f a7 20 	movsd  %xmm6,0x20a76f(%rip)        # 6113b8 <mid_error+0x38>
  406c48:	00 
  406c49:	f2 0f 10 04 24       	movsd  (%rsp),%xmm0
  406c4e:	f2 0f 10 5c 24 10    	movsd  0x10(%rsp),%xmm3
  406c54:	f2 0f 10 64 24 20    	movsd  0x20(%rsp),%xmm4
  406c5a:	f2 0f 10 6c 24 40    	movsd  0x40(%rsp),%xmm5
  406c60:	f2 0f 10 74 24 48    	movsd  0x48(%rsp),%xmm6
  406c66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  406c6d:	00 00 00 
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406c70:	f2 0f 10 8e 20 14 61 	movsd  0x611420(%rsi),%xmm1
  406c77:	00 
  406c78:	48 83 c6 08          	add    $0x8,%rsi
  406c7c:	48 83 c1 40          	add    $0x40,%rcx

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406c80:	f2 44 0f 10 41 c0    	movsd  -0x40(%rcx),%xmm8
  406c86:	48 83 c0 40          	add    $0x40,%rax
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406c8a:	f2 41 0f 59 cc       	mulsd  %xmm12,%xmm1
  406c8f:	48 83 c2 40          	add    $0x40,%rdx

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406c93:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406c98:	66 0f 28 f9          	movapd %xmm1,%xmm7
  406c9c:	f2 0f 59 fe          	mulsd  %xmm6,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406ca0:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406ca5:	f2 44 0f 10 40 c0    	movsd  -0x40(%rax),%xmm8
  406cab:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406cb0:	f2 0f 58 7a c0       	addsd  -0x40(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406cb5:	f2 44 0f 11 40 c0    	movsd  %xmm8,-0x40(%rax)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406cbb:	f2 44 0f 10 41 c8    	movsd  -0x38(%rcx),%xmm8
		out_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406cc1:	f2 0f 11 7a c0       	movsd  %xmm7,-0x40(%rdx)
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406cc6:	66 0f 28 fc          	movapd %xmm4,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406cca:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406ccf:	f2 0f 59 f9          	mulsd  %xmm1,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406cd3:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406cd8:	f2 44 0f 10 40 c8    	movsd  -0x38(%rax),%xmm8
  406cde:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406ce3:	f2 0f 58 7a c8       	addsd  -0x38(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406ce8:	f2 44 0f 11 40 c8    	movsd  %xmm8,-0x38(%rax)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406cee:	f2 44 0f 10 41 d0    	movsd  -0x30(%rcx),%xmm8
		out_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406cf4:	f2 0f 11 7a c8       	movsd  %xmm7,-0x38(%rdx)
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406cf9:	66 0f 28 fb          	movapd %xmm3,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406cfd:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d02:	f2 0f 59 f9          	mulsd  %xmm1,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d06:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406d0b:	f2 44 0f 10 40 d0    	movsd  -0x30(%rax),%xmm8
  406d11:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406d16:	f2 0f 58 7a d0       	addsd  -0x30(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406d1b:	f2 44 0f 11 40 d0    	movsd  %xmm8,-0x30(%rax)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d21:	f2 44 0f 10 41 d8    	movsd  -0x28(%rcx),%xmm8
		out_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406d27:	f2 0f 11 7a d0       	movsd  %xmm7,-0x30(%rdx)
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d2c:	66 0f 28 f9          	movapd %xmm1,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d30:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d35:	f2 0f 59 fd          	mulsd  %xmm5,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d39:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406d3e:	f2 44 0f 10 40 d8    	movsd  -0x28(%rax),%xmm8
  406d44:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406d49:	f2 0f 58 7a d8       	addsd  -0x28(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406d4e:	f2 44 0f 11 40 d8    	movsd  %xmm8,-0x28(%rax)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d54:	f2 44 0f 10 41 e0    	movsd  -0x20(%rcx),%xmm8
		out_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406d5a:	f2 0f 11 7a d8       	movsd  %xmm7,-0x28(%rdx)
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d5f:	66 41 0f 28 ff       	movapd %xmm15,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d64:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d69:	f2 0f 59 f9          	mulsd  %xmm1,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d6d:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406d72:	f2 44 0f 10 40 e0    	movsd  -0x20(%rax),%xmm8
  406d78:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406d7d:	f2 0f 58 7a e0       	addsd  -0x20(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406d82:	f2 44 0f 11 40 e0    	movsd  %xmm8,-0x20(%rax)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d88:	f2 44 0f 10 41 e8    	movsd  -0x18(%rcx),%xmm8
		out_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406d8e:	f2 0f 11 7a e0       	movsd  %xmm7,-0x20(%rdx)
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d93:	66 0f 28 f9          	movapd %xmm1,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406d97:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406d9c:	f2 41 0f 59 fe       	mulsd  %xmm14,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406da1:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406da6:	f2 44 0f 10 40 e8    	movsd  -0x18(%rax),%xmm8
  406dac:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406db1:	f2 0f 58 7a e8       	addsd  -0x18(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406db6:	f2 44 0f 11 40 e8    	movsd  %xmm8,-0x18(%rax)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406dbc:	f2 44 0f 10 41 f0    	movsd  -0x10(%rcx),%xmm8
		out_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406dc2:	f2 0f 11 7a e8       	movsd  %xmm7,-0x18(%rdx)
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406dc7:	66 41 0f 28 fa       	movapd %xmm10,%xmm7

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406dcc:	f2 45 0f 59 c4       	mulsd  %xmm12,%xmm8
for (neurode=0; neurode<OUT_SIZE; neurode++)
{
	for (weight=0; weight<MID_SIZE; weight++)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];
  406dd1:	f2 0f 59 f9          	mulsd  %xmm1,%xmm7
  406dd5:	f2 0f 59 ca          	mulsd  %xmm2,%xmm1

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406dd9:	f2 41 0f 58 f8       	addsd  %xmm8,%xmm7
		out_wts[neurode][weight] += delta;
  406dde:	f2 44 0f 10 40 f0    	movsd  -0x10(%rax),%xmm8
  406de4:	f2 44 0f 58 c7       	addsd  %xmm7,%xmm8

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406de9:	f2 0f 58 7a f0       	addsd  -0x10(%rdx),%xmm7
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406dee:	f2 44 0f 11 40 f0    	movsd  %xmm8,-0x10(%rax)

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406df4:	f2 0f 11 7a f0       	movsd  %xmm7,-0x10(%rdx)
	{
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
  406df9:	f2 0f 10 79 f8       	movsd  -0x8(%rcx),%xmm7
  406dfe:	f2 41 0f 59 fc       	mulsd  %xmm12,%xmm7
  406e03:	f2 0f 58 cf          	addsd  %xmm7,%xmm1
		out_wts[neurode][weight] += delta;
  406e07:	f2 0f 10 78 f8       	movsd  -0x8(%rax),%xmm7
  406e0c:	f2 0f 58 f9          	addsd  %xmm1,%xmm7

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406e10:	f2 0f 58 4a f8       	addsd  -0x8(%rdx),%xmm1
		/* standard delta rule */
		delta = learn * out_error[neurode] * mid_out[weight];

		/* now the momentum term */
		delta += alph * out_wt_change[neurode][weight];
		out_wts[neurode][weight] += delta;
  406e15:	f2 0f 11 78 f8       	movsd  %xmm7,-0x8(%rax)

		/* keep track of this pass's cum wt changes for next pass's momentum */
		out_wt_cum_change[neurode][weight] += delta;
  406e1a:	f2 0f 11 4a f8       	movsd  %xmm1,-0x8(%rdx)
int weight, neurode;
double learn,delta,alph;

learn = BETA;
alph  = ALPHA;
for (neurode=0; neurode<OUT_SIZE; neurode++)
  406e1f:	48 83 fe 40          	cmp    $0x40,%rsi
  406e23:	0f 85 47 fe ff ff    	jne    406c70 <DoNNetIteration+0x10d0>
for (neurode=0; neurode<MID_SIZE; neurode++)
{
	for (weight=0; weight<IN_SIZE; weight++)
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];
  406e29:	48 63 44 24 34       	movslq 0x34(%rsp),%rax
int weight, neurode;
double learn,delta,alph;

learn = BETA;
alph  = ALPHA;
for (neurode=0; neurode<OUT_SIZE; neurode++)
  406e2e:	31 ff                	xor    %edi,%edi
  406e30:	45 31 ed             	xor    %r13d,%r13d
  406e33:	45 31 db             	xor    %r11d,%r11d
  406e36:	41 bc 88 13 61 00    	mov    $0x611388,%r12d
  406e3c:	f2 41 0f 59 c4       	mulsd  %xmm12,%xmm0
for (neurode=0; neurode<MID_SIZE; neurode++)
{
	for (weight=0; weight<IN_SIZE; weight++)
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];
  406e41:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  406e45:	4c 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%r15
  406e4c:	00 
  406e4d:	49 29 c7             	sub    %rax,%r15
  406e50:	48 8d 87 60 14 61 00 	lea    0x611460(%rdi),%rax
  406e57:	a8 08                	test   $0x8,%al
  406e59:	0f 84 6c 01 00 00    	je     406fcb <DoNNetIteration+0x142b>
  406e5f:	90                   	nop
  406e60:	f2 0f 10 0c dd c0 1f 	movsd  0x611fc0(,%rbx,8),%xmm1
  406e67:	61 00 

learn = BETA;
alph  = ALPHA;
for (neurode=0; neurode<MID_SIZE; neurode++)
{
	for (weight=0; weight<IN_SIZE; weight++)
  406e69:	41 b9 01 00 00 00    	mov    $0x1,%r9d
		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
		mid_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406e6f:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
  406e74:	f2 0f 10 97 c0 2a 61 	movsd  0x612ac0(%rdi),%xmm2
  406e7b:	00 
		mid_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406e7c:	41 ba 22 00 00 00    	mov    $0x22,%r10d
for (neurode=0; neurode<MID_SIZE; neurode++)
{
	for (weight=0; weight<IN_SIZE; weight++)
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];
  406e82:	f2 0f 59 c8          	mulsd  %xmm0,%xmm1

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
  406e86:	f2 41 0f 59 d4       	mulsd  %xmm12,%xmm2
  406e8b:	f2 0f 58 ca          	addsd  %xmm2,%xmm1
		mid_wts[neurode][weight] += delta;
  406e8f:	f2 0f 10 97 60 14 61 	movsd  0x611460(%rdi),%xmm2
  406e96:	00 
  406e97:	f2 0f 58 d1          	addsd  %xmm1,%xmm2

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406e9b:	f2 0f 58 8f a0 35 61 	addsd  0x6135a0(%rdi),%xmm1
  406ea2:	00 
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
		mid_wts[neurode][weight] += delta;
  406ea3:	f2 0f 11 97 60 14 61 	movsd  %xmm2,0x611460(%rdi)
  406eaa:	00 

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406eab:	f2 0f 11 8f a0 35 61 	movsd  %xmm1,0x6135a0(%rdi)
  406eb2:	00 
  406eb3:	66 0f 28 d8          	movapd %xmm0,%xmm3
  406eb7:	49 8d 4c 05 00       	lea    0x0(%r13,%rax,1),%rcx
  406ebc:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
	/*
	** apply the derivative of the sigmoid here
	** Because of the choice of sigmoid f(I), the derivative
	** of the sigmoid is f'(I) = f(I)(1 - f(I))
	*/
	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
  406ec0:	31 c0                	xor    %eax,%eax
  406ec2:	66 0f 14 db          	unpcklpd %xmm3,%xmm3
  406ec6:	48 c1 e1 03          	shl    $0x3,%rcx
  406eca:	4c 8d 04 d5 c0 1f 61 	lea    0x611fc0(,%rdx,8),%r8
  406ed1:	00 
  406ed2:	4c 8d b1 c0 2a 61 00 	lea    0x612ac0(%rcx),%r14
  406ed9:	48 8d b1 60 14 61 00 	lea    0x611460(%rcx),%rsi
  406ee0:	31 d2                	xor    %edx,%edx
  406ee2:	48 81 c1 a0 35 61 00 	add    $0x6135a0,%rcx
  406ee9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
  406ef0:	66 41 0f 10 0c 06    	movupd (%r14,%rax,1),%xmm1
  406ef6:	83 c2 01             	add    $0x1,%edx
  406ef9:	66 0f 28 d1          	movapd %xmm1,%xmm2
for (neurode=0; neurode<MID_SIZE; neurode++)
{
	for (weight=0; weight<IN_SIZE; weight++)
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];
  406efd:	66 41 0f 10 0c 00    	movupd (%r8,%rax,1),%xmm1

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
  406f03:	66 41 0f 59 d5       	mulpd  %xmm13,%xmm2
  406f08:	66 0f 59 cb          	mulpd  %xmm3,%xmm1
  406f0c:	66 0f 58 ca          	addpd  %xmm2,%xmm1
		mid_wts[neurode][weight] += delta;
  406f10:	66 0f 28 14 06       	movapd (%rsi,%rax,1),%xmm2
  406f15:	66 0f 58 d1          	addpd  %xmm1,%xmm2
  406f19:	0f 29 14 06          	movaps %xmm2,(%rsi,%rax,1)

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406f1d:	66 0f 10 14 01       	movupd (%rcx,%rax,1),%xmm2
  406f22:	66 0f 58 ca          	addpd  %xmm2,%xmm1
  406f26:	0f 11 0c 01          	movups %xmm1,(%rcx,%rax,1)
  406f2a:	48 83 c0 10          	add    $0x10,%rax
  406f2e:	83 fa 10             	cmp    $0x10,%edx
  406f31:	76 bd                	jbe    406ef0 <DoNNetIteration+0x1350>
  406f33:	41 83 c1 22          	add    $0x22,%r9d
  406f37:	41 83 fa 22          	cmp    $0x22,%r10d
  406f3b:	74 58                	je     406f95 <DoNNetIteration+0x13f5>
for (neurode=0; neurode<MID_SIZE; neurode++)
{
	for (weight=0; weight<IN_SIZE; weight++)
	{
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];
  406f3d:	4d 63 c9             	movslq %r9d,%r9
  406f40:	4b 8d 04 0f          	lea    (%r15,%r9,1),%rax
  406f44:	f2 0f 59 04 c5 c0 1f 	mulsd  0x611fc0(,%rax,8),%xmm0
  406f4b:	61 00 

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
  406f4d:	49 63 c3             	movslq %r11d,%rax
  406f50:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
  406f54:	49 8d 04 d1          	lea    (%r9,%rdx,8),%rax
  406f58:	48 29 d0             	sub    %rdx,%rax
  406f5b:	f2 0f 10 0c c5 c0 2a 	movsd  0x612ac0(,%rax,8),%xmm1
  406f62:	61 00 
  406f64:	f2 41 0f 59 cc       	mulsd  %xmm12,%xmm1
  406f69:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
		mid_wts[neurode][weight] += delta;
  406f6d:	f2 0f 10 0c c5 60 14 	movsd  0x611460(,%rax,8),%xmm1
  406f74:	61 00 
  406f76:	f2 0f 58 c8          	addsd  %xmm0,%xmm1

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406f7a:	f2 0f 58 04 c5 a0 35 	addsd  0x6135a0(,%rax,8),%xmm0
  406f81:	61 00 
		/* first the basic delta rule */
		delta = learn * mid_error[neurode] * in_pats[patt][weight];

		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
		mid_wts[neurode][weight] += delta;
  406f83:	f2 0f 11 0c c5 60 14 	movsd  %xmm1,0x611460(,%rax,8)
  406f8a:	61 00 

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406f8c:	f2 0f 11 04 c5 a0 35 	movsd  %xmm0,0x6135a0(,%rax,8)
  406f93:	61 00 
  406f95:	48 81 c7 18 01 00 00 	add    $0x118,%rdi
int weight, neurode;
double learn,alph,delta;

learn = BETA;
alph  = ALPHA;
for (neurode=0; neurode<MID_SIZE; neurode++)
  406f9c:	41 83 c3 01          	add    $0x1,%r11d
  406fa0:	49 83 c5 23          	add    $0x23,%r13
  406fa4:	48 81 ff c0 08 00 00 	cmp    $0x8c0,%rdi
  406fab:	74 2e                	je     406fdb <DoNNetIteration+0x143b>
  406fad:	48 8d 87 60 14 61 00 	lea    0x611460(%rdi),%rax
  406fb4:	f2 41 0f 10 04 24    	movsd  (%r12),%xmm0
  406fba:	49 83 c4 08          	add    $0x8,%r12
  406fbe:	a8 08                	test   $0x8,%al
  406fc0:	f2 41 0f 59 c4       	mulsd  %xmm12,%xmm0
  406fc5:	0f 85 95 fe ff ff    	jne    406e60 <DoNNetIteration+0x12c0>
		/* with the momentum term */
		delta += alph * mid_wt_change[neurode][weight];
		mid_wts[neurode][weight] += delta;

		/* keep track of this pass's cum wt changes for next pass's momentum */
		mid_wt_cum_change[neurode][weight] += delta;
  406fcb:	45 31 c9             	xor    %r9d,%r9d
  406fce:	31 c0                	xor    %eax,%eax
  406fd0:	41 ba 23 00 00 00    	mov    $0x23,%r10d
  406fd6:	e9 d8 fe ff ff       	jmpq   406eb3 <DoNNetIteration+0x1313>
	iteration_count=1;
	learned = F;
	numpasses = 0;
	while (learned == F)
	{
		for (patt=0; patt<numpats; patt++)
  406fdb:	83 44 24 34 01       	addl   $0x1,0x34(%rsp)
  406fe0:	8b 05 2a a4 20 00    	mov    0x20a42a(%rip),%eax        # 611410 <numpats>
  406fe6:	48 83 c5 40          	add    $0x40,%rbp
  406fea:	8b 7c 24 34          	mov    0x34(%rsp),%edi
		{
			worst_error = 0.0;      /* reset this every pass through data */
			move_wt_changes();      /* move last pass's wt changes to momentum array */
			do_forward_pass(patt);
			do_back_pass(patt);
			iteration_count++;
  406fee:	83 05 33 ad 20 00 01 	addl   $0x1,0x20ad33(%rip)        # 611d28 <iteration_count>
  406ff5:	48 83 c3 23          	add    $0x23,%rbx
  406ff9:	48 83 44 24 38 08    	addq   $0x8,0x38(%rsp)
	iteration_count=1;
	learned = F;
	numpasses = 0;
	while (learned == F)
	{
		for (patt=0; patt<numpats; patt++)
  406fff:	39 f8                	cmp    %edi,%eax
  407001:	0f 8f 17 ef ff ff    	jg     405f1e <DoNNetIteration+0x37e>
			move_wt_changes();      /* move last pass's wt changes to momentum array */
			do_forward_pass(patt);
			do_back_pass(patt);
			iteration_count++;
		}
		numpasses ++;
  407007:	83 05 92 ce 20 00 01 	addl   $0x1,0x20ce92(%rip)        # 613ea0 <numpasses>

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  40700e:	85 c0                	test   %eax,%eax
  407010:	0f 8e 70 04 00 00    	jle    407486 <DoNNetIteration+0x18e6>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407016:	f2 0f 10 15 02 a3 20 	movsd  0x20a302(%rip),%xmm2        # 611320 <tot_out_error>
  40701d:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  40701e:	83 f8 01             	cmp    $0x1,%eax
{
double error,sum;

int i;

error = 0.0;
  407021:	66 0f ef e4          	pxor   %xmm4,%xmm4
  407025:	66 0f 28 c2          	movapd %xmm2,%xmm0
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  407029:	f2 0f 10 0d 8f a3 20 	movsd  0x20a38f(%rip),%xmm1        # 6113c0 <avg_out_error>
  407030:	00 
{
double error,sum;

int i;

error = 0.0;
  407031:	f2 0f 5f c4          	maxsd  %xmm4,%xmm0
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  407035:	f2 0f 58 cc          	addsd  %xmm4,%xmm1

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407039:	0f 84 ef 04 00 00    	je     40752e <DoNNetIteration+0x198e>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  40703f:	f2 0f 10 2d e1 a2 20 	movsd  0x20a2e1(%rip),%xmm5        # 611328 <tot_out_error+0x8>
  407046:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407047:	83 f8 02             	cmp    $0x2,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  40704a:	f2 0f 58 0d 76 a3 20 	addsd  0x20a376(%rip),%xmm1        # 6113c8 <avg_out_error+0x8>
  407051:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407052:	66 0f 28 e5          	movapd %xmm5,%xmm4
  407056:	f2 0f 5f e0          	maxsd  %xmm0,%xmm4
  40705a:	66 0f 28 c4          	movapd %xmm4,%xmm0

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  40705e:	0f 84 d7 00 00 00    	je     40713b <DoNNetIteration+0x159b>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407064:	f2 0f 10 1d c4 a2 20 	movsd  0x20a2c4(%rip),%xmm3        # 611330 <tot_out_error+0x10>
  40706b:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  40706c:	83 f8 03             	cmp    $0x3,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  40706f:	f2 0f 58 0d 59 a3 20 	addsd  0x20a359(%rip),%xmm1        # 6113d0 <avg_out_error+0x10>
  407076:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407077:	f2 0f 5f dc          	maxsd  %xmm4,%xmm3

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  40707b:	0f 84 dd 04 00 00    	je     40755e <DoNNetIteration+0x19be>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407081:	f2 0f 10 05 af a2 20 	movsd  0x20a2af(%rip),%xmm0        # 611338 <tot_out_error+0x18>
  407088:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407089:	83 f8 04             	cmp    $0x4,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  40708c:	f2 0f 58 0d 44 a3 20 	addsd  0x20a344(%rip),%xmm1        # 6113d8 <avg_out_error+0x18>
  407093:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407094:	f2 0f 5f c3          	maxsd  %xmm3,%xmm0

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407098:	0f 84 9d 00 00 00    	je     40713b <DoNNetIteration+0x159b>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  40709e:	f2 0f 10 1d 9a a2 20 	movsd  0x20a29a(%rip),%xmm3        # 611340 <tot_out_error+0x20>
  4070a5:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070a6:	83 f8 05             	cmp    $0x5,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  4070a9:	f2 0f 58 0d 2f a3 20 	addsd  0x20a32f(%rip),%xmm1        # 6113e0 <avg_out_error+0x20>
  4070b0:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  4070b1:	f2 0f 5f d8          	maxsd  %xmm0,%xmm3

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070b5:	0f 84 a3 04 00 00    	je     40755e <DoNNetIteration+0x19be>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  4070bb:	f2 0f 10 05 85 a2 20 	movsd  0x20a285(%rip),%xmm0        # 611348 <tot_out_error+0x28>
  4070c2:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070c3:	83 f8 06             	cmp    $0x6,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  4070c6:	f2 0f 58 0d 1a a3 20 	addsd  0x20a31a(%rip),%xmm1        # 6113e8 <avg_out_error+0x28>
  4070cd:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  4070ce:	f2 0f 5f c3          	maxsd  %xmm3,%xmm0

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070d2:	74 67                	je     40713b <DoNNetIteration+0x159b>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  4070d4:	f2 0f 10 1d 74 a2 20 	movsd  0x20a274(%rip),%xmm3        # 611350 <tot_out_error+0x30>
  4070db:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070dc:	83 f8 07             	cmp    $0x7,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  4070df:	f2 0f 58 0d 09 a3 20 	addsd  0x20a309(%rip),%xmm1        # 6113f0 <avg_out_error+0x30>
  4070e6:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  4070e7:	f2 0f 5f d8          	maxsd  %xmm0,%xmm3

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070eb:	0f 84 6d 04 00 00    	je     40755e <DoNNetIteration+0x19be>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  4070f1:	f2 0f 10 05 5f a2 20 	movsd  0x20a25f(%rip),%xmm0        # 611358 <tot_out_error+0x38>
  4070f8:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  4070f9:	83 f8 08             	cmp    $0x8,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  4070fc:	f2 0f 58 0d f4 a2 20 	addsd  0x20a2f4(%rip),%xmm1        # 6113f8 <avg_out_error+0x38>
  407103:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407104:	f2 0f 5f c3          	maxsd  %xmm3,%xmm0

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407108:	74 31                	je     40713b <DoNNetIteration+0x159b>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  40710a:	f2 0f 10 1d 4e a2 20 	movsd  0x20a24e(%rip),%xmm3        # 611360 <tot_out_error+0x40>
  407111:	00 

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407112:	83 f8 09             	cmp    $0x9,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
  407115:	f2 0f 58 0d e3 a2 20 	addsd  0x20a2e3(%rip),%xmm1        # 611400 <avg_out_error+0x40>
  40711c:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  40711d:	f2 0f 5f d8          	maxsd  %xmm0,%xmm3

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  407121:	0f 84 37 04 00 00    	je     40755e <DoNNetIteration+0x19be>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407127:	f2 0f 10 05 39 a2 20 	movsd  0x20a239(%rip),%xmm0        # 611368 <tot_out_error+0x48>
  40712e:	00 
	sum += avg_out_error[i];
  40712f:	f2 0f 58 0d d1 a2 20 	addsd  0x20a2d1(%rip),%xmm1        # 611408 <avg_out_error+0x48>
  407136:	00 

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
  407137:	f2 0f 5f c3          	maxsd  %xmm3,%xmm0
	sum += avg_out_error[i];
}
worst_error = error;
average_error = sum/numpats;
  40713b:	66 0f ef db          	pxor   %xmm3,%xmm3
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  40713f:	31 d2                	xor    %edx,%edx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  407141:	be 00 00 00 00       	mov    $0x0,%esi
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  407146:	66 0f 2e 05 6a 71 00 	ucomisd 0x716a(%rip),%xmm0        # 40e2b8 <jtable.3055+0x1528>
  40714d:	00 
  40714e:	66 0f 28 e5          	movapd %xmm5,%xmm4
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
  407152:	f2 0f 11 05 66 a1 20 	movsd  %xmm0,0x20a166(%rip)        # 6112c0 <worst_error>
  407159:	00 
average_error = sum/numpats;
  40715a:	f2 0f 2a d8          	cvtsi2sd %eax,%xmm3
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  40715e:	0f 92 c2             	setb   %dl
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
average_error = sum/numpats;
  407161:	f2 0f 5e cb          	divsd  %xmm3,%xmm1
  407165:	f2 0f 11 0d 53 cf 20 	movsd  %xmm1,0x20cf53(%rip)        # 6140c0 <average_error>
  40716c:	00 
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  40716d:	f2 0f 10 0d 4b 71 00 	movsd  0x714b(%rip),%xmm1        # 40e2c0 <jtable.3055+0x1530>
  407174:	00 
  407175:	66 0f 28 d9          	movapd %xmm1,%xmm3
  407179:	66 0f 2e d1          	ucomisd %xmm1,%xmm2
  40717d:	f2 0f c2 da 02       	cmplesd %xmm2,%xmm3
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  407182:	f2 0f 10 15 2e 71 00 	movsd  0x712e(%rip),%xmm2        # 40e2b8 <jtable.3055+0x1528>
  407189:	00 
  40718a:	66 0f 54 e3          	andpd  %xmm3,%xmm4
  40718e:	66 0f 55 dd          	andnpd %xmm5,%xmm3
  407192:	19 c9                	sbb    %ecx,%ecx
  407194:	83 c1 01             	add    $0x1,%ecx
  407197:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
  40719b:	66 0f 56 dc          	orpd   %xmm4,%xmm3
  40719f:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  4071a2:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  4071a6:	0f 82 0c 03 00 00    	jb     4074b8 <DoNNetIteration+0x1918>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  4071ac:	83 f8 02             	cmp    $0x2,%eax
  4071af:	0f 84 4b 01 00 00    	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  4071b5:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4071ba:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  4071be:	f2 0f 10 1d 6a a1 20 	movsd  0x20a16a(%rip),%xmm3        # 611330 <tot_out_error+0x10>
  4071c5:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4071c6:	be 00 00 00 00       	mov    $0x0,%esi
  4071cb:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  4071ce:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  4071d2:	0f 82 48 03 00 00    	jb     407520 <DoNNetIteration+0x1980>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  4071d8:	83 f8 03             	cmp    $0x3,%eax
  4071db:	0f 84 1f 01 00 00    	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  4071e1:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4071e6:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  4071ea:	f2 0f 10 1d 46 a1 20 	movsd  0x20a146(%rip),%xmm3        # 611338 <tot_out_error+0x18>
  4071f1:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4071f2:	be 00 00 00 00       	mov    $0x0,%esi
  4071f7:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  4071fa:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  4071fe:	0f 82 0c 03 00 00    	jb     407510 <DoNNetIteration+0x1970>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  407204:	83 f8 04             	cmp    $0x4,%eax
  407207:	0f 84 f3 00 00 00    	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  40720d:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  407212:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  407216:	f2 0f 10 1d 22 a1 20 	movsd  0x20a122(%rip),%xmm3        # 611340 <tot_out_error+0x20>
  40721d:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  40721e:	be 00 00 00 00       	mov    $0x0,%esi
  407223:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  407226:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  40722a:	0f 82 d0 02 00 00    	jb     407500 <DoNNetIteration+0x1960>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  407230:	83 f8 05             	cmp    $0x5,%eax
  407233:	0f 84 c7 00 00 00    	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  407239:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  40723e:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  407242:	f2 0f 10 1d fe a0 20 	movsd  0x20a0fe(%rip),%xmm3        # 611348 <tot_out_error+0x28>
  407249:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  40724a:	be 00 00 00 00       	mov    $0x0,%esi
  40724f:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  407252:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  407256:	0f 82 fb 01 00 00    	jb     407457 <DoNNetIteration+0x18b7>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  40725c:	83 f8 06             	cmp    $0x6,%eax
  40725f:	0f 84 9b 00 00 00    	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  407265:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  40726a:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  40726e:	f2 0f 10 1d da a0 20 	movsd  0x20a0da(%rip),%xmm3        # 611350 <tot_out_error+0x30>
  407275:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  407276:	be 00 00 00 00       	mov    $0x0,%esi
  40727b:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  40727e:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  407282:	0f 82 68 02 00 00    	jb     4074f0 <DoNNetIteration+0x1950>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  407288:	83 f8 07             	cmp    $0x7,%eax
  40728b:	74 73                	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  40728d:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  407292:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  407296:	f2 0f 10 1d ba a0 20 	movsd  0x20a0ba(%rip),%xmm3        # 611358 <tot_out_error+0x38>
  40729d:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  40729e:	be 00 00 00 00       	mov    $0x0,%esi
  4072a3:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  4072a6:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  4072aa:	0f 82 28 02 00 00    	jb     4074d8 <DoNNetIteration+0x1938>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  4072b0:	83 f8 08             	cmp    $0x8,%eax
  4072b3:	74 4b                	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  4072b5:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4072ba:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  4072be:	f2 0f 10 1d 9a a0 20 	movsd  0x20a09a(%rip),%xmm3        # 611360 <tot_out_error+0x40>
  4072c5:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4072c6:	be 00 00 00 00       	mov    $0x0,%esi
  4072cb:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  4072ce:	66 0f 2e d9          	ucomisd %xmm1,%xmm3
  4072d2:	0f 82 f0 01 00 00    	jb     4074c8 <DoNNetIteration+0x1928>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  4072d8:	83 f8 09             	cmp    $0x9,%eax
  4072db:	74 23                	je     407300 <DoNNetIteration+0x1760>
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  4072dd:	b9 01 00 00 00       	mov    $0x1,%ecx
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4072e2:	66 0f 2e c2          	ucomisd %xmm2,%xmm0
	if (tot_out_error[i] >= 16.0) error = T;
  4072e6:	f2 0f 10 05 7a a0 20 	movsd  0x20a07a(%rip),%xmm0        # 611368 <tot_out_error+0x48>
  4072ed:	00 
	fprintf(outfile,
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
  4072ee:	be 00 00 00 00       	mov    $0x0,%esi
  4072f3:	0f 43 d6             	cmovae %esi,%edx
	if (tot_out_error[i] >= 16.0) error = T;
  4072f6:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
  4072fa:	0f 82 60 01 00 00    	jb     407460 <DoNNetIteration+0x18c0>
}

if (error == T) result = ERR;
  407300:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
			do_forward_pass(patt);
			do_back_pass(patt);
			iteration_count++;
		}
		numpasses ++;
		learned = check_out_error();
  407305:	89 05 75 c0 20 00    	mov    %eax,0x20c075(%rip)        # 613380 <learned>
  40730b:	8b 15 8f cb 20 00    	mov    0x20cb8f(%rip),%edx        # 613ea0 <numpasses>
  407311:	31 c0                	xor    %eax,%eax
  407313:	be 10 de 40 00       	mov    $0x40de10,%esi
  407318:	bf 01 00 00 00       	mov    $0x1,%edi
  40731d:	44 0f 29 2c 24       	movaps %xmm13,(%rsp)
  407322:	e8 e9 9c ff ff       	callq  401010 <__printf_chk@plt>
** zeroing of changes.  This should reduce clock jitter,
** since we don't have to stop and start the clock for
** each iteration.
*/
elapsed=StartStopwatch();
while(nloops--)
  407327:	48 83 6c 24 58 01    	subq   $0x1,0x58(%rsp)
  40732d:	66 44 0f 28 2c 24    	movapd (%rsp),%xmm13
  407333:	0f 85 9b e8 ff ff    	jne    405bd4 <DoNNetIteration+0x34>
	}
#ifdef DEBUG
printf("Learned in %d passes\n",numpasses);
#endif
}
return(StopStopwatch(elapsed));
  407339:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
}
  40733e:	48 83 c4 68          	add    $0x68,%rsp
  407342:	5b                   	pop    %rbx
  407343:	5d                   	pop    %rbp
  407344:	41 5c                	pop    %r12
  407346:	41 5d                	pop    %r13
  407348:	41 5e                	pop    %r14
  40734a:	41 5f                	pop    %r15
	}
#ifdef DEBUG
printf("Learned in %d passes\n",numpasses);
#endif
}
return(StopStopwatch(elapsed));
  40734c:	e9 6f 4e 00 00       	jmpq   40c1c0 <StopStopwatch>
  407351:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	{
		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
		/*
		** Zero it out for next pass accumulation.
		*/
		mid_wt_cum_change[i][j] = 0.0;
  407358:	31 ff                	xor    %edi,%edi
  40735a:	31 c0                	xor    %eax,%eax
  40735c:	41 bb 23 00 00 00    	mov    $0x23,%r11d
  407362:	e9 01 ec ff ff       	jmpq   405f68 <DoNNetIteration+0x3c8>
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
		if (-error > tot_error)
  407367:	66 44 0f 28 d6       	movapd %xmm6,%xmm10
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  40736c:	f2 0f 5c c6          	subsd  %xmm6,%xmm0
		if (-error > tot_error)
  407370:	66 44 0f 57 15 87 6f 	xorpd  0x6f87(%rip),%xmm10        # 40e300 <jtable.3055+0x1570>
  407377:	00 00 
  407379:	f2 44 0f 5f d5       	maxsd  %xmm5,%xmm10
  40737e:	66 41 0f 28 ea       	movapd %xmm10,%xmm5
  407383:	e9 a7 f2 ff ff       	jmpq   40662f <DoNNetIteration+0xa8f>
  407388:	66 0f 28 f7          	movapd %xmm7,%xmm6
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  40738c:	f2 0f 5c c7          	subsd  %xmm7,%xmm0
		if (-error > tot_error)
  407390:	66 0f 57 35 68 6f 00 	xorpd  0x6f68(%rip),%xmm6        # 40e300 <jtable.3055+0x1570>
  407397:	00 
  407398:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  40739c:	66 0f 28 ee          	movapd %xmm6,%xmm5
  4073a0:	e9 52 f2 ff ff       	jmpq   4065f7 <DoNNetIteration+0xa57>
  4073a5:	66 0f 28 cb          	movapd %xmm3,%xmm1
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  4073a9:	f2 0f 5c c3          	subsd  %xmm3,%xmm0
		if (-error > tot_error)
  4073ad:	66 0f 57 0d 4b 6f 00 	xorpd  0x6f4b(%rip),%xmm1        # 40e300 <jtable.3055+0x1570>
  4073b4:	00 
  4073b5:	f2 0f 5f cd          	maxsd  %xmm5,%xmm1
  4073b9:	66 0f 28 e9          	movapd %xmm1,%xmm5
  4073bd:	e9 2e f1 ff ff       	jmpq   4064f0 <DoNNetIteration+0x950>
  4073c2:	66 0f 28 ec          	movapd %xmm4,%xmm5
  4073c6:	66 0f ef f6          	pxor   %xmm6,%xmm6
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  4073ca:	f2 0f 5c c4          	subsd  %xmm4,%xmm0
		if (-error > tot_error)
  4073ce:	66 0f 57 2d 2a 6f 00 	xorpd  0x6f2a(%rip),%xmm5        # 40e300 <jtable.3055+0x1570>
  4073d5:	00 
  4073d6:	f2 0f 5f ee          	maxsd  %xmm6,%xmm5
  4073da:	e9 de f0 ff ff       	jmpq   4064bd <DoNNetIteration+0x91d>
  4073df:	66 41 0f 28 f0       	movapd %xmm8,%xmm6
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  4073e4:	f2 41 0f 5c c0       	subsd  %xmm8,%xmm0
		if (-error > tot_error)
  4073e9:	66 0f 57 35 0f 6f 00 	xorpd  0x6f0f(%rip),%xmm6        # 40e300 <jtable.3055+0x1570>
  4073f0:	00 
  4073f1:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  4073f5:	66 0f 28 ee          	movapd %xmm6,%xmm5
  4073f9:	e9 c6 f1 ff ff       	jmpq   4065c4 <DoNNetIteration+0xa24>
  4073fe:	66 41 0f 28 f1       	movapd %xmm9,%xmm6
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  407403:	f2 41 0f 5c c1       	subsd  %xmm9,%xmm0
		if (-error > tot_error)
  407408:	66 0f 57 35 f0 6e 00 	xorpd  0x6ef0(%rip),%xmm6        # 40e300 <jtable.3055+0x1570>
  40740f:	00 
  407410:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  407414:	66 0f 28 ee          	movapd %xmm6,%xmm5
  407418:	e9 6e f1 ff ff       	jmpq   40658b <DoNNetIteration+0x9eb>
  40741d:	66 0f 28 f1          	movapd %xmm1,%xmm6
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  407421:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
		if (-error > tot_error)
  407425:	66 0f 57 35 d3 6e 00 	xorpd  0x6ed3(%rip),%xmm6        # 40e300 <jtable.3055+0x1570>
  40742c:	00 
  40742d:	f2 0f 5f f5          	maxsd  %xmm5,%xmm6
  407431:	66 0f 28 ee          	movapd %xmm6,%xmm5
  407435:	e9 18 f1 ff ff       	jmpq   406552 <DoNNetIteration+0x9b2>
  40743a:	66 0f 28 ca          	movapd %xmm2,%xmm1
	** We use these to decide if we are done yet.
	*/
	error = out_error[neurode];
	if (error <0.0)
	{
		sum += -error;
  40743e:	f2 0f 5c c2          	subsd  %xmm2,%xmm0
		if (-error > tot_error)
  407442:	66 0f 57 0d b6 6e 00 	xorpd  0x6eb6(%rip),%xmm1        # 40e300 <jtable.3055+0x1570>
  407449:	00 
  40744a:	f2 0f 5f cd          	maxsd  %xmm5,%xmm1
  40744e:	66 0f 28 e9          	movapd %xmm1,%xmm5
  407452:	e9 cc f0 ff ff       	jmpq   406523 <DoNNetIteration+0x983>
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  407457:	83 f8 06             	cmp    $0x6,%eax
  40745a:	0f 85 0a fe ff ff    	jne    40726a <DoNNetIteration+0x16ca>

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
}

if (error == T) result = ERR;
  407460:	83 f9 01             	cmp    $0x1,%ecx
  407463:	0f 84 97 fe ff ff    	je     407300 <DoNNetIteration+0x1760>
	randomize_wts();
	zero_changes();
	iteration_count=1;
	learned = F;
	numpasses = 0;
	while (learned == F)
  407469:	85 d2                	test   %edx,%edx
			do_forward_pass(patt);
			do_back_pass(patt);
			iteration_count++;
		}
		numpasses ++;
		learned = check_out_error();
  40746b:	89 15 0f bf 20 00    	mov    %edx,0x20bf0f(%rip)        # 613380 <learned>
	randomize_wts();
	zero_changes();
	iteration_count=1;
	learned = F;
	numpasses = 0;
	while (learned == F)
  407471:	0f 85 94 fe ff ff    	jne    40730b <DoNNetIteration+0x176b>
	{
		for (patt=0; patt<numpats; patt++)
  407477:	85 c0                	test   %eax,%eax
  407479:	0f 8f 79 ea ff ff    	jg     405ef8 <DoNNetIteration+0x358>
			move_wt_changes();      /* move last pass's wt changes to momentum array */
			do_forward_pass(patt);
			do_back_pass(patt);
			iteration_count++;
		}
		numpasses ++;
  40747f:	83 05 1a ca 20 00 01 	addl   $0x1,0x20ca1a(%rip)        # 613ea0 <numpasses>
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
average_error = sum/numpats;
  407486:	66 0f ef c0          	pxor   %xmm0,%xmm0
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
  40748a:	48 c7 05 2b 9e 20 00 	movq   $0x0,0x209e2b(%rip)        # 6112c0 <worst_error>
  407491:	00 00 00 00 
average_error = sum/numpats;
  407495:	66 0f ef e4          	pxor   %xmm4,%xmm4
  407499:	f2 0f 2a c0          	cvtsi2sd %eax,%xmm0
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  40749d:	b8 01 00 00 00       	mov    $0x1,%eax
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
average_error = sum/numpats;
  4074a2:	f2 0f 5e e0          	divsd  %xmm0,%xmm4
  4074a6:	f2 0f 11 25 12 cc 20 	movsd  %xmm4,0x20cc12(%rip)        # 6140c0 <average_error>
  4074ad:	00 
  4074ae:	e9 52 fe ff ff       	jmpq   407305 <DoNNetIteration+0x1765>
  4074b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
/*
#ifdef DEBUG
printf("\n Iteration # %d",iteration_count);
#endif
*/
for (i=0; i<numpats; i++)
  4074b8:	83 f8 02             	cmp    $0x2,%eax
  4074bb:	0f 85 f9 fc ff ff    	jne    4071ba <DoNNetIteration+0x161a>
  4074c1:	eb 9d                	jmp    407460 <DoNNetIteration+0x18c0>
  4074c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4074c8:	83 f8 09             	cmp    $0x9,%eax
  4074cb:	0f 85 11 fe ff ff    	jne    4072e2 <DoNNetIteration+0x1742>
  4074d1:	eb 8d                	jmp    407460 <DoNNetIteration+0x18c0>
  4074d3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4074d8:	83 f8 08             	cmp    $0x8,%eax
  4074db:	0f 85 d9 fd ff ff    	jne    4072ba <DoNNetIteration+0x171a>
  4074e1:	e9 7a ff ff ff       	jmpq   407460 <DoNNetIteration+0x18c0>
  4074e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4074ed:	00 00 00 
  4074f0:	83 f8 07             	cmp    $0x7,%eax
  4074f3:	0f 85 99 fd ff ff    	jne    407292 <DoNNetIteration+0x16f2>
  4074f9:	e9 62 ff ff ff       	jmpq   407460 <DoNNetIteration+0x18c0>
  4074fe:	66 90                	xchg   %ax,%ax
  407500:	83 f8 05             	cmp    $0x5,%eax
  407503:	0f 85 35 fd ff ff    	jne    40723e <DoNNetIteration+0x169e>
  407509:	e9 52 ff ff ff       	jmpq   407460 <DoNNetIteration+0x18c0>
  40750e:	66 90                	xchg   %ax,%ax
  407510:	83 f8 04             	cmp    $0x4,%eax
  407513:	0f 85 f9 fc ff ff    	jne    407212 <DoNNetIteration+0x1672>
  407519:	e9 42 ff ff ff       	jmpq   407460 <DoNNetIteration+0x18c0>
  40751e:	66 90                	xchg   %ax,%ax
  407520:	83 f8 03             	cmp    $0x3,%eax
  407523:	0f 85 bd fc ff ff    	jne    4071e6 <DoNNetIteration+0x1646>
  407529:	e9 32 ff ff ff       	jmpq   407460 <DoNNetIteration+0x18c0>
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  40752e:	31 d2                	xor    %edx,%edx
for (i=0; i<numpats; i++)
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
  407530:	f2 0f 11 05 88 9d 20 	movsd  %xmm0,0x209d88(%rip)        # 6112c0 <worst_error>
  407537:	00 
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  407538:	66 0f 2e 05 78 6d 00 	ucomisd 0x6d78(%rip),%xmm0        # 40e2b8 <jtable.3055+0x1528>
  40753f:	00 
{
	if (tot_out_error[i] > error) error = tot_out_error[i];
	sum += avg_out_error[i];
}
worst_error = error;
average_error = sum/numpats;
  407540:	f2 0f 11 0d 78 cb 20 	movsd  %xmm1,0x20cb78(%rip)        # 6140c0 <average_error>
  407547:	00 
**/
static int check_out_error()
{
int result,i,error;

result  = T;
  407548:	0f 92 c2             	setb   %dl
	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
	 i+1,tot_out_error[i]);
*/

	if (worst_error >= STOP) result = F;
	if (tot_out_error[i] >= 16.0) error = T;
  40754b:	66 0f 2e 15 6d 6d 00 	ucomisd 0x6d6d(%rip),%xmm2        # 40e2c0 <jtable.3055+0x1530>
  407552:	00 
  407553:	0f 82 10 ff ff ff    	jb     407469 <DoNNetIteration+0x18c9>
  407559:	e9 a2 fd ff ff       	jmpq   407300 <DoNNetIteration+0x1760>

int i;

error = 0.0;
sum = 0.0;
for (i=0; i<numpats; i++)
  40755e:	66 0f 28 c3          	movapd %xmm3,%xmm0
  407562:	e9 d4 fb ff ff       	jmpq   40713b <DoNNetIteration+0x159b>
  407567:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40756e:	00 00 

0000000000407570 <DoFPUTransIteration>:
** 200.
*/
static ulong DoFPUTransIteration(fardouble *abase,      /* A coeffs. */
			fardouble *bbase,               /* B coeffs. */
			ulong arraysize)                /* # of coeffs */
{
  407570:	41 57                	push   %r15
  407572:	41 56                	push   %r14
unsigned long elapsed;  /* Elapsed time */

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  407574:	31 c0                	xor    %eax,%eax
** 200.
*/
static ulong DoFPUTransIteration(fardouble *abase,      /* A coeffs. */
			fardouble *bbase,               /* B coeffs. */
			ulong arraysize)                /* # of coeffs */
{
  407576:	41 55                	push   %r13
  407578:	41 54                	push   %r12
  40757a:	49 89 fd             	mov    %rdi,%r13
  40757d:	55                   	push   %rbp
  40757e:	53                   	push   %rbx
  40757f:	49 89 f6             	mov    %rsi,%r14
  407582:	49 89 d4             	mov    %rdx,%r12
unsigned long elapsed;  /* Elapsed time */

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  407585:	bb c6 00 00 00       	mov    $0xc6,%ebx
** 200.
*/
static ulong DoFPUTransIteration(fardouble *abase,      /* A coeffs. */
			fardouble *bbase,               /* B coeffs. */
			ulong arraysize)                /* # of coeffs */
{
  40758a:	48 83 ec 48          	sub    $0x48,%rsp
unsigned long elapsed;  /* Elapsed time */

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  40758e:	e8 1d 4c 00 00       	callq  40c1b0 <StartStopwatch>
  407593:	66 0f ef d2          	pxor   %xmm2,%xmm2
  407597:	49 89 c7             	mov    %rax,%r15
  40759a:	f2 0f 10 1d f6 6c 00 	movsd  0x6cf6(%rip),%xmm3        # 40e298 <jtable.3055+0x1508>
  4075a1:	00 
  4075a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
	{
		x+=dx;
  4075a8:	f2 0f 58 15 18 6d 00 	addsd  0x6d18(%rip),%xmm2        # 40e2c8 <jtable.3055+0x1538>
  4075af:	00 
/*
** Use select to pick which function we call.
*/
switch(select)
{
	case 0: return(pow(x+(double)1.0,x));
  4075b0:	f2 0f 10 05 b8 67 00 	movsd  0x67b8(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  4075b7:	00 
  4075b8:	f2 0f 11 5c 24 08    	movsd  %xmm3,0x8(%rsp)
  4075be:	f2 0f 58 c2          	addsd  %xmm2,%xmm0
  4075c2:	66 0f 28 ca          	movapd %xmm2,%xmm1
  4075c6:	f2 0f 11 14 24       	movsd  %xmm2,(%rsp)
  4075cb:	e8 80 99 ff ff       	callq  400f50 <pow@plt>
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  4075d0:	f2 0f 10 5c 24 08    	movsd  0x8(%rsp),%xmm3
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  4075d6:	83 eb 01             	sub    $0x1,%ebx
  4075d9:	f2 0f 10 14 24       	movsd  (%rsp),%xmm2
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  4075de:	f2 0f 58 d8          	addsd  %xmm0,%xmm3
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  4075e2:	75 c4                	jne    4075a8 <DoFPUTransIteration+0x38>
	}
}
/*
** Finish computation
*/
rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
  4075e4:	f2 0f 58 1d e4 6c 00 	addsd  0x6ce4(%rip),%xmm3        # 40e2d0 <jtable.3055+0x1540>
  4075eb:	00 
** ( 2 * pi ) / period...and since the period
** is 2, omega is simply pi.
*/
omega=(double)3.1415926535897932;

for(i=1;i<arraysize;i++)
  4075ec:	49 83 fc 01          	cmp    $0x1,%r12
/*
** Calculate the fourier series.  Begin by
** calculating A[0].
*/

*abase=TrapezoidIntegrate((double)0.0,
  4075f0:	f2 0f 59 1d d0 6c 00 	mulsd  0x6cd0(%rip),%xmm3        # 40e2c8 <jtable.3055+0x1538>
  4075f7:	00 
  4075f8:	f2 0f 59 1d 98 6c 00 	mulsd  0x6c98(%rip),%xmm3        # 40e298 <jtable.3055+0x1508>
  4075ff:	00 
  407600:	f2 41 0f 11 5d 00    	movsd  %xmm3,0x0(%r13)
** ( 2 * pi ) / period...and since the period
** is 2, omega is simply pi.
*/
omega=(double)3.1415926535897932;

for(i=1;i<arraysize;i++)
  407606:	0f 86 cd 02 00 00    	jbe    4078d9 <DoFPUTransIteration+0x369>
  40760c:	bd 01 00 00 00       	mov    $0x1,%ebp
  407611:	f2 0f 10 05 57 67 00 	movsd  0x6757(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  407618:	00 
	** Calculate A[i] terms.  Note, once again, that we
	** can ignore the 2/period term outside the integral
	** since the period is 2 and the term cancels itself
	** out.
	*/
	*(abase+i)=TrapezoidIntegrate((double)0.0,
  407619:	48 85 ed             	test   %rbp,%rbp
** ( 2 * pi ) / period...and since the period
** is 2, omega is simply pi.
*/
omega=(double)3.1415926535897932;

for(i=1;i<arraysize;i++)
  40761c:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
  407623:	00 00 
	** Calculate A[i] terms.  Note, once again, that we
	** can ignore the 2/period term outside the integral
	** since the period is 2 and the term cancels itself
	** out.
	*/
	*(abase+i)=TrapezoidIntegrate((double)0.0,
  407625:	0f 88 e4 01 00 00    	js     40780f <DoFPUTransIteration+0x29f>
  40762b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  407630:	66 0f ef c9          	pxor   %xmm1,%xmm1
  407634:	f2 48 0f 2a cd       	cvtsi2sd %rbp,%xmm1
  407639:	f2 0f 59 0d 97 6c 00 	mulsd  0x6c97(%rip),%xmm1        # 40e2d8 <jtable.3055+0x1548>
  407640:	00 
dx=(x1 - x0) / (double)nsteps;

/*
** Initialize the return value.
*/
rvalue=thefunction(x0,omegan,select)/(double)2.0;
  407641:	bb c6 00 00 00       	mov    $0xc6,%ebx
  407646:	f2 0f 59 05 4a 6c 00 	mulsd  0x6c4a(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  40764d:	00 
  40764e:	66 0f ef d2          	pxor   %xmm2,%xmm2
	** Calculate A[i] terms.  Note, once again, that we
	** can ignore the 2/period term outside the integral
	** since the period is 2 and the term cancels itself
	** out.
	*/
	*(abase+i)=TrapezoidIntegrate((double)0.0,
  407652:	f2 0f 11 0c 24       	movsd  %xmm1,(%rsp)
dx=(x1 - x0) / (double)nsteps;

/*
** Initialize the return value.
*/
rvalue=thefunction(x0,omegan,select)/(double)2.0;
  407657:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  40765d:	0f 1f 00             	nopl   (%rax)
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
	{
		x+=dx;
  407660:	f2 0f 58 15 60 6c 00 	addsd  0x6c60(%rip),%xmm2        # 40e2c8 <jtable.3055+0x1538>
  407667:	00 
*/
switch(select)
{
	case 0: return(pow(x+(double)1.0,x));

	case 1: return(pow(x+(double)1.0,x) * cos(omegan * x));
  407668:	f2 0f 10 05 00 67 00 	movsd  0x6700(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  40766f:	00 
  407670:	f2 0f 58 c2          	addsd  %xmm2,%xmm0
  407674:	66 0f 28 ca          	movapd %xmm2,%xmm1
  407678:	f2 0f 11 54 24 18    	movsd  %xmm2,0x18(%rsp)
  40767e:	e8 cd 98 ff ff       	callq  400f50 <pow@plt>
  407683:	f2 0f 10 54 24 18    	movsd  0x18(%rsp),%xmm2
  407689:	f2 0f 10 24 24       	movsd  (%rsp),%xmm4
  40768e:	f2 0f 11 44 24 10    	movsd  %xmm0,0x10(%rsp)
  407694:	f2 0f 59 e2          	mulsd  %xmm2,%xmm4
  407698:	66 0f 28 c4          	movapd %xmm4,%xmm0
  40769c:	e8 cf 98 ff ff       	callq  400f70 <cos@plt>
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  4076a1:	f2 0f 59 44 24 10    	mulsd  0x10(%rsp),%xmm0
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  4076a7:	83 eb 01             	sub    $0x1,%ebx
  4076aa:	f2 0f 10 54 24 18    	movsd  0x18(%rsp),%xmm2
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  4076b0:	f2 0f 58 44 24 08    	addsd  0x8(%rsp),%xmm0
  4076b6:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  4076bc:	75 a2                	jne    407660 <DoFPUTransIteration+0xf0>
  4076be:	f2 0f 10 3c 24       	movsd  (%rsp),%xmm7
  4076c3:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
  4076c8:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
dx=(x1 - x0) / (double)nsteps;

/*
** Initialize the return value.
*/
rvalue=thefunction(x0,omegan,select)/(double)2.0;
  4076cd:	bb c6 00 00 00       	mov    $0xc6,%ebx
  4076d2:	66 0f 28 c7          	movapd %xmm7,%xmm0
  4076d6:	f2 0f 58 c7          	addsd  %xmm7,%xmm0
  4076da:	e8 81 98 ff ff       	callq  400f60 <sincos@plt>
	}
}
/*
** Finish computation
*/
rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
  4076df:	f2 0f 10 05 f9 6b 00 	movsd  0x6bf9(%rip),%xmm0        # 40e2e0 <jtable.3055+0x1550>
  4076e6:	00 
dx=(x1 - x0) / (double)nsteps;

/*
** Initialize the return value.
*/
rvalue=thefunction(x0,omegan,select)/(double)2.0;
  4076e7:	f2 0f 10 1d a9 6b 00 	movsd  0x6ba9(%rip),%xmm3        # 40e298 <jtable.3055+0x1508>
  4076ee:	00 
	}
}
/*
** Finish computation
*/
rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
  4076ef:	f2 0f 59 44 24 30    	mulsd  0x30(%rsp),%xmm0
dx=(x1 - x0) / (double)nsteps;

/*
** Initialize the return value.
*/
rvalue=thefunction(x0,omegan,select)/(double)2.0;
  4076f5:	f2 0f 59 5c 24 28    	mulsd  0x28(%rsp),%xmm3
  4076fb:	f2 0f 10 4c 24 38    	movsd  0x38(%rsp),%xmm1
  407701:	66 0f ef d2          	pxor   %xmm2,%xmm2
  407705:	f2 0f 11 4c 24 20    	movsd  %xmm1,0x20(%rsp)
	}
}
/*
** Finish computation
*/
rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
  40770b:	f2 0f 59 05 85 6b 00 	mulsd  0x6b85(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  407712:	00 
  407713:	f2 0f 58 44 24 08    	addsd  0x8(%rsp),%xmm0
	** Calculate A[i] terms.  Note, once again, that we
	** can ignore the 2/period term outside the integral
	** since the period is 2 and the term cancels itself
	** out.
	*/
	*(abase+i)=TrapezoidIntegrate((double)0.0,
  407719:	f2 0f 59 05 a7 6b 00 	mulsd  0x6ba7(%rip),%xmm0        # 40e2c8 <jtable.3055+0x1538>
  407720:	00 
  407721:	f2 41 0f 11 44 ed 00 	movsd  %xmm0,0x0(%r13,%rbp,8)
  407728:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40772f:	00 
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
	{
		x+=dx;
  407730:	f2 0f 58 15 90 6b 00 	addsd  0x6b90(%rip),%xmm2        # 40e2c8 <jtable.3055+0x1538>
  407737:	00 
{
	case 0: return(pow(x+(double)1.0,x));

	case 1: return(pow(x+(double)1.0,x) * cos(omegan * x));

	case 2: return(pow(x+(double)1.0,x) * sin(omegan * x));
  407738:	f2 0f 10 05 30 66 00 	movsd  0x6630(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  40773f:	00 
  407740:	f2 0f 11 5c 24 18    	movsd  %xmm3,0x18(%rsp)
  407746:	f2 0f 58 c2          	addsd  %xmm2,%xmm0
  40774a:	66 0f 28 ca          	movapd %xmm2,%xmm1
  40774e:	f2 0f 11 54 24 10    	movsd  %xmm2,0x10(%rsp)
  407754:	e8 f7 97 ff ff       	callq  400f50 <pow@plt>
  407759:	f2 0f 10 54 24 10    	movsd  0x10(%rsp),%xmm2
  40775f:	f2 0f 10 2c 24       	movsd  (%rsp),%xmm5
  407764:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
  40776a:	f2 0f 59 ea          	mulsd  %xmm2,%xmm5
  40776e:	66 0f 28 c5          	movapd %xmm5,%xmm0
  407772:	e8 d9 98 ff ff       	callq  401050 <sin@plt>
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  407777:	f2 0f 59 44 24 08    	mulsd  0x8(%rsp),%xmm0
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  40777d:	83 eb 01             	sub    $0x1,%ebx
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  407780:	f2 0f 10 5c 24 18    	movsd  0x18(%rsp),%xmm3
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  407786:	f2 0f 10 54 24 10    	movsd  0x10(%rsp),%xmm2
	{
		x+=dx;
		rvalue+=thefunction(x,omegan,select);
  40778c:	f2 0f 58 d8          	addsd  %xmm0,%xmm3
/*
** Compute the other terms of the integral.
*/
if(nsteps!=1)
{       --nsteps;               /* Already done 1 step */
	while(--nsteps )
  407790:	75 9e                	jne    407730 <DoFPUTransIteration+0x1c0>
	}
}
/*
** Finish computation
*/
rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
  407792:	f2 0f 10 05 46 6b 00 	movsd  0x6b46(%rip),%xmm0        # 40e2e0 <jtable.3055+0x1550>
  407799:	00 
  40779a:	f2 0f 59 44 24 20    	mulsd  0x20(%rsp),%xmm0
  4077a0:	f2 0f 59 05 f0 6a 00 	mulsd  0x6af0(%rip),%xmm0        # 40e298 <jtable.3055+0x1508>
  4077a7:	00 
  4077a8:	f2 0f 58 d8          	addsd  %xmm0,%xmm3
			1);

	/*
	** Calculate the B[i] terms.
	*/
	*(bbase+i)=TrapezoidIntegrate((double)0.0,
  4077ac:	f2 0f 59 1d 14 6b 00 	mulsd  0x6b14(%rip),%xmm3        # 40e2c8 <jtable.3055+0x1538>
  4077b3:	00 
  4077b4:	f2 41 0f 11 1c ee    	movsd  %xmm3,(%r14,%rbp,8)
** ( 2 * pi ) / period...and since the period
** is 2, omega is simply pi.
*/
omega=(double)3.1415926535897932;

for(i=1;i<arraysize;i++)
  4077ba:	48 83 c5 01          	add    $0x1,%rbp
  4077be:	49 39 ec             	cmp    %rbp,%r12
  4077c1:	0f 84 87 00 00 00    	je     40784e <DoFPUTransIteration+0x2de>
  4077c7:	48 85 ed             	test   %rbp,%rbp
  4077ca:	78 64                	js     407830 <DoFPUTransIteration+0x2c0>
  4077cc:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4077d0:	f2 48 0f 2a c5       	cvtsi2sd %rbp,%xmm0
  4077d5:	f2 0f 59 05 fb 6a 00 	mulsd  0x6afb(%rip),%xmm0        # 40e2d8 <jtable.3055+0x1548>
  4077dc:	00 
  4077dd:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
  4077e2:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
  4077e7:	66 0f ef ff          	pxor   %xmm7,%xmm7
  4077eb:	f2 0f 59 c7          	mulsd  %xmm7,%xmm0
  4077ef:	e8 6c 97 ff ff       	callq  400f60 <sincos@plt>
  4077f4:	f2 0f 10 64 24 38    	movsd  0x38(%rsp),%xmm4
	** Calculate A[i] terms.  Note, once again, that we
	** can ignore the 2/period term outside the integral
	** since the period is 2 and the term cancels itself
	** out.
	*/
	*(abase+i)=TrapezoidIntegrate((double)0.0,
  4077fa:	48 85 ed             	test   %rbp,%rbp
  4077fd:	f2 0f 10 44 24 30    	movsd  0x30(%rsp),%xmm0
  407803:	f2 0f 11 64 24 28    	movsd  %xmm4,0x28(%rsp)
  407809:	0f 89 21 fe ff ff    	jns    407630 <DoFPUTransIteration+0xc0>
  40780f:	48 89 e8             	mov    %rbp,%rax
  407812:	48 89 ea             	mov    %rbp,%rdx
  407815:	66 0f ef c9          	pxor   %xmm1,%xmm1
  407819:	48 d1 e8             	shr    %rax
  40781c:	83 e2 01             	and    $0x1,%edx
  40781f:	48 09 d0             	or     %rdx,%rax
  407822:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
  407827:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
  40782b:	e9 09 fe ff ff       	jmpq   407639 <DoFPUTransIteration+0xc9>
  407830:	48 89 e8             	mov    %rbp,%rax
  407833:	48 89 ea             	mov    %rbp,%rdx
  407836:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40783a:	48 d1 e8             	shr    %rax
  40783d:	83 e2 01             	and    $0x1,%edx
  407840:	48 09 d0             	or     %rdx,%rax
  407843:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  407848:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40784c:	eb 87                	jmp    4077d5 <DoFPUTransIteration+0x265>
  40784e:	bf 26 de 40 00       	mov    $0x40de26,%edi
  407853:	e8 38 96 ff ff       	callq  400e90 <puts@plt>
dx=(x1 - x0) / (double)nsteps;

/*
** Initialize the return value.
*/
rvalue=thefunction(x0,omegan,select)/(double)2.0;
  407858:	31 db                	xor    %ebx,%ebx
  40785a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  407860:	f2 41 0f 10 44 dd 00 	movsd  0x0(%r13,%rbx,8),%xmm0
  407867:	be 2d de 40 00       	mov    $0x40de2d,%esi
  40786c:	bf 01 00 00 00       	mov    $0x1,%edi
  407871:	b8 01 00 00 00       	mov    $0x1,%eax
  407876:	48 83 c3 01          	add    $0x1,%rbx
  40787a:	e8 91 97 ff ff       	callq  401010 <__printf_chk@plt>
}
#ifdef DEBUG
{
  int i;
  printf("\nA[i]=\n");
  for (i=0;i<arraysize;i++) printf("%7.3g ",abase[i]);
  40787f:	49 39 dc             	cmp    %rbx,%r12
  407882:	75 dc                	jne    407860 <DoFPUTransIteration+0x2f0>
  407884:	31 c0                	xor    %eax,%eax
  407886:	be 34 de 40 00       	mov    $0x40de34,%esi
  40788b:	bf 01 00 00 00       	mov    $0x1,%edi
  407890:	e8 7b 97 ff ff       	callq  401010 <__printf_chk@plt>
  printf("\nB[i]=\n(undefined) ");
  for (i=1;i<arraysize;i++) printf("%7.3g ",bbase[i]);
  407895:	49 83 fc 01          	cmp    $0x1,%r12
  407899:	74 28                	je     4078c3 <DoFPUTransIteration+0x353>
  40789b:	bb 01 00 00 00       	mov    $0x1,%ebx
  4078a0:	f2 41 0f 10 04 de    	movsd  (%r14,%rbx,8),%xmm0
  4078a6:	be 2d de 40 00       	mov    $0x40de2d,%esi
  4078ab:	bf 01 00 00 00       	mov    $0x1,%edi
  4078b0:	b8 01 00 00 00       	mov    $0x1,%eax
  4078b5:	48 83 c3 01          	add    $0x1,%rbx
  4078b9:	e8 52 97 ff ff       	callq  401010 <__printf_chk@plt>
  4078be:	49 39 dc             	cmp    %rbx,%r12
  4078c1:	75 dd                	jne    4078a0 <DoFPUTransIteration+0x330>
#endif
/*
** All done, stop the stopwatch
*/
return(StopStopwatch(elapsed));
}
  4078c3:	48 83 c4 48          	add    $0x48,%rsp
}
#endif
/*
** All done, stop the stopwatch
*/
return(StopStopwatch(elapsed));
  4078c7:	4c 89 ff             	mov    %r15,%rdi
}
  4078ca:	5b                   	pop    %rbx
  4078cb:	5d                   	pop    %rbp
  4078cc:	41 5c                	pop    %r12
  4078ce:	41 5d                	pop    %r13
  4078d0:	41 5e                	pop    %r14
  4078d2:	41 5f                	pop    %r15
}
#endif
/*
** All done, stop the stopwatch
*/
return(StopStopwatch(elapsed));
  4078d4:	e9 e7 48 00 00       	jmpq   40c1c0 <StopStopwatch>
  4078d9:	bf 26 de 40 00       	mov    $0x40de26,%edi
  4078de:	e8 ad 95 ff ff       	callq  400e90 <puts@plt>
}
#ifdef DEBUG
{
  int i;
  printf("\nA[i]=\n");
  for (i=0;i<arraysize;i++) printf("%7.3g ",abase[i]);
  4078e3:	4d 85 e4             	test   %r12,%r12
  4078e6:	0f 85 6c ff ff ff    	jne    407858 <DoFPUTransIteration+0x2e8>
  4078ec:	be 34 de 40 00       	mov    $0x40de34,%esi
  4078f1:	bf 01 00 00 00       	mov    $0x1,%edi
  4078f6:	31 c0                	xor    %eax,%eax
  4078f8:	e8 13 97 ff ff       	callq  401010 <__printf_chk@plt>
  4078fd:	eb c4                	jmp    4078c3 <DoFPUTransIteration+0x353>
  4078ff:	90                   	nop

0000000000407900 <cipher_idea>:
** IDEA encryption/decryption algorithm.
*/
static void cipher_idea(u16 in[4],
		u16 out[4],
		register IDEAkey Z)
{
  407900:	41 56                	push   %r14
  407902:	41 55                	push   %r13
int r=ROUNDS;

x1=*in++;
x2=*in++;
x3=*in++;
x4=*in;
  407904:	48 89 d1             	mov    %rdx,%rcx
** IDEA encryption/decryption algorithm.
*/
static void cipher_idea(u16 in[4],
		u16 out[4],
		register IDEAkey Z)
{
  407907:	41 54                	push   %r12
  407909:	55                   	push   %rbp
  40790a:	48 8d 6a 60          	lea    0x60(%rdx),%rbp
  40790e:	53                   	push   %rbx
register u16 x1, x2, x3, x4, t1, t2;
/* register u16 t16;
register u16 t32; */
int r=ROUNDS;

x1=*in++;
  40790f:	44 0f b7 37          	movzwl (%rdi),%r14d
	}
	else
		return(1-a);
}
else
	return(1-b);
  407913:	41 b8 01 00 00 00    	mov    $0x1,%r8d
/* register u16 t16;
register u16 t32; */
int r=ROUNDS;

x1=*in++;
x2=*in++;
  407919:	44 0f b7 5f 02       	movzwl 0x2(%rdi),%r11d
x3=*in++;
  40791e:	0f b7 47 04          	movzwl 0x4(%rdi),%eax
x4=*in;
  407922:	44 0f b7 6f 06       	movzwl 0x6(%rdi),%r13d
  407927:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40792e:	00 00 

do {
	MUL(x1,*Z++);
  407930:	44 0f b7 11          	movzwl (%rcx),%r10d
	}
	else
		return(1-a);
}
else
	return(1-b);
  407934:	45 89 c1             	mov    %r8d,%r9d
  407937:	45 29 d1             	sub    %r10d,%r9d
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  40793a:	66 45 85 f6          	test   %r14w,%r14w
  40793e:	74 2f                	je     40796f <cipher_idea+0x6f>
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
	}
	else
		return(1-a);
  407940:	45 89 c1             	mov    %r8d,%r9d
  407943:	45 29 f1             	sub    %r14d,%r9d
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
  407946:	66 45 85 d2          	test   %r10w,%r10w
  40794a:	74 23                	je     40796f <cipher_idea+0x6f>
	{       p=(u32)(a*b);
  40794c:	45 0f b7 f6          	movzwl %r14w,%r14d
  407950:	45 0f af d6          	imul   %r14d,%r10d
		b=low16(p);
		a=(u16)(p>>16);
  407954:	44 89 d7             	mov    %r10d,%edi
		return(b-a+(b<a));
  407957:	45 89 d1             	mov    %r10d,%r9d
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  40795a:	c1 ef 10             	shr    $0x10,%edi
		return(b-a+(b<a));
  40795d:	41 29 f9             	sub    %edi,%r9d
  407960:	66 41 39 fa          	cmp    %di,%r10w
  407964:	40 0f 92 c7          	setb   %dil
  407968:	40 0f b6 ff          	movzbl %dil,%edi
  40796c:	41 01 f9             	add    %edi,%r9d
x4=*in;

do {
	MUL(x1,*Z++);
	x2+=*Z++;
	x3+=*Z++;
  40796f:	66 03 41 04          	add    0x4(%rcx),%ax
x3=*in++;
x4=*in;

do {
	MUL(x1,*Z++);
	x2+=*Z++;
  407973:	44 89 db             	mov    %r11d,%ebx
	}
	else
		return(1-a);
}
else
	return(1-b);
  407976:	45 89 c4             	mov    %r8d,%r12d
x3=*in++;
x4=*in;

do {
	MUL(x1,*Z++);
	x2+=*Z++;
  407979:	66 03 59 02          	add    0x2(%rcx),%bx
	x3+=*Z++;
  40797d:	41 89 c3             	mov    %eax,%r11d
	MUL(x4,*Z++);
  407980:	0f b7 41 06          	movzwl 0x6(%rcx),%eax
	}
	else
		return(1-a);
}
else
	return(1-b);
  407984:	41 29 c4             	sub    %eax,%r12d
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  407987:	66 45 85 ed          	test   %r13w,%r13w
  40798b:	74 26                	je     4079b3 <cipher_idea+0xb3>
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
	}
	else
		return(1-a);
  40798d:	45 89 c4             	mov    %r8d,%r12d
  407990:	45 29 ec             	sub    %r13d,%r12d
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
  407993:	66 85 c0             	test   %ax,%ax
  407996:	74 1b                	je     4079b3 <cipher_idea+0xb3>
	{       p=(u32)(a*b);
  407998:	41 0f af c5          	imul   %r13d,%eax
		b=low16(p);
		a=(u16)(p>>16);
  40799c:	89 c7                	mov    %eax,%edi
		return(b-a+(b<a));
  40799e:	41 89 c4             	mov    %eax,%r12d
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  4079a1:	c1 ef 10             	shr    $0x10,%edi
		return(b-a+(b<a));
  4079a4:	41 29 fc             	sub    %edi,%r12d
  4079a7:	66 39 f8             	cmp    %di,%ax
  4079aa:	0f 92 c0             	setb   %al
  4079ad:	0f b6 c0             	movzbl %al,%eax
  4079b0:	41 01 c4             	add    %eax,%r12d
	x2+=*Z++;
	x3+=*Z++;
	MUL(x4,*Z++);

	t2=x1^x3;
	MUL(t2,*Z++);
  4079b3:	0f b7 79 08          	movzwl 0x8(%rcx),%edi
	}
	else
		return(1-a);
}
else
	return(1-b);
  4079b7:	44 89 c0             	mov    %r8d,%eax
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  4079ba:	45 89 da             	mov    %r11d,%r10d
	}
	else
		return(1-a);
}
else
	return(1-b);
  4079bd:	29 f8                	sub    %edi,%eax
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  4079bf:	66 45 31 ca          	xor    %r9w,%r10w
  4079c3:	74 2c                	je     4079f1 <cipher_idea+0xf1>
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
	}
	else
		return(1-a);
  4079c5:	44 89 c0             	mov    %r8d,%eax
  4079c8:	44 29 d0             	sub    %r10d,%eax
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
  4079cb:	66 85 ff             	test   %di,%di
  4079ce:	74 21                	je     4079f1 <cipher_idea+0xf1>
	{       p=(u32)(a*b);
  4079d0:	45 0f b7 d2          	movzwl %r10w,%r10d
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
  4079d4:	31 c0                	xor    %eax,%eax
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
  4079d6:	41 0f af fa          	imul   %r10d,%edi
		b=low16(p);
		a=(u16)(p>>16);
  4079da:	41 89 fa             	mov    %edi,%r10d
		return(b-a+(b<a));
  4079dd:	41 89 fd             	mov    %edi,%r13d
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  4079e0:	41 c1 ea 10          	shr    $0x10,%r10d
		return(b-a+(b<a));
  4079e4:	45 29 d5             	sub    %r10d,%r13d
  4079e7:	66 44 39 d7          	cmp    %r10w,%di
  4079eb:	0f 92 c0             	setb   %al
  4079ee:	44 01 e8             	add    %r13d,%eax
  4079f1:	48 83 c1 0c          	add    $0xc,%rcx
	MUL(x4,*Z++);

	t2=x1^x3;
	MUL(t2,*Z++);
	t1=t2+(x2^x4);
	MUL(t1,*Z++);
  4079f5:	44 0f b7 69 fe       	movzwl -0x2(%rcx),%r13d
	x3+=*Z++;
	MUL(x4,*Z++);

	t2=x1^x3;
	MUL(t2,*Z++);
	t1=t2+(x2^x4);
  4079fa:	41 89 da             	mov    %ebx,%r10d
  4079fd:	45 31 e2             	xor    %r12d,%r10d
	}
	else
		return(1-a);
}
else
	return(1-b);
  407a00:	44 89 c7             	mov    %r8d,%edi
  407a03:	44 29 ef             	sub    %r13d,%edi
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  407a06:	66 41 01 c2          	add    %ax,%r10w
  407a0a:	74 2e                	je     407a3a <cipher_idea+0x13a>
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
	}
	else
		return(1-a);
  407a0c:	44 89 c7             	mov    %r8d,%edi
  407a0f:	44 29 d7             	sub    %r10d,%edi
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
  407a12:	66 45 85 ed          	test   %r13w,%r13w
  407a16:	74 22                	je     407a3a <cipher_idea+0x13a>
	{       p=(u32)(a*b);
  407a18:	45 0f b7 d2          	movzwl %r10w,%r10d
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
  407a1c:	31 ff                	xor    %edi,%edi
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
  407a1e:	45 0f af d5          	imul   %r13d,%r10d
		b=low16(p);
		a=(u16)(p>>16);
  407a22:	45 89 d5             	mov    %r10d,%r13d
		return(b-a+(b<a));
  407a25:	45 89 d6             	mov    %r10d,%r14d
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  407a28:	41 c1 ed 10          	shr    $0x10,%r13d
		return(b-a+(b<a));
  407a2c:	45 29 ee             	sub    %r13d,%r14d
  407a2f:	66 45 39 ea          	cmp    %r13w,%r10w
  407a33:	40 0f 92 c7          	setb   %dil
  407a37:	44 01 f7             	add    %r14d,%edi

	t2=x1^x3;
	MUL(t2,*Z++);
	t1=t2+(x2^x4);
	MUL(t1,*Z++);
	t2=t1+t2;
  407a3a:	01 f8                	add    %edi,%eax

	x1^=t1;
  407a3c:	45 89 ce             	mov    %r9d,%r14d
	x4^=t2;

	t2^=x2;
	x2=x3^t1;
  407a3f:	41 31 fb             	xor    %edi,%r11d
	t1=t2+(x2^x4);
	MUL(t1,*Z++);
	t2=t1+t2;

	x1^=t1;
	x4^=t2;
  407a42:	41 31 c4             	xor    %eax,%r12d
	MUL(t2,*Z++);
	t1=t2+(x2^x4);
	MUL(t1,*Z++);
	t2=t1+t2;

	x1^=t1;
  407a45:	41 31 fe             	xor    %edi,%r14d
	x4^=t2;

	t2^=x2;
  407a48:	31 d8                	xor    %ebx,%eax
	x2=x3^t1;
	x3=t2;
} while(--r);
  407a4a:	48 39 cd             	cmp    %rcx,%rbp
	t1=t2+(x2^x4);
	MUL(t1,*Z++);
	t2=t1+t2;

	x1^=t1;
	x4^=t2;
  407a4d:	45 0f b7 ec          	movzwl %r12w,%r13d

	t2^=x2;
	x2=x3^t1;
	x3=t2;
} while(--r);
  407a51:	0f 85 d9 fe ff ff    	jne    407930 <cipher_idea+0x30>
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  407a57:	66 45 85 f6          	test   %r14w,%r14w

	t2^=x2;
	x2=x3^t1;
	x3=t2;
} while(--r);
MUL(x1,*Z++);
  407a5b:	0f b7 7a 60          	movzwl 0x60(%rdx),%edi
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  407a5f:	74 2f                	je     407a90 <cipher_idea+0x190>
{       if(b)
  407a61:	66 85 ff             	test   %di,%di
  407a64:	0f 84 a6 00 00 00    	je     407b10 <cipher_idea+0x210>
	{       p=(u32)(a*b);
  407a6a:	45 0f b7 f6          	movzwl %r14w,%r14d
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
  407a6e:	31 c9                	xor    %ecx,%ecx
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
  407a70:	41 0f af fe          	imul   %r14d,%edi
		b=low16(p);
		a=(u16)(p>>16);
  407a74:	41 89 f8             	mov    %edi,%r8d
		return(b-a+(b<a));
  407a77:	41 89 f9             	mov    %edi,%r9d
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  407a7a:	41 c1 e8 10          	shr    $0x10,%r8d
		return(b-a+(b<a));
  407a7e:	45 29 c1             	sub    %r8d,%r9d
  407a81:	66 44 39 c7          	cmp    %r8w,%di
  407a85:	0f 92 c1             	setb   %cl
  407a88:	44 01 c9             	add    %r9d,%ecx
  407a8b:	eb 0a                	jmp    407a97 <cipher_idea+0x197>
  407a8d:	0f 1f 00             	nopl   (%rax)
	}
	else
		return(1-a);
}
else
	return(1-b);
  407a90:	b9 01 00 00 00       	mov    $0x1,%ecx
  407a95:	29 f9                	sub    %edi,%ecx
	t2^=x2;
	x2=x3^t1;
	x3=t2;
} while(--r);
MUL(x1,*Z++);
*out++=x1;
  407a97:	66 89 0e             	mov    %cx,(%rsi)
*out++=x3+*Z++;
  407a9a:	66 03 42 62          	add    0x62(%rdx),%ax
  407a9e:	66 89 46 02          	mov    %ax,0x2(%rsi)
*out++=x2+*Z++;
  407aa2:	66 44 03 5a 64       	add    0x64(%rdx),%r11w
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  407aa7:	66 45 85 ed          	test   %r13w,%r13w
	x3=t2;
} while(--r);
MUL(x1,*Z++);
*out++=x1;
*out++=x3+*Z++;
*out++=x2+*Z++;
  407aab:	66 44 89 5e 04       	mov    %r11w,0x4(%rsi)
MUL(x4,*Z);
  407ab0:	0f b7 52 66          	movzwl 0x66(%rdx),%edx
** branches, and that the compiler doesn't schedule branches.
*/
static u16 mul(register u16 a, register u16 b)
{
register u32 p;
if(a)
  407ab4:	74 2a                	je     407ae0 <cipher_idea+0x1e0>
{       if(b)
  407ab6:	66 85 d2             	test   %dx,%dx
  407ab9:	74 3d                	je     407af8 <cipher_idea+0x1f8>
	{       p=(u32)(a*b);
  407abb:	41 0f af d5          	imul   %r13d,%edx
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
  407abf:	31 c0                	xor    %eax,%eax
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
return;
}
  407ac1:	5b                   	pop    %rbx
  407ac2:	5d                   	pop    %rbp
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  407ac3:	89 d1                	mov    %edx,%ecx
		return(b-a+(b<a));
  407ac5:	89 d7                	mov    %edx,%edi
register u32 p;
if(a)
{       if(b)
	{       p=(u32)(a*b);
		b=low16(p);
		a=(u16)(p>>16);
  407ac7:	c1 e9 10             	shr    $0x10,%ecx
		return(b-a+(b<a));
  407aca:	29 cf                	sub    %ecx,%edi
  407acc:	66 39 ca             	cmp    %cx,%dx
  407acf:	0f 92 c0             	setb   %al
  407ad2:	01 f8                	add    %edi,%eax
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
return;
}
  407ad4:	41 5c                	pop    %r12
MUL(x1,*Z++);
*out++=x1;
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
  407ad6:	66 89 46 06          	mov    %ax,0x6(%rsi)
return;
}
  407ada:	41 5d                	pop    %r13
  407adc:	41 5e                	pop    %r14
  407ade:	c3                   	retq   
  407adf:	90                   	nop
	}
	else
		return(1-a);
}
else
	return(1-b);
  407ae0:	b8 01 00 00 00       	mov    $0x1,%eax
  407ae5:	29 d0                	sub    %edx,%eax
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
return;
}
  407ae7:	5b                   	pop    %rbx
MUL(x1,*Z++);
*out++=x1;
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
  407ae8:	66 89 46 06          	mov    %ax,0x6(%rsi)
return;
}
  407aec:	5d                   	pop    %rbp
  407aed:	41 5c                	pop    %r12
  407aef:	41 5d                	pop    %r13
  407af1:	41 5e                	pop    %r14
  407af3:	c3                   	retq   
  407af4:	0f 1f 40 00          	nopl   0x0(%rax)
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
	}
	else
		return(1-a);
  407af8:	b8 01 00 00 00       	mov    $0x1,%eax
  407afd:	44 29 e8             	sub    %r13d,%eax
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
return;
}
  407b00:	5b                   	pop    %rbx
MUL(x1,*Z++);
*out++=x1;
*out++=x3+*Z++;
*out++=x2+*Z++;
MUL(x4,*Z);
*out=x4;
  407b01:	66 89 46 06          	mov    %ax,0x6(%rsi)
return;
}
  407b05:	5d                   	pop    %rbp
  407b06:	41 5c                	pop    %r12
  407b08:	41 5d                	pop    %r13
  407b0a:	41 5e                	pop    %r14
  407b0c:	c3                   	retq   
  407b0d:	0f 1f 00             	nopl   (%rax)
		b=low16(p);
		a=(u16)(p>>16);
		return(b-a+(b<a));
	}
	else
		return(1-a);
  407b10:	b9 01 00 00 00       	mov    $0x1,%ecx
  407b15:	44 29 f1             	sub    %r14d,%ecx
  407b18:	e9 7a ff ff ff       	jmpq   407a97 <cipher_idea+0x197>
  407b1d:	0f 1f 00             	nopl   (%rax)

0000000000407b20 <DoNumSortIteration>:
** elapsed for the iteration.
*/
static ulong DoNumSortIteration(farlong *arraybase,
		ulong arraysize,
		uint numarrays)
{
  407b20:	41 57                	push   %r15
  407b22:	41 56                	push   %r14
  407b24:	41 55                	push   %r13
  407b26:	41 54                	push   %r12
  407b28:	49 89 f5             	mov    %rsi,%r13
  407b2b:	55                   	push   %rbp
  407b2c:	53                   	push   %rbx
  407b2d:	49 89 fc             	mov    %rdi,%r12
farlong *darray;        /* Destination array pointer */
/*
** Initialize the random number generator
*/
/* randnum(13L); */
randnum((int32)13);
  407b30:	bf 0d 00 00 00       	mov    $0xd,%edi
** elapsed for the iteration.
*/
static ulong DoNumSortIteration(farlong *arraybase,
		ulong arraysize,
		uint numarrays)
{
  407b35:	48 83 ec 38          	sub    $0x38,%rsp
  407b39:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
farlong *darray;        /* Destination array pointer */
/*
** Initialize the random number generator
*/
/* randnum(13L); */
randnum((int32)13);
  407b3d:	e8 9e cc ff ff       	callq  4047e0 <randnum>

/*
** Load up first array with randoms
*/
for(i=0L;i<arraysize;i++)
  407b42:	4d 85 ed             	test   %r13,%r13
  407b45:	74 18                	je     407b5f <DoNumSortIteration+0x3f>
  407b47:	31 db                	xor    %ebx,%ebx
        /* array[i]=randnum(0L); */
	array[i]=randnum((int32)0);
  407b49:	31 ff                	xor    %edi,%edi
  407b4b:	e8 90 cc ff ff       	callq  4047e0 <randnum>
  407b50:	48 98                	cltq   
  407b52:	49 89 04 dc          	mov    %rax,(%r12,%rbx,8)
randnum((int32)13);

/*
** Load up first array with randoms
*/
for(i=0L;i<arraysize;i++)
  407b56:	48 83 c3 01          	add    $0x1,%rbx
  407b5a:	4c 39 eb             	cmp    %r13,%rbx
  407b5d:	75 ea                	jne    407b49 <DoNumSortIteration+0x29>
  407b5f:	4c 89 e5             	mov    %r12,%rbp
  407b62:	4d 89 ee             	mov    %r13,%r14
** Now, if there's more than one array to load, copy the
** first into each of the others.
*/
darray=array;
while(--numarrays)
{       darray+=arraysize;
  407b65:	4a 8d 04 ed 00 00 00 	lea    0x0(,%r13,8),%rax
  407b6c:	00 
  407b6d:	48 c1 e5 3c          	shl    $0x3c,%rbp
  407b71:	44 8b 4c 24 1c       	mov    0x1c(%rsp),%r9d
  407b76:	4d 8d 7c 24 10       	lea    0x10(%r12),%r15
  407b7b:	48 c1 ed 3f          	shr    $0x3f,%rbp
  407b7f:	48 89 c6             	mov    %rax,%rsi
  407b82:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  407b87:	4c 39 ed             	cmp    %r13,%rbp
  407b8a:	4d 8d 44 04 10       	lea    0x10(%r12,%rax,1),%r8
  407b8f:	4c 89 64 24 28       	mov    %r12,0x28(%rsp)
  407b94:	49 0f 47 ed          	cmova  %r13,%rbp
  407b98:	49 29 ee             	sub    %rbp,%r14
  407b9b:	4d 8d 56 fe          	lea    -0x2(%r14),%r10
  407b9f:	49 d1 ea             	shr    %r10
  407ba2:	49 83 c2 01          	add    $0x1,%r10
  407ba6:	4b 8d 04 12          	lea    (%r10,%r10,1),%rax
  407baa:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  407baf:	48 8d 04 ed 00 00 00 	lea    0x0(,%rbp,8),%rax
  407bb6:	00 
  407bb7:	48 89 c7             	mov    %rax,%rdi
  407bba:	4d 8d 1c 04          	lea    (%r12,%rax,1),%r11
  407bbe:	48 89 f0             	mov    %rsi,%rax
  407bc1:	48 01 f7             	add    %rsi,%rdi
/*
** Now, if there's more than one array to load, copy the
** first into each of the others.
*/
darray=array;
while(--numarrays)
  407bc4:	41 83 e9 01          	sub    $0x1,%r9d
{       darray+=arraysize;
  407bc8:	4c 89 e6             	mov    %r12,%rsi
  407bcb:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  407bd0:	48 89 c3             	mov    %rax,%rbx
/*
** Now, if there's more than one array to load, copy the
** first into each of the others.
*/
darray=array;
while(--numarrays)
  407bd3:	0f 84 93 00 00 00    	je     407c6c <DoNumSortIteration+0x14c>
{       darray+=arraysize;
	for(i=0L;i<arraysize;i++)
  407bd9:	4d 85 ed             	test   %r13,%r13
** Now, if there's more than one array to load, copy the
** first into each of the others.
*/
darray=array;
while(--numarrays)
{       darray+=arraysize;
  407bdc:	48 8d 0c 1e          	lea    (%rsi,%rbx,1),%rcx
	for(i=0L;i<arraysize;i++)
  407be0:	74 7a                	je     407c5c <DoNumSortIteration+0x13c>
  407be2:	49 8d 40 f0          	lea    -0x10(%r8),%rax
  407be6:	4c 39 f8             	cmp    %r15,%rax
  407be9:	0f 93 c2             	setae  %dl
  407bec:	4d 39 c4             	cmp    %r8,%r12
  407bef:	0f 93 c0             	setae  %al
  407bf2:	08 c2                	or     %al,%dl
  407bf4:	0f 84 73 01 00 00    	je     407d6d <DoNumSortIteration+0x24d>
  407bfa:	49 83 fd 18          	cmp    $0x18,%r13
  407bfe:	0f 86 69 01 00 00    	jbe    407d6d <DoNumSortIteration+0x24d>
  407c04:	31 ff                	xor    %edi,%edi
  407c06:	48 85 ed             	test   %rbp,%rbp
  407c09:	74 0c                	je     407c17 <DoNumSortIteration+0xf7>
		darray[i]=array[i];
  407c0b:	49 8b 04 24          	mov    (%r12),%rax
** first into each of the others.
*/
darray=array;
while(--numarrays)
{       darray+=arraysize;
	for(i=0L;i<arraysize;i++)
  407c0f:	bf 01 00 00 00       	mov    $0x1,%edi
		darray[i]=array[i];
  407c14:	48 89 01             	mov    %rax,(%rcx)
  407c17:	49 83 fe 01          	cmp    $0x1,%r14
  407c1b:	74 37                	je     407c54 <DoNumSortIteration+0x134>
  407c1d:	48 03 74 24 10       	add    0x10(%rsp),%rsi
** first into each of the others.
*/
darray=array;
while(--numarrays)
{       darray+=arraysize;
	for(i=0L;i<arraysize;i++)
  407c22:	31 c0                	xor    %eax,%eax
  407c24:	31 d2                	xor    %edx,%edx
  407c26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407c2d:	00 00 00 
		darray[i]=array[i];
  407c30:	66 41 0f 6f 04 03    	movdqa (%r11,%rax,1),%xmm0
  407c36:	48 83 c2 01          	add    $0x1,%rdx
  407c3a:	0f 11 04 06          	movups %xmm0,(%rsi,%rax,1)
  407c3e:	48 83 c0 10          	add    $0x10,%rax
  407c42:	4c 39 d2             	cmp    %r10,%rdx
  407c45:	72 e9                	jb     407c30 <DoNumSortIteration+0x110>
  407c47:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  407c4c:	48 01 c7             	add    %rax,%rdi
  407c4f:	49 39 c6             	cmp    %rax,%r14
  407c52:	74 08                	je     407c5c <DoNumSortIteration+0x13c>
  407c54:	49 8b 04 fc          	mov    (%r12,%rdi,8),%rax
  407c58:	48 89 04 f9          	mov    %rax,(%rcx,%rdi,8)
  407c5c:	49 01 d8             	add    %rbx,%r8
/*
** Now, if there's more than one array to load, copy the
** first into each of the others.
*/
darray=array;
while(--numarrays)
  407c5f:	41 83 e9 01          	sub    $0x1,%r9d
{       darray+=arraysize;
  407c63:	48 89 ce             	mov    %rcx,%rsi
/*
** Now, if there's more than one array to load, copy the
** first into each of the others.
*/
darray=array;
while(--numarrays)
  407c66:	0f 85 6d ff ff ff    	jne    407bd9 <DoNumSortIteration+0xb9>
LoadNumArrayWithRand(arraybase,arraysize,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  407c6c:	31 c0                	xor    %eax,%eax
  407c6e:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
  407c73:	49 8d 6d ff          	lea    -0x1(%r13),%rbp
  407c77:	e8 34 45 00 00       	callq  40c1b0 <StartStopwatch>

/*
** Execute a heap of heapsorts
*/
for(i=0;i<numarrays;i++)
  407c7c:	44 8b 4c 24 1c       	mov    0x1c(%rsp),%r9d
LoadNumArrayWithRand(arraybase,arraysize,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  407c81:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

/*
** Execute a heap of heapsorts
*/
for(i=0;i<numarrays;i++)
  407c86:	4d 85 c9             	test   %r9,%r9
  407c89:	0f 84 d8 01 00 00    	je     407e67 <DoNumSortIteration+0x347>
  407c8f:	4c 89 64 24 10       	mov    %r12,0x10(%rsp)
  407c94:	4c 8b 64 24 20       	mov    0x20(%rsp),%r12
  407c99:	49 89 e8             	mov    %rbp,%r8
  407c9c:	49 d1 e8             	shr    %r8
  407c9f:	31 f6                	xor    %esi,%esi
ulong i;                        /* Loop index */

/*
** First, build a heap in the array
*/
for(i=(top/2L); i>0; --i)
  407ca1:	4d 85 c0             	test   %r8,%r8
  407ca4:	4d 89 c7             	mov    %r8,%r15
  407ca7:	0f 84 89 01 00 00    	je     407e36 <DoNumSortIteration+0x316>
  407cad:	0f 1f 00             	nopl   (%rax)
while((i+i)<=j)
{
	k=i+i;
	if(k<j)
		if(array[k]<array[k+1L])
			++k;
  407cb0:	4c 89 f8             	mov    %r15,%rax
  407cb3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	ulong j)                /* Maximum of array */
{
unsigned long k;
long temp;                              /* Used for exchange */

while((i+i)<=j)
  407cb8:	48 8d 0c 00          	lea    (%rax,%rax,1),%rcx
  407cbc:	48 39 e9             	cmp    %rbp,%rcx
  407cbf:	77 34                	ja     407cf5 <DoNumSortIteration+0x1d5>
{
	k=i+i;
	if(k<j)
  407cc1:	0f 82 c9 00 00 00    	jb     407d90 <DoNumSortIteration+0x270>
  407cc7:	48 89 c2             	mov    %rax,%rdx
  407cca:	48 c1 e2 04          	shl    $0x4,%rdx
  407cce:	48 01 da             	add    %rbx,%rdx
  407cd1:	48 8b 3a             	mov    (%rdx),%rdi
		if(array[k]<array[k+1L])
			++k;
	if(array[i]<array[k])
  407cd4:	4c 8d 14 c3          	lea    (%rbx,%rax,8),%r10
  407cd8:	4c 89 e8             	mov    %r13,%rax
  407cdb:	4d 8b 1a             	mov    (%r10),%r11
  407cde:	49 39 fb             	cmp    %rdi,%r11
  407ce1:	7d d5                	jge    407cb8 <DoNumSortIteration+0x198>
	{
		temp=array[k];
		array[k]=array[i];
		array[i]=temp;
  407ce3:	48 89 c8             	mov    %rcx,%rax
		if(array[k]<array[k+1L])
			++k;
	if(array[i]<array[k])
	{
		temp=array[k];
		array[k]=array[i];
  407ce6:	4c 89 1a             	mov    %r11,(%rdx)
		array[i]=temp;
  407ce9:	49 89 3a             	mov    %rdi,(%r10)
	ulong j)                /* Maximum of array */
{
unsigned long k;
long temp;                              /* Used for exchange */

while((i+i)<=j)
  407cec:	48 8d 0c 00          	lea    (%rax,%rax,1),%rcx
  407cf0:	48 39 e9             	cmp    %rbp,%rcx
  407cf3:	76 cc                	jbe    407cc1 <DoNumSortIteration+0x1a1>
ulong i;                        /* Loop index */

/*
** First, build a heap in the array
*/
for(i=(top/2L); i>0; --i)
  407cf5:	49 83 ef 01          	sub    $0x1,%r15
  407cf9:	75 b5                	jne    407cb0 <DoNumSortIteration+0x190>
	if(array[i]<array[k])
	{
		temp=array[k];
		array[k]=array[i];
		array[i]=temp;
		i=k;
  407cfb:	48 89 e9             	mov    %rbp,%rcx
  407cfe:	66 90                	xchg   %ax,%ax
ulong i;                        /* Loop index */

/*
** First, build a heap in the array
*/
for(i=(top/2L); i>0; --i)
  407d00:	31 d2                	xor    %edx,%edx
	ulong j)                /* Maximum of array */
{
unsigned long k;
long temp;                              /* Used for exchange */

while((i+i)<=j)
  407d02:	31 c0                	xor    %eax,%eax
  407d04:	eb 37                	jmp    407d3d <DoNumSortIteration+0x21d>
  407d06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407d0d:	00 00 00 
  407d10:	4c 8d 14 c3          	lea    (%rbx,%rax,8),%r10
  407d14:	49 8b 3a             	mov    (%r10),%rdi
{
	k=i+i;
	if(k<j)
		if(array[k]<array[k+1L])
			++k;
	if(array[i]<array[k])
  407d17:	4c 8d 1c d3          	lea    (%rbx,%rdx,8),%r11
		array[k]=array[i];
		array[i]=temp;
		i=k;
	}
	else
		i=j+1;
  407d1b:	48 8d 51 01          	lea    0x1(%rcx),%rdx
{
	k=i+i;
	if(k<j)
		if(array[k]<array[k+1L])
			++k;
	if(array[i]<array[k])
  407d1f:	4d 8b 33             	mov    (%r11),%r14
  407d22:	49 39 fe             	cmp    %rdi,%r14
  407d25:	7d 09                	jge    407d30 <DoNumSortIteration+0x210>
	{
		temp=array[k];
		array[k]=array[i];
  407d27:	4d 89 32             	mov    %r14,(%r10)
		array[i]=temp;
		i=k;
  407d2a:	48 89 c2             	mov    %rax,%rdx
			++k;
	if(array[i]<array[k])
	{
		temp=array[k];
		array[k]=array[i];
		array[i]=temp;
  407d2d:	49 89 3b             	mov    %rdi,(%r11)
	ulong j)                /* Maximum of array */
{
unsigned long k;
long temp;                              /* Used for exchange */

while((i+i)<=j)
  407d30:	48 8d 04 12          	lea    (%rdx,%rdx,1),%rax
  407d34:	48 39 c8             	cmp    %rcx,%rax
  407d37:	0f 87 8b 00 00 00    	ja     407dc8 <DoNumSortIteration+0x2a8>
{
	k=i+i;
	if(k<j)
  407d3d:	48 39 c8             	cmp    %rcx,%rax
  407d40:	73 ce                	jae    407d10 <DoNumSortIteration+0x1f0>
		if(array[k]<array[k+1L])
  407d42:	4c 8d 1c c5 00 00 00 	lea    0x0(,%rax,8),%r11
  407d49:	00 
  407d4a:	4c 8d 70 01          	lea    0x1(%rax),%r14
  407d4e:	4e 8d 14 1b          	lea    (%rbx,%r11,1),%r10
  407d52:	4e 8d 5c 1b 08       	lea    0x8(%rbx,%r11,1),%r11
  407d57:	49 8b 3a             	mov    (%r10),%rdi
  407d5a:	4d 8b 3b             	mov    (%r11),%r15
  407d5d:	4c 39 ff             	cmp    %r15,%rdi
  407d60:	7d b5                	jge    407d17 <DoNumSortIteration+0x1f7>
  407d62:	4c 89 ff             	mov    %r15,%rdi
  407d65:	4d 89 da             	mov    %r11,%r10
			++k;
  407d68:	4c 89 f0             	mov    %r14,%rax
  407d6b:	eb aa                	jmp    407d17 <DoNumSortIteration+0x1f7>
** first into each of the others.
*/
darray=array;
while(--numarrays)
{       darray+=arraysize;
	for(i=0L;i<arraysize;i++)
  407d6d:	31 c0                	xor    %eax,%eax
  407d6f:	90                   	nop
		darray[i]=array[i];
  407d70:	49 8b 14 c4          	mov    (%r12,%rax,8),%rdx
  407d74:	48 89 14 c1          	mov    %rdx,(%rcx,%rax,8)
** first into each of the others.
*/
darray=array;
while(--numarrays)
{       darray+=arraysize;
	for(i=0L;i<arraysize;i++)
  407d78:	48 83 c0 01          	add    $0x1,%rax
  407d7c:	4c 39 e8             	cmp    %r13,%rax
  407d7f:	75 ef                	jne    407d70 <DoNumSortIteration+0x250>
  407d81:	e9 d6 fe ff ff       	jmpq   407c5c <DoNumSortIteration+0x13c>
  407d86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407d8d:	00 00 00 

while((i+i)<=j)
{
	k=i+i;
	if(k<j)
		if(array[k]<array[k+1L])
  407d90:	49 89 c2             	mov    %rax,%r10
  407d93:	4c 8d 59 01          	lea    0x1(%rcx),%r11
  407d97:	49 c1 e2 04          	shl    $0x4,%r10
  407d9b:	4a 8d 14 13          	lea    (%rbx,%r10,1),%rdx
  407d9f:	4e 8d 54 13 08       	lea    0x8(%rbx,%r10,1),%r10
  407da4:	48 8b 3a             	mov    (%rdx),%rdi
  407da7:	4d 8b 32             	mov    (%r10),%r14
  407daa:	4c 39 f7             	cmp    %r14,%rdi
  407dad:	0f 8d 21 ff ff ff    	jge    407cd4 <DoNumSortIteration+0x1b4>
  407db3:	4c 89 f7             	mov    %r14,%rdi
  407db6:	4c 89 d2             	mov    %r10,%rdx
			++k;
  407db9:	4c 89 d9             	mov    %r11,%rcx
  407dbc:	e9 13 ff ff ff       	jmpq   407cd4 <DoNumSortIteration+0x1b4>
  407dc1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
** array.
*/
for(i=top; i>0; --i)
{       NumSift(array,bottom,i);
	temp=*array;                    /* Perform exchange */
	*array=*(array+i);
  407dc8:	48 8b 14 cb          	mov    (%rbx,%rcx,8),%rdx
** end of the array.  When we get done, we'll have a sorted
** array.
*/
for(i=top; i>0; --i)
{       NumSift(array,bottom,i);
	temp=*array;                    /* Perform exchange */
  407dcc:	48 8b 03             	mov    (%rbx),%rax
	*array=*(array+i);
  407dcf:	48 89 13             	mov    %rdx,(%rbx)
	*(array+i)=temp;
  407dd2:	48 89 04 cb          	mov    %rax,(%rbx,%rcx,8)
/*
** Repeatedly extract maximum from heap and place it at the
** end of the array.  When we get done, we'll have a sorted
** array.
*/
for(i=top; i>0; --i)
  407dd6:	48 83 e9 01          	sub    $0x1,%rcx
  407dda:	0f 85 20 ff ff ff    	jne    407d00 <DoNumSortIteration+0x1e0>
elapsed=StartStopwatch();

/*
** Execute a heap of heapsorts
*/
for(i=0;i<numarrays;i++)
  407de0:	48 83 c6 01          	add    $0x1,%rsi
  407de4:	4c 01 e3             	add    %r12,%rbx
  407de7:	4c 39 ce             	cmp    %r9,%rsi
  407dea:	0f 85 b1 fe ff ff    	jne    407ca1 <DoNumSortIteration+0x181>
  407df0:	4c 8b 64 24 10       	mov    0x10(%rsp),%r12
  407df5:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	NumHeapSort(arraybase+i*arraysize,0L,arraysize-1L);

/*
** Get elapsed time
*/
elapsed=StopStopwatch(elapsed);
  407dfa:	e8 c1 43 00 00       	callq  40c1c0 <StopStopwatch>
  407dff:	48 89 c3             	mov    %rax,%rbx
#ifdef DEBUG
{
	for(i=0;i<arraysize-1;i++)
  407e02:	31 c0                	xor    %eax,%eax
  407e04:	eb 19                	jmp    407e1f <DoNumSortIteration+0x2ff>
  407e06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407e0d:	00 00 00 
	{       /*
		** Compare to check for proper
		** sort.
		*/
		if(arraybase[i+1]<arraybase[i])
  407e10:	48 83 c0 01          	add    $0x1,%rax
  407e14:	49 8b 74 c4 f8       	mov    -0x8(%r12,%rax,8),%rsi
  407e19:	49 39 34 c4          	cmp    %rsi,(%r12,%rax,8)
  407e1d:	7c 32                	jl     407e51 <DoNumSortIteration+0x331>
** Get elapsed time
*/
elapsed=StopStopwatch(elapsed);
#ifdef DEBUG
{
	for(i=0;i<arraysize-1;i++)
  407e1f:	48 39 e8             	cmp    %rbp,%rax
  407e22:	75 ec                	jne    407e10 <DoNumSortIteration+0x2f0>
	}
}
#endif

return(elapsed);
}
  407e24:	48 83 c4 38          	add    $0x38,%rsp
  407e28:	48 89 d8             	mov    %rbx,%rax
  407e2b:	5b                   	pop    %rbx
  407e2c:	5d                   	pop    %rbp
  407e2d:	41 5c                	pop    %r12
  407e2f:	41 5d                	pop    %r13
  407e31:	41 5e                	pop    %r14
  407e33:	41 5f                	pop    %r15
  407e35:	c3                   	retq   
/*
** Repeatedly extract maximum from heap and place it at the
** end of the array.  When we get done, we'll have a sorted
** array.
*/
for(i=top; i>0; --i)
  407e36:	48 85 ed             	test   %rbp,%rbp
  407e39:	0f 85 bc fe ff ff    	jne    407cfb <DoNumSortIteration+0x1db>
elapsed=StartStopwatch();

/*
** Execute a heap of heapsorts
*/
for(i=0;i<numarrays;i++)
  407e3f:	48 83 c6 01          	add    $0x1,%rsi
  407e43:	4c 01 e3             	add    %r12,%rbx
  407e46:	4c 39 ce             	cmp    %r9,%rsi
  407e49:	0f 85 52 fe ff ff    	jne    407ca1 <DoNumSortIteration+0x181>
  407e4f:	eb 9f                	jmp    407df0 <DoNumSortIteration+0x2d0>
  407e51:	bf 48 de 40 00       	mov    $0x40de48,%edi
  407e56:	e8 35 90 ff ff       	callq  400e90 <puts@plt>
		** Compare to check for proper
		** sort.
		*/
		if(arraybase[i+1]<arraybase[i])
		{       printf("Sort Error\n");
			numsort_status=1;
  407e5b:	c7 05 47 88 20 00 01 	movl   $0x1,0x208847(%rip)        # 6106ac <numsort_status>
  407e62:	00 00 00 
  407e65:	eb bd                	jmp    407e24 <DoNumSortIteration+0x304>
  407e67:	48 89 c7             	mov    %rax,%rdi
  407e6a:	eb 8e                	jmp    407dfa <DoNumSortIteration+0x2da>
  407e6c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000407e70 <strsift>:
*/
static void strsift(farulong *optrarray,        /* Offset pointers */
	faruchar *strarray,                     /* String array */
	ulong numstrings,                       /* # of strings */
	ulong i, ulong j)                       /* Offsets */
{
  407e70:	41 57                	push   %r15
  407e72:	41 56                	push   %r14
  407e74:	49 89 cf             	mov    %rcx,%r15
  407e77:	41 55                	push   %r13
  407e79:	41 54                	push   %r12
  407e7b:	55                   	push   %rbp
  407e7c:	53                   	push   %rbx
  407e7d:	48 89 f5             	mov    %rsi,%rbp
  407e80:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  407e87:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  407e8e:	00 00 
  407e90:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
  407e97:	00 
  407e98:	31 c0                	xor    %eax,%eax
  407e9a:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  407e9f:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  407ea4:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  407ea9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
unsigned long k;                /* Temporaries */
unsigned char temp[80];
unsigned char tlen;             /* For string lengths */


while((i+i)<=j)
  407eb0:	4f 8d 24 3f          	lea    (%r15,%r15,1),%r12
  407eb4:	4c 3b 64 24 10       	cmp    0x10(%rsp),%r12
  407eb9:	0f 87 00 01 00 00    	ja     407fbf <strsift+0x14f>
{
	k=i+i;
	if(k<j)
  407ebf:	0f 82 43 01 00 00    	jb     408008 <strsift+0x198>
  407ec5:	4d 89 fd             	mov    %r15,%r13
  407ec8:	49 c1 e5 04          	shl    $0x4,%r13
  407ecc:	4c 03 6c 24 08       	add    0x8(%rsp),%r13
  407ed1:	4c 89 e8             	mov    %r13,%rax
  407ed4:	4c 89 6c 24 18       	mov    %r13,0x18(%rsp)
  407ed9:	49 89 ed             	mov    %rbp,%r13
  407edc:	4c 03 28             	add    (%rax),%r13
  407edf:	41 0f b6 5d 00       	movzbl 0x0(%r13),%ebx
  407ee4:	88 5c 24 26          	mov    %bl,0x26(%rsp)
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  407ee8:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  407eed:	48 89 ef             	mov    %rbp,%rdi
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  407ef0:	4c 89 ee             	mov    %r13,%rsi
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  407ef3:	4e 8d 34 f8          	lea    (%rax,%r15,8),%r14
  407ef7:	49 03 3e             	add    (%r14),%rdi
  407efa:	0f b6 17             	movzbl (%rdi),%edx
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  407efd:	39 da                	cmp    %ebx,%edx
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  407eff:	88 54 24 20          	mov    %dl,0x20(%rsp)
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  407f03:	0f 4f d3             	cmovg  %ebx,%edx
  407f06:	48 63 d2             	movslq %edx,%rdx
  407f09:	e8 52 8f ff ff       	callq  400e60 <strncmp@plt>
		(char *)(strarray+*(optrarray+b)),slen);

if(slen==0)
  407f0e:	85 c0                	test   %eax,%eax
  407f10:	0f 85 da 00 00 00    	jne    407ff0 <strsift+0x180>
{
	/*
	** They match.  Return true if the length of a
	** is greater than the length of b.
	*/
	if(*(strarray+*(optrarray+a)) >
  407f16:	44 0f b6 44 24 20    	movzbl 0x20(%rsp),%r8d
  407f1c:	44 3a 44 24 26       	cmp    0x26(%rsp),%r8b
  407f21:	0f 86 cf 00 00 00    	jbe    407ff6 <strsift+0x186>
			++k;
	if(str_is_less(optrarray,strarray,numstrings,i,k))
	{
		/* temp=string[k] */
		tlen=*(strarray+*(optrarray+k));
		MoveMemory((farvoid *)&temp[0],
  407f27:	8d 53 01             	lea    0x1(%rbx),%edx
  407f2a:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
  407f2f:	4c 89 ee             	mov    %r13,%rsi
  407f32:	48 63 d2             	movslq %edx,%rdx
  407f35:	e8 b6 3f 00 00       	callq  40bef0 <MoveMemory>
			(farvoid *)(strarray+*(optrarray+k)),
			(unsigned long)(tlen+1));

		/* string[k]=string[i] */
		tlen=*(strarray+*(optrarray+i));
  407f3a:	49 8b 06             	mov    (%r14),%rax
		stradjust(optrarray,strarray,numstrings,k,tlen);
  407f3d:	4c 8b 6c 24 08       	mov    0x8(%rsp),%r13
  407f42:	4c 89 e1             	mov    %r12,%rcx
  407f45:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  407f4a:	48 89 ee             	mov    %rbp,%rsi
  407f4d:	0f b6 5c 05 00       	movzbl 0x0(%rbp,%rax,1),%ebx
  407f52:	4c 89 ef             	mov    %r13,%rdi
  407f55:	41 89 d8             	mov    %ebx,%r8d
  407f58:	e8 83 d5 ff ff       	callq  4054e0 <stradjust>
		MoveMemory((farvoid *)(strarray+*(optrarray+k)),
  407f5d:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  407f62:	48 89 e8             	mov    %rbp,%rax
  407f65:	48 89 ee             	mov    %rbp,%rsi
  407f68:	49 03 36             	add    (%r14),%rsi
  407f6b:	8d 53 01             	lea    0x1(%rbx),%edx
  407f6e:	48 03 01             	add    (%rcx),%rax
  407f71:	48 63 d2             	movslq %edx,%rdx
  407f74:	48 89 c7             	mov    %rax,%rdi
  407f77:	e8 74 3f 00 00       	callq  40bef0 <MoveMemory>
			(farvoid *)(strarray+*(optrarray+i)),
			(unsigned long)(tlen+1));

		/* string[i]=temp */
		tlen=temp[0];
		stradjust(optrarray,strarray,numstrings,i,tlen);
  407f7c:	0f b6 5c 24 40       	movzbl 0x40(%rsp),%ebx
  407f81:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
  407f86:	4c 89 f9             	mov    %r15,%rcx
  407f89:	48 89 ee             	mov    %rbp,%rsi
  407f8c:	4c 89 ef             	mov    %r13,%rdi
		MoveMemory((farvoid *)(strarray+*(optrarray+i)),
			(farvoid *)&temp[0],
			(unsigned long)(tlen+1));
		i=k;
  407f8f:	4d 89 e7             	mov    %r12,%r15
unsigned long k;                /* Temporaries */
unsigned char temp[80];
unsigned char tlen;             /* For string lengths */


while((i+i)<=j)
  407f92:	4f 8d 24 3f          	lea    (%r15,%r15,1),%r12
			(farvoid *)(strarray+*(optrarray+i)),
			(unsigned long)(tlen+1));

		/* string[i]=temp */
		tlen=temp[0];
		stradjust(optrarray,strarray,numstrings,i,tlen);
  407f96:	41 89 d8             	mov    %ebx,%r8d
  407f99:	e8 42 d5 ff ff       	callq  4054e0 <stradjust>
		MoveMemory((farvoid *)(strarray+*(optrarray+i)),
  407f9e:	48 89 ef             	mov    %rbp,%rdi
  407fa1:	49 03 3e             	add    (%r14),%rdi
  407fa4:	8d 53 01             	lea    0x1(%rbx),%edx
  407fa7:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
  407fac:	48 63 d2             	movslq %edx,%rdx
  407faf:	e8 3c 3f 00 00       	callq  40bef0 <MoveMemory>
unsigned long k;                /* Temporaries */
unsigned char temp[80];
unsigned char tlen;             /* For string lengths */


while((i+i)<=j)
  407fb4:	4c 3b 64 24 10       	cmp    0x10(%rsp),%r12
  407fb9:	0f 86 00 ff ff ff    	jbe    407ebf <strsift+0x4f>
	}
	else
		i=j+1;
}
return;
}
  407fbf:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
  407fc6:	00 
  407fc7:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  407fce:	00 00 
  407fd0:	0f 85 da 00 00 00    	jne    4080b0 <strsift+0x240>
  407fd6:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  407fdd:	5b                   	pop    %rbx
  407fde:	5d                   	pop    %rbp
  407fdf:	41 5c                	pop    %r12
  407fe1:	41 5d                	pop    %r13
  407fe3:	41 5e                	pop    %r14
  407fe5:	41 5f                	pop    %r15
  407fe7:	c3                   	retq   
  407fe8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  407fef:	00 
		*(strarray+*(optrarray+b)))
		return(TRUE);
	return(FALSE);
}

if(slen<0) return(TRUE);        /* a is strictly less than b */
  407ff0:	0f 88 31 ff ff ff    	js     407f27 <strsift+0xb7>
			(farvoid *)&temp[0],
			(unsigned long)(tlen+1));
		i=k;
	}
	else
		i=j+1;
  407ff6:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  407ffb:	4c 8d 78 01          	lea    0x1(%rax),%r15
  407fff:	e9 ac fe ff ff       	jmpq   407eb0 <strsift+0x40>
  408004:	0f 1f 40 00          	nopl   0x0(%rax)

while((i+i)<=j)
{
	k=i+i;
	if(k<j)
		if(str_is_less(optrarray,strarray,numstrings,k,k+1L))
  408008:	49 8d 44 24 01       	lea    0x1(%r12),%rax
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  40800d:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  408012:	49 89 ed             	mov    %rbp,%r13
if(slen > (int)*(strarray+*(optrarray+b)))
  408015:	49 89 ee             	mov    %rbp,%r14

while((i+i)<=j)
{
	k=i+i;
	if(k<j)
		if(str_is_less(optrarray,strarray,numstrings,k,k+1L))
  408018:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  40801d:	4c 89 f8             	mov    %r15,%rax
  408020:	48 c1 e0 04          	shl    $0x4,%rax
  408024:	48 8d 34 07          	lea    (%rdi,%rax,1),%rsi
if(slen > (int)*(strarray+*(optrarray+b)))
  408028:	4c 8d 5c 07 08       	lea    0x8(%rdi,%rax,1),%r11
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  40802d:	4c 03 2e             	add    (%rsi),%r13
if(slen > (int)*(strarray+*(optrarray+b)))
  408030:	4d 03 33             	add    (%r11),%r14
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  408033:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
if(slen > (int)*(strarray+*(optrarray+b)))
  408038:	4c 89 5c 24 28       	mov    %r11,0x28(%rsp)
  40803d:	45 0f b6 06          	movzbl (%r14),%r8d
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  408041:	41 0f b6 5d 00       	movzbl 0x0(%r13),%ebx
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  408046:	4c 89 f6             	mov    %r14,%rsi
  408049:	4c 89 ef             	mov    %r13,%rdi
  40804c:	44 39 c3             	cmp    %r8d,%ebx
  40804f:	44 89 c2             	mov    %r8d,%edx
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
if(slen > (int)*(strarray+*(optrarray+b)))
  408052:	44 88 44 24 27       	mov    %r8b,0x27(%rsp)
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  408057:	0f 4e d3             	cmovle %ebx,%edx
  40805a:	44 89 44 24 20       	mov    %r8d,0x20(%rsp)
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  40805f:	88 5c 24 26          	mov    %bl,0x26(%rsp)
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  408063:	48 63 d2             	movslq %edx,%rdx
  408066:	e8 f5 8d ff ff       	callq  400e60 <strncmp@plt>
		(char *)(strarray+*(optrarray+b)),slen);

if(slen==0)
  40806b:	85 c0                	test   %eax,%eax
  40806d:	44 8b 44 24 20       	mov    0x20(%rsp),%r8d
  408072:	44 0f b6 54 24 27    	movzbl 0x27(%rsp),%r10d
  408078:	4c 8b 5c 24 28       	mov    0x28(%rsp),%r11
  40807d:	75 29                	jne    4080a8 <strsift+0x238>
{
	/*
	** They match.  Return true if the length of a
	** is greater than the length of b.
	*/
	if(*(strarray+*(optrarray+a)) >
  40807f:	44 38 54 24 26       	cmp    %r10b,0x26(%rsp)
  408084:	0f 86 5e fe ff ff    	jbe    407ee8 <strsift+0x78>
		*(strarray+*(optrarray+b)))
		return(TRUE);
	return(FALSE);
}

if(slen<0) return(TRUE);        /* a is strictly less than b */
  40808a:	44 89 c3             	mov    %r8d,%ebx
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
if(slen > (int)*(strarray+*(optrarray+b)))
  40808d:	44 88 54 24 26       	mov    %r10b,0x26(%rsp)
		*(strarray+*(optrarray+b)))
		return(TRUE);
	return(FALSE);
}

if(slen<0) return(TRUE);        /* a is strictly less than b */
  408092:	4d 89 f5             	mov    %r14,%r13
  408095:	4c 89 5c 24 18       	mov    %r11,0x18(%rsp)
while((i+i)<=j)
{
	k=i+i;
	if(k<j)
		if(str_is_less(optrarray,strarray,numstrings,k,k+1L))
			++k;
  40809a:	4c 8b 64 24 38       	mov    0x38(%rsp),%r12
  40809f:	e9 44 fe ff ff       	jmpq   407ee8 <strsift+0x78>
  4080a4:	0f 1f 40 00          	nopl   0x0(%rax)
		*(strarray+*(optrarray+b)))
		return(TRUE);
	return(FALSE);
}

if(slen<0) return(TRUE);        /* a is strictly less than b */
  4080a8:	0f 89 3a fe ff ff    	jns    407ee8 <strsift+0x78>
  4080ae:	eb da                	jmp    40808a <strsift+0x21a>
	}
	else
		i=j+1;
}
return;
}
  4080b0:	e8 4b 8e ff ff       	callq  400f00 <__stack_chk_fail@plt>
  4080b5:	90                   	nop
  4080b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4080bd:	00 00 00 

00000000004080c0 <DoStringSortIteration>:
** Note that this routine also builds the offset pointer
** array.
*/
static ulong DoStringSortIteration(faruchar *arraybase,
		uint numarrays,ulong arraysize)
{
  4080c0:	41 57                	push   %r15
  4080c2:	41 56                	push   %r14

/*
** Initialize random number generator.
*/
/* randnum(13L); */
randnum((int32)13);
  4080c4:	41 bf 01 00 00 00    	mov    $0x1,%r15d
** Note that this routine also builds the offset pointer
** array.
*/
static ulong DoStringSortIteration(faruchar *arraybase,
		uint numarrays,ulong arraysize)
{
  4080ca:	41 55                	push   %r13
  4080cc:	41 54                	push   %r12
  4080ce:	49 89 d5             	mov    %rdx,%r13
  4080d1:	55                   	push   %rbp
  4080d2:	53                   	push   %rbx
  4080d3:	49 89 fc             	mov    %rdi,%r12
/*
** Start with no strings.  Initialize our current offset pointer
** to 0.
*/
*nstrings=0L;
curroffset=0L;
  4080d6:	31 ed                	xor    %ebp,%ebp
** Note that this routine also builds the offset pointer
** array.
*/
static ulong DoStringSortIteration(faruchar *arraybase,
		uint numarrays,ulong arraysize)
{
  4080d8:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  4080df:	48 89 bc 24 80 00 00 	mov    %rdi,0x80(%rsp)
  4080e6:	00 

/*
** Initialize random number generator.
*/
/* randnum(13L); */
randnum((int32)13);
  4080e7:	bf 0d 00 00 00       	mov    $0xd,%edi
** Note that this routine also builds the offset pointer
** array.
*/
static ulong DoStringSortIteration(faruchar *arraybase,
		uint numarrays,ulong arraysize)
{
  4080ec:	89 74 24 64          	mov    %esi,0x64(%rsp)
  4080f0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4080f7:	00 00 
  4080f9:	48 89 84 24 f8 00 00 	mov    %rax,0xf8(%rsp)
  408100:	00 
  408101:	31 c0                	xor    %eax,%eax

/*
** Initialize random number generator.
*/
/* randnum(13L); */
randnum((int32)13);
  408103:	e8 d8 c6 ff ff       	callq  4047e0 <randnum>
	** there's room in the array.
	*/
        /* stringlength=(unsigned char)((1+abs_randwc(76L)) & 0xFFL);*/
	stringlength=(unsigned char)((1+abs_randwc((int32)76)) & 0xFFL);
	if((unsigned long)stringlength+curroffset+1L>=arraysize)
	{       stringlength=(unsigned char)((arraysize-curroffset-1L) &
  408108:	41 8d 45 ff          	lea    -0x1(%r13),%eax
  40810c:	4c 89 6c 24 08       	mov    %r13,0x8(%rsp)
  408111:	88 44 24 14          	mov    %al,0x14(%rsp)
  408115:	49 8d 47 ff          	lea    -0x1(%r15),%rax
	** shorter than 4 bytes and no longer than
	** 80 bytes.  Note we have to also make sure
	** there's room in the array.
	*/
        /* stringlength=(unsigned char)((1+abs_randwc(76L)) & 0xFFL);*/
	stringlength=(unsigned char)((1+abs_randwc((int32)76)) & 0xFFL);
  408119:	bf 4c 00 00 00       	mov    $0x4c,%edi
  40811e:	4c 8d 75 01          	lea    0x1(%rbp),%r14
  408122:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  408127:	e8 54 c6 ff ff       	callq  404780 <abs_randwc>
  40812c:	8d 58 01             	lea    0x1(%rax),%ebx
	if((unsigned long)stringlength+curroffset+1L>=arraysize)
  40812f:	0f b6 c3             	movzbl %bl,%eax
  408132:	4c 01 f0             	add    %r14,%rax
  408135:	48 39 44 24 08       	cmp    %rax,0x8(%rsp)
  40813a:	0f 87 ca 05 00 00    	ja     40870a <DoStringSortIteration+0x64a>
	{       stringlength=(unsigned char)((arraysize-curroffset-1L) &
  408140:	0f b6 5c 24 14       	movzbl 0x14(%rsp),%ebx
  408145:	29 eb                	sub    %ebp,%ebx
	curroffset++;

	/*
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
  408147:	84 db                	test   %bl,%bl
	}

	/*
	** Store length at curroffset and advance current offset.
	*/
	*(strarray+curroffset)=stringlength;
  408149:	41 88 1c 2c          	mov    %bl,(%r12,%rbp,1)
	curroffset++;

	/*
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
  40814d:	74 34                	je     408183 <DoStringSortIteration+0xc3>
        /* stringlength=(unsigned char)((1+abs_randwc(76L)) & 0xFFL);*/
	stringlength=(unsigned char)((1+abs_randwc((int32)76)) & 0xFFL);
	if((unsigned long)stringlength+curroffset+1L>=arraysize)
	{       stringlength=(unsigned char)((arraysize-curroffset-1L) &
				0xFF);
		fullflag=1;     /* Indicates a full */
  40814f:	bd 01 00 00 00       	mov    $0x1,%ebp
  408154:	45 31 ed             	xor    %r13d,%r13d
  408157:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40815e:	00 00 
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
	{       *(strarray+curroffset)=
		        /* (unsigned char)(abs_randwc((long)0xFE)); */
			(unsigned char)(abs_randwc((int32)0xFE));
  408160:	bf fe 00 00 00       	mov    $0xfe,%edi
	curroffset++;

	/*
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
  408165:	41 83 c5 01          	add    $0x1,%r13d
	{       *(strarray+curroffset)=
		        /* (unsigned char)(abs_randwc((long)0xFE)); */
			(unsigned char)(abs_randwc((int32)0xFE));
  408169:	e8 12 c6 ff ff       	callq  404780 <abs_randwc>

	/*
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
	{       *(strarray+curroffset)=
  40816e:	43 88 04 34          	mov    %al,(%r12,%r14,1)
		        /* (unsigned char)(abs_randwc((long)0xFE)); */
			(unsigned char)(abs_randwc((int32)0xFE));
		curroffset++;
  408172:	49 83 c6 01          	add    $0x1,%r14
	curroffset++;

	/*
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
  408176:	41 38 dd             	cmp    %bl,%r13b
  408179:	72 e5                	jb     408160 <DoStringSortIteration+0xa0>
	/*
	** Increment the # of strings counter.
	*/
	*nstrings+=1L;

} while(fullflag==0);
  40817b:	85 ed                	test   %ebp,%ebp
  40817d:	0f 84 95 05 00 00    	je     408718 <DoStringSortIteration+0x658>
** is more than one array, copy the original into the
** others.
*/
k=1;
tempsbase=strarray;
while(k<numarrays)
  408183:	83 7c 24 64 01       	cmpl   $0x1,0x64(%rsp)
  408188:	4c 8b 6c 24 08       	mov    0x8(%rsp),%r13
  40818d:	bf 01 00 00 00       	mov    $0x1,%edi
  408192:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
  408199:	00 
  40819a:	44 8b 54 24 64       	mov    0x64(%rsp),%r10d
  40819f:	4d 8d 45 64          	lea    0x64(%r13),%r8
  4081a3:	49 89 f1             	mov    %rsi,%r9
  4081a6:	76 33                	jbe    4081db <DoStringSortIteration+0x11b>
  4081a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4081af:	00 
{       tempsbase+=arraysize+100;         /* Set base */
  4081b0:	4c 01 c6             	add    %r8,%rsi
	for(l=0;l<arraysize;l++)
  4081b3:	31 d2                	xor    %edx,%edx
  4081b5:	31 c0                	xor    %eax,%eax
  4081b7:	4d 85 ed             	test   %r13,%r13
  4081ba:	74 17                	je     4081d3 <DoStringSortIteration+0x113>
  4081bc:	0f 1f 40 00          	nopl   0x0(%rax)
		tempsbase[l]=strarray[l];
  4081c0:	41 0f b6 0c 01       	movzbl (%r9,%rax,1),%ecx
  4081c5:	88 0c 06             	mov    %cl,(%rsi,%rax,1)
*/
k=1;
tempsbase=strarray;
while(k<numarrays)
{       tempsbase+=arraysize+100;         /* Set base */
	for(l=0;l<arraysize;l++)
  4081c8:	8d 42 01             	lea    0x1(%rdx),%eax
  4081cb:	49 39 c5             	cmp    %rax,%r13
  4081ce:	48 89 c2             	mov    %rax,%rdx
  4081d1:	77 ed                	ja     4081c0 <DoStringSortIteration+0x100>
		tempsbase[l]=strarray[l];
	k++;
  4081d3:	83 c7 01             	add    $0x1,%edi
** is more than one array, copy the original into the
** others.
*/
k=1;
tempsbase=strarray;
while(k<numarrays)
  4081d6:	41 39 fa             	cmp    %edi,%r10d
  4081d9:	75 d5                	jne    4081b0 <DoStringSortIteration+0xf0>

/*
** Now the array is full, allocate enough space for an
** offset pointer array.
*/
optrarray=(farulong *)AllocateMemory(*nstrings * sizeof(unsigned long) *
  4081db:	8b 7c 24 64          	mov    0x64(%rsp),%edi
  4081df:	48 8d b4 24 9c 00 00 	lea    0x9c(%rsp),%rsi
  4081e6:	00 
  4081e7:	48 c1 e7 03          	shl    $0x3,%rdi
  4081eb:	49 0f af ff          	imul   %r15,%rdi
  4081ef:	e8 3c 3b 00 00       	callq  40bd30 <AllocateMemory>
		numarrays,
		&systemerror);
if(systemerror)
  4081f4:	8b b4 24 9c 00 00 00 	mov    0x9c(%rsp),%esi

/*
** Now the array is full, allocate enough space for an
** offset pointer array.
*/
optrarray=(farulong *)AllocateMemory(*nstrings * sizeof(unsigned long) *
  4081fb:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
		numarrays,
		&systemerror);
if(systemerror)
  408200:	85 f6                	test   %esi,%esi
  408202:	0f 85 30 05 00 00    	jne    408738 <DoStringSortIteration+0x678>
** Go through the newly-built string array, building
** offsets and putting them into the offset pointer
** array.
*/
curroffset=0;
for(j=0;j<*nstrings;j++)
  408208:	4d 85 ff             	test   %r15,%r15
  40820b:	74 30                	je     40823d <DoStringSortIteration+0x17d>
  40820d:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
  408212:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
  408219:	00 
  40821a:	48 89 c2             	mov    %rax,%rdx
  40821d:	4a 8d 34 f8          	lea    (%rax,%r15,8),%rsi
  408221:	31 c0                	xor    %eax,%eax
  408223:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{       *(optrarray+j)=curroffset;
  408228:	48 89 02             	mov    %rax,(%rdx)
  40822b:	0f b6 0c 07          	movzbl (%rdi,%rax,1),%ecx
  40822f:	48 83 c2 08          	add    $0x8,%rdx
** Go through the newly-built string array, building
** offsets and putting them into the offset pointer
** array.
*/
curroffset=0;
for(j=0;j<*nstrings;j++)
  408233:	48 39 d6             	cmp    %rdx,%rsi
{       *(optrarray+j)=curroffset;
	curroffset+=(unsigned long)(*(strarray+curroffset))+1L;
  408236:	48 8d 44 08 01       	lea    0x1(%rax,%rcx,1),%rax
** Go through the newly-built string array, building
** offsets and putting them into the offset pointer
** array.
*/
curroffset=0;
for(j=0;j<*nstrings;j++)
  40823b:	75 eb                	jne    408228 <DoStringSortIteration+0x168>
** As above, we've made one copy of the offset pointers,
** so duplicate this array in the remaining ones.
*/
k=1;
tempobase=optrarray;
while(k<numarrays)
  40823d:	83 7c 24 64 01       	cmpl   $0x1,0x64(%rsp)

/*
** Now the array is full, allocate enough space for an
** offset pointer array.
*/
optrarray=(farulong *)AllocateMemory(*nstrings * sizeof(unsigned long) *
  408242:	48 8b 54 24 78       	mov    0x78(%rsp),%rdx
  408247:	4e 8d 04 fd 00 00 00 	lea    0x0(,%r15,8),%r8
  40824e:	00 
** As above, we've made one copy of the offset pointers,
** so duplicate this array in the remaining ones.
*/
k=1;
tempobase=optrarray;
while(k<numarrays)
  40824f:	bf 01 00 00 00       	mov    $0x1,%edi
  408254:	44 8b 54 24 64       	mov    0x64(%rsp),%r10d
  408259:	49 89 d1             	mov    %rdx,%r9
  40825c:	0f 86 01 05 00 00    	jbe    408763 <DoStringSortIteration+0x6a3>
  408262:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{       tempobase+=*nstrings;
  408268:	4c 01 c2             	add    %r8,%rdx
	for(l=0;l<*nstrings;l++)
  40826b:	31 c9                	xor    %ecx,%ecx
  40826d:	31 c0                	xor    %eax,%eax
  40826f:	4d 85 ff             	test   %r15,%r15
  408272:	74 17                	je     40828b <DoStringSortIteration+0x1cb>
  408274:	0f 1f 40 00          	nopl   0x0(%rax)
		tempobase[l]=optrarray[l];
  408278:	49 8b 34 c1          	mov    (%r9,%rax,8),%rsi
  40827c:	48 89 34 c2          	mov    %rsi,(%rdx,%rax,8)
*/
k=1;
tempobase=optrarray;
while(k<numarrays)
{       tempobase+=*nstrings;
	for(l=0;l<*nstrings;l++)
  408280:	8d 41 01             	lea    0x1(%rcx),%eax
  408283:	49 39 c7             	cmp    %rax,%r15
  408286:	48 89 c1             	mov    %rax,%rcx
  408289:	77 ed                	ja     408278 <DoStringSortIteration+0x1b8>
		tempobase[l]=optrarray[l];
	k++;
  40828b:	83 c7 01             	add    $0x1,%edi
** As above, we've made one copy of the offset pointers,
** so duplicate this array in the remaining ones.
*/
k=1;
tempobase=optrarray;
while(k<numarrays)
  40828e:	41 39 fa             	cmp    %edi,%r10d
  408291:	75 d5                	jne    408268 <DoStringSortIteration+0x1a8>
tempsbase=arraybase;

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  408293:	31 c0                	xor    %eax,%eax
  408295:	e8 16 3f 00 00       	callq  40c1b0 <StartStopwatch>
  40829a:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
  4082a1:	00 
  4082a2:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
*/
k=1;
tempobase=optrarray;
while(k<numarrays)
{       tempobase+=*nstrings;
	for(l=0;l<*nstrings;l++)
  4082a7:	4c 8b b4 24 80 00 00 	mov    0x80(%rsp),%r14
  4082ae:	00 
  4082af:	c7 44 24 60 00 00 00 	movl   $0x0,0x60(%rsp)
  4082b6:	00 
  4082b7:	48 d1 e8             	shr    %rax
  4082ba:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  4082bf:	49 8d 45 64          	lea    0x64(%r13),%rax
  4082c3:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  4082c8:	4a 8d 04 fd 00 00 00 	lea    0x0(,%r15,8),%rax
  4082cf:	00 
  4082d0:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  4082d5:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
  4082da:	4c 8d 68 08          	lea    0x8(%rax),%r13
  4082de:	66 90                	xchg   %ax,%ax


/*
** Build a heap in the array
*/
for(i=(top/2L); i>0; --i)
  4082e0:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
  4082e5:	49 8d 5d f8          	lea    -0x8(%r13),%rbx
  4082e9:	4c 8b 64 24 30       	mov    0x30(%rsp),%r12
  4082ee:	48 85 c0             	test   %rax,%rax
  4082f1:	48 89 c5             	mov    %rax,%rbp
  4082f4:	0f 84 2a 04 00 00    	je     408724 <DoStringSortIteration+0x664>
  4082fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	strsift(optrarray,strarray,numstrings,i,top);
  408300:	48 89 e9             	mov    %rbp,%rcx
  408303:	4d 89 e0             	mov    %r12,%r8
  408306:	4c 89 fa             	mov    %r15,%rdx
  408309:	4c 89 f6             	mov    %r14,%rsi
  40830c:	48 89 df             	mov    %rbx,%rdi
  40830f:	e8 5c fb ff ff       	callq  407e70 <strsift>


/*
** Build a heap in the array
*/
for(i=(top/2L); i>0; --i)
  408314:	48 83 ed 01          	sub    $0x1,%rbp
  408318:	75 e6                	jne    408300 <DoStringSortIteration+0x240>
  40831a:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  40831f:	4c 89 e8             	mov    %r13,%rax
  408322:	48 c1 e0 3c          	shl    $0x3c,%rax
  408326:	48 c1 e8 3f          	shr    $0x3f,%rax
  40832a:	4c 39 c8             	cmp    %r9,%rax
  40832d:	4c 89 ce             	mov    %r9,%rsi
  408330:	4c 89 cf             	mov    %r9,%rdi
  408333:	49 0f 47 c1          	cmova  %r9,%rax
  408337:	49 83 f9 03          	cmp    $0x3,%r9
  40833b:	4c 89 cd             	mov    %r9,%rbp
  40833e:	48 0f 47 f0          	cmova  %rax,%rsi
  408342:	48 29 f7             	sub    %rsi,%rdi
  408345:	48 89 f1             	mov    %rsi,%rcx
  408348:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
  40834d:	48 89 fa             	mov    %rdi,%rdx
  408350:	4c 8d 64 cb 08       	lea    0x8(%rbx,%rcx,8),%r12
  408355:	48 89 7c 24 50       	mov    %rdi,0x50(%rsp)
  40835a:	48 83 ea 02          	sub    $0x2,%rdx
  40835e:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  408363:	48 d1 ea             	shr    %rdx
  408366:	48 8d 72 01          	lea    0x1(%rdx),%rsi
  40836a:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  40836f:	48 01 f6             	add    %rsi,%rsi
  408372:	48 89 74 24 58       	mov    %rsi,0x58(%rsp)
  408377:	4c 89 fe             	mov    %r15,%rsi
  40837a:	48 29 ce             	sub    %rcx,%rsi
  40837d:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  408382:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
** end of the array.  When we get done, we'll have a sorted
** array.
*/
for(i=top; i>0; --i)
{
	strsift(optrarray,strarray,numstrings,0,i);
  408388:	49 89 e8             	mov    %rbp,%r8
  40838b:	31 c9                	xor    %ecx,%ecx
  40838d:	4c 89 fa             	mov    %r15,%rdx
  408390:	4c 89 f6             	mov    %r14,%rsi
  408393:	48 89 df             	mov    %rbx,%rdi
  408396:	e8 d5 fa ff ff       	callq  407e70 <strsift>

	/* temp = string[0] */
	tlen=*strarray;
	MoveMemory((farvoid *)&temp[0], /* Perform exchange */
  40839b:	41 0f b6 06          	movzbl (%r14),%eax
  40839f:	48 8d bc 24 a0 00 00 	lea    0xa0(%rsp),%rdi
  4083a6:	00 
  4083a7:	4c 89 f6             	mov    %r14,%rsi
  4083aa:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4083ae:	e8 3d 3b 00 00       	callq  40bef0 <MoveMemory>
		(farvoid *)strarray,
		(unsigned long)(tlen+1));


	/* string[0]=string[i] */
	tlen=*(strarray+*(optrarray+i));
  4083b3:	48 8b 04 eb          	mov    (%rbx,%rbp,8),%rax
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  4083b7:	49 8b 7d f8          	mov    -0x8(%r13),%rdi
** location i+1 to end of array.  Whether we're moving "up" or
** down, this is how many bytes we'll have to move.
*/
nbytes=*(optrarray+nstrings-1L) +
	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
	*(optrarray+i+1L);
  4083bb:	49 8b 75 00          	mov    0x0(%r13),%rsi
		(farvoid *)strarray,
		(unsigned long)(tlen+1));


	/* string[0]=string[i] */
	tlen=*(strarray+*(optrarray+i));
  4083bf:	41 0f b6 0c 06       	movzbl (%r14,%rax,1),%ecx
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  4083c4:	41 0f b6 04 3e       	movzbl (%r14,%rdi,1),%eax
  4083c9:	41 89 ca             	mov    %ecx,%r10d
  4083cc:	89 4c 24 1c          	mov    %ecx,0x1c(%rsp)
** string position i+1.  Destination is string position i+l
** (i+"ell"...don't confuse 1 and l).
** Hand this straight to memmove and let it handle the
** "overlap" problem.
*/
MoveMemory((farvoid *)(strarray+*(optrarray+i)+l+1),
  4083d0:	88 4c 24 08          	mov    %cl,0x8(%rsp)
/*
** If new length is less than old length, the direction is
** down.  If new length is greater than old length, the
** direction is up.
*/
direction=(int)l - (int)*(strarray+*(optrarray+i));
  4083d4:	41 29 c2             	sub    %eax,%r10d
adjamount=(unsigned char)abs(direction);
  4083d7:	44 89 d2             	mov    %r10d,%edx
  4083da:	44 89 54 24 18       	mov    %r10d,0x18(%rsp)
  4083df:	c1 fa 1f             	sar    $0x1f,%edx
  4083e2:	89 d0                	mov    %edx,%eax
  4083e4:	44 31 d0             	xor    %r10d,%eax
  4083e7:	29 d0                	sub    %edx,%eax
  4083e9:	89 44 24 14          	mov    %eax,0x14(%rsp)
** Calculate the total # of bytes in string array from
** location i+1 to end of array.  Whether we're moving "up" or
** down, this is how many bytes we'll have to move.
*/
nbytes=*(optrarray+nstrings-1L) +
	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
  4083ed:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  4083f2:	49 8b 54 05 f0       	mov    -0x10(%r13,%rax,1),%rdx
** string position i+1.  Destination is string position i+l
** (i+"ell"...don't confuse 1 and l).
** Hand this straight to memmove and let it handle the
** "overlap" problem.
*/
MoveMemory((farvoid *)(strarray+*(optrarray+i)+l+1),
  4083f7:	45 0f b6 1c 16       	movzbl (%r14,%rdx,1),%r11d
  4083fc:	48 29 f2             	sub    %rsi,%rdx
  4083ff:	4c 01 f6             	add    %r14,%rsi
  408402:	4a 8d 54 1a 01       	lea    0x1(%rdx,%r11,1),%rdx
  408407:	44 0f b6 d9          	movzbl %cl,%r11d
  40840b:	4a 8d 7c 1f 01       	lea    0x1(%rdi,%r11,1),%rdi
  408410:	4c 01 f7             	add    %r14,%rdi
  408413:	e8 d8 3a 00 00       	callq  40bef0 <MoveMemory>

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408418:	49 83 ff 01          	cmp    $0x1,%r15
  40841c:	44 0f b6 44 24 08    	movzbl 0x8(%rsp),%r8d
  408422:	48 63 44 24 14       	movslq 0x14(%rsp),%rax
  408427:	44 8b 54 24 18       	mov    0x18(%rsp),%r10d
  40842c:	8b 4c 24 1c          	mov    0x1c(%rsp),%ecx
  408430:	0f 86 99 00 00 00    	jbe    4084cf <DoStringSortIteration+0x40f>
  408436:	45 85 d2             	test   %r10d,%r10d
  408439:	0f 88 f1 01 00 00    	js     408630 <DoStringSortIteration+0x570>
  40843f:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  408444:	48 85 ff             	test   %rdi,%rdi
  408447:	0f 84 83 02 00 00    	je     4086d0 <DoStringSortIteration+0x610>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  40844d:	49 01 45 00          	add    %rax,0x0(%r13)
  408451:	48 83 ff 01          	cmp    $0x1,%rdi

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408455:	be 02 00 00 00       	mov    $0x2,%esi
  40845a:	74 18                	je     408474 <DoStringSortIteration+0x3b4>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  40845c:	49 01 45 08          	add    %rax,0x8(%r13)
  408460:	48 83 ff 02          	cmp    $0x2,%rdi

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408464:	be 03 00 00 00       	mov    $0x3,%esi
  408469:	74 09                	je     408474 <DoStringSortIteration+0x3b4>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  40846b:	49 01 45 10          	add    %rax,0x10(%r13)

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  40846f:	be 04 00 00 00       	mov    $0x4,%esi
  408474:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  408479:	48 39 54 24 30       	cmp    %rdx,0x30(%rsp)
  40847e:	74 4f                	je     4084cf <DoStringSortIteration+0x40f>
  408480:	48 83 7c 24 38 02    	cmpq   $0x2,0x38(%rsp)
  408486:	74 43                	je     4084cb <DoStringSortIteration+0x40b>
  408488:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40848d:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  408492:	31 d2                	xor    %edx,%edx
  408494:	f3 0f 7e 4c 24 08    	movq   0x8(%rsp),%xmm1
  40849a:	31 ff                	xor    %edi,%edi
  40849c:	66 0f 6c c9          	punpcklqdq %xmm1,%xmm1
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
	else
		*(optrarray+j)=*(optrarray+j)+adjamount;
  4084a0:	66 41 0f 6f 04 14    	movdqa (%r12,%rdx,1),%xmm0
  4084a6:	48 83 c7 01          	add    $0x1,%rdi
  4084aa:	66 0f d4 c1          	paddq  %xmm1,%xmm0
  4084ae:	41 0f 29 04 14       	movaps %xmm0,(%r12,%rdx,1)
  4084b3:	48 83 c2 10          	add    $0x10,%rdx
  4084b7:	49 39 f9             	cmp    %rdi,%r9
  4084ba:	77 e4                	ja     4084a0 <DoStringSortIteration+0x3e0>
  4084bc:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  4084c1:	48 01 fe             	add    %rdi,%rsi
  4084c4:	48 3b 7c 24 50       	cmp    0x50(%rsp),%rdi
  4084c9:	74 04                	je     4084cf <DoStringSortIteration+0x40f>
  4084cb:	48 01 04 f3          	add    %rax,(%rbx,%rsi,8)

/*
** Store the new length and go home.
*/
*(strarray+*(optrarray+i))=l;
  4084cf:	49 8b 45 f8          	mov    -0x8(%r13),%rax


	/* string[0]=string[i] */
	tlen=*(strarray+*(optrarray+i));
	stradjust(optrarray,strarray,numstrings,0,tlen);
	MoveMemory((farvoid *)strarray,
  4084d3:	4c 89 f6             	mov    %r14,%rsi
  4084d6:	8d 51 01             	lea    0x1(%rcx),%edx
  4084d9:	4c 89 f7             	mov    %r14,%rdi
  4084dc:	48 63 d2             	movslq %edx,%rdx
		*(optrarray+j)=*(optrarray+j)+adjamount;

/*
** Store the new length and go home.
*/
*(strarray+*(optrarray+i))=l;
  4084df:	45 88 04 06          	mov    %r8b,(%r14,%rax,1)


	/* string[0]=string[i] */
	tlen=*(strarray+*(optrarray+i));
	stradjust(optrarray,strarray,numstrings,0,tlen);
	MoveMemory((farvoid *)strarray,
  4084e3:	48 03 34 eb          	add    (%rbx,%rbp,8),%rsi
  4084e7:	e8 04 3a 00 00       	callq  40bef0 <MoveMemory>
		(farvoid *)(strarray+*(optrarray+i)),
		(unsigned long)(tlen+1));

	/* string[i]=temp */
	tlen=temp[0];
	stradjust(optrarray,strarray,numstrings,i,tlen);
  4084ec:	0f b6 84 24 a0 00 00 	movzbl 0xa0(%rsp),%eax
  4084f3:	00 
  4084f4:	48 89 e9             	mov    %rbp,%rcx
  4084f7:	4c 89 fa             	mov    %r15,%rdx
  4084fa:	4c 89 f6             	mov    %r14,%rsi
  4084fd:	48 89 df             	mov    %rbx,%rdi
  408500:	41 89 c0             	mov    %eax,%r8d
  408503:	89 44 24 08          	mov    %eax,0x8(%rsp)
  408507:	e8 d4 cf ff ff       	callq  4054e0 <stradjust>
	MoveMemory((farvoid *)(strarray+*(optrarray+i)),
  40850c:	8b 44 24 08          	mov    0x8(%rsp),%eax
  408510:	4c 89 f7             	mov    %r14,%rdi
  408513:	48 03 3c eb          	add    (%rbx,%rbp,8),%rdi
  408517:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40851e:	00 
  40851f:	8d 50 01             	lea    0x1(%rax),%edx
  408522:	48 63 d2             	movslq %edx,%rdx
  408525:	e8 c6 39 00 00       	callq  40bef0 <MoveMemory>
/*
** Repeatedly extract maximum from heap and place it at the
** end of the array.  When we get done, we'll have a sorted
** array.
*/
for(i=top; i>0; --i)
  40852a:	48 83 ed 01          	sub    $0x1,%rbp
  40852e:	0f 85 54 fe ff ff    	jne    408388 <DoStringSortIteration+0x2c8>
elapsed=StartStopwatch();

/*
** Execute heapsorts
*/
for(i=0;i<numarrays;i++)
  408534:	83 44 24 60 01       	addl   $0x1,0x60(%rsp)
{       StrHeapSort(tempobase,tempsbase,nstrings,0L,nstrings-1);
	tempobase+=nstrings;    /* Advance base pointers */
	tempsbase+=arraysize+100;
  408539:	4c 03 74 24 70       	add    0x70(%rsp),%r14
elapsed=StartStopwatch();

/*
** Execute heapsorts
*/
for(i=0;i<numarrays;i++)
  40853e:	8b 44 24 60          	mov    0x60(%rsp),%eax
  408542:	4c 03 6c 24 28       	add    0x28(%rsp),%r13
  408547:	39 44 24 64          	cmp    %eax,0x64(%rsp)
  40854b:	0f 85 8f fd ff ff    	jne    4082e0 <DoStringSortIteration+0x220>
}

/*
** Record elapsed time
*/
elapsed=StopStopwatch(elapsed);
  408551:	48 8b bc 24 88 00 00 	mov    0x88(%rsp),%rdi
  408558:	00 
  408559:	e8 62 3c 00 00       	callq  40c1c0 <StopStopwatch>

#ifdef DEBUG
{
	unsigned long i;
	for(i=0;i<nstrings-1;i++)
  40855e:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
}

/*
** Record elapsed time
*/
elapsed=StopStopwatch(elapsed);
  408564:	48 89 c3             	mov    %rax,%rbx

#ifdef DEBUG
{
	unsigned long i;
	for(i=0;i<nstrings-1;i++)
  408567:	0f 84 7e 00 00 00    	je     4085eb <DoStringSortIteration+0x52b>
  40856d:	4c 8b 64 24 78       	mov    0x78(%rsp),%r12
  408572:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
  408579:	00 
  40857a:	31 ed                	xor    %ebp,%ebp
  40857c:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15
  408581:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
  408586:	49 8b 04 24          	mov    (%r12),%rax
  40858a:	49 89 ce             	mov    %rcx,%r14
  40858d:	44 0f b6 2c 01       	movzbl (%rcx,%rax,1),%r13d
  408592:	44 89 eb             	mov    %r13d,%ebx
  408595:	0f 1f 00             	nopl   (%rax)
	{       /*
		** Compare strings to check for proper
		** sort.
		*/
		if(str_is_less(optrarray,arraybase,nstrings,i+1,i))
  408598:	48 83 c5 01          	add    $0x1,%rbp
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  40859c:	4c 89 f7             	mov    %r14,%rdi
if(slen > (int)*(strarray+*(optrarray+b)))
  40859f:	0f b6 d3             	movzbl %bl,%edx
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  4085a2:	49 03 3c ec          	add    (%r12,%rbp,8),%rdi
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  4085a6:	4c 89 f6             	mov    %r14,%rsi
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  4085a9:	0f b6 07             	movzbl (%rdi),%eax
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  4085ac:	39 d0                	cmp    %edx,%eax
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  4085ae:	41 89 c5             	mov    %eax,%r13d
if(slen > (int)*(strarray+*(optrarray+b)))
	slen=(int)*(strarray+*(optrarray+b));

slen=strncmp((char *)(strarray+*(optrarray+a)),
  4085b1:	0f 4f c2             	cmovg  %edx,%eax
  4085b4:	49 03 74 ec f8       	add    -0x8(%r12,%rbp,8),%rsi
  4085b9:	48 63 d0             	movslq %eax,%rdx
  4085bc:	e8 9f 88 ff ff       	callq  400e60 <strncmp@plt>
		(char *)(strarray+*(optrarray+b)),slen);

if(slen==0)
  4085c1:	85 c0                	test   %eax,%eax
  4085c3:	0f 85 17 01 00 00    	jne    4086e0 <DoStringSortIteration+0x620>
{
	/*
	** They match.  Return true if the length of a
	** is greater than the length of b.
	*/
	if(*(strarray+*(optrarray+a)) >
  4085c9:	41 38 dd             	cmp    %bl,%r13b
  4085cc:	0f 86 14 01 00 00    	jbe    4086e6 <DoStringSortIteration+0x626>
  4085d2:	bf 48 de 40 00       	mov    $0x40de48,%edi
  4085d7:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  4085dc:	e8 af 88 ff ff       	callq  400e90 <puts@plt>
		** Compare strings to check for proper
		** sort.
		*/
		if(str_is_less(optrarray,arraybase,nstrings,i+1,i))
		{       printf("Sort Error\n");
			stringsort_status=1;
  4085e1:	c7 05 bd 80 20 00 01 	movl   $0x1,0x2080bd(%rip)        # 6106a8 <stringsort_status>
  4085e8:	00 00 00 

/*
** Release the offset pointer array built by
** LoadStringArray()
*/
FreeMemory((farvoid *)optrarray,&syserror);
  4085eb:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
  4085f0:	48 8d b4 24 9c 00 00 	lea    0x9c(%rsp),%rsi
  4085f7:	00 
  4085f8:	e8 33 38 00 00       	callq  40be30 <FreeMemory>

/*
** Return elapsed ticks.
*/
return(elapsed);
}
  4085fd:	48 89 d8             	mov    %rbx,%rax
  408600:	48 8b 9c 24 f8 00 00 	mov    0xf8(%rsp),%rbx
  408607:	00 
  408608:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  40860f:	00 00 
  408611:	0f 85 6c 01 00 00    	jne    408783 <DoStringSortIteration+0x6c3>
  408617:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  40861e:	5b                   	pop    %rbx
  40861f:	5d                   	pop    %rbp
  408620:	41 5c                	pop    %r12
  408622:	41 5d                	pop    %r13
  408624:	41 5e                	pop    %r14
  408626:	41 5f                	pop    %r15
  408628:	c3                   	retq   
  408629:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  408630:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  408635:	48 85 ff             	test   %rdi,%rdi
  408638:	0f 84 c2 00 00 00    	je     408700 <DoStringSortIteration+0x640>
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  40863e:	49 29 45 00          	sub    %rax,0x0(%r13)
  408642:	48 83 ff 01          	cmp    $0x1,%rdi

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408646:	be 02 00 00 00       	mov    $0x2,%esi
  40864b:	74 18                	je     408665 <DoStringSortIteration+0x5a5>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  40864d:	49 29 45 08          	sub    %rax,0x8(%r13)
  408651:	48 83 ff 02          	cmp    $0x2,%rdi

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408655:	be 03 00 00 00       	mov    $0x3,%esi
  40865a:	74 09                	je     408665 <DoStringSortIteration+0x5a5>
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  40865c:	49 29 45 10          	sub    %rax,0x10(%r13)

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408660:	be 04 00 00 00       	mov    $0x4,%esi
  408665:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
  40866a:	48 39 54 24 30       	cmp    %rdx,0x30(%rsp)
  40866f:	0f 84 5a fe ff ff    	je     4084cf <DoStringSortIteration+0x40f>
  408675:	48 83 7c 24 38 02    	cmpq   $0x2,0x38(%rsp)
  40867b:	74 47                	je     4086c4 <DoStringSortIteration+0x604>
  40867d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  408682:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
  408687:	31 d2                	xor    %edx,%edx
  408689:	f3 0f 7e 4c 24 08    	movq   0x8(%rsp),%xmm1
  40868f:	31 ff                	xor    %edi,%edi
  408691:	66 0f 6c c9          	punpcklqdq %xmm1,%xmm1
	if(direction<0)
		*(optrarray+j)=*(optrarray+j)-adjamount;
  408695:	66 41 0f 6f 04 14    	movdqa (%r12,%rdx,1),%xmm0
  40869b:	48 83 c7 01          	add    $0x1,%rdi
  40869f:	66 0f fb c1          	psubq  %xmm1,%xmm0
  4086a3:	41 0f 29 04 14       	movaps %xmm0,(%r12,%rdx,1)
  4086a8:	48 83 c2 10          	add    $0x10,%rdx
  4086ac:	4c 39 cf             	cmp    %r9,%rdi
  4086af:	72 e4                	jb     408695 <DoStringSortIteration+0x5d5>
  4086b1:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  4086b6:	48 01 fe             	add    %rdi,%rsi
  4086b9:	48 39 7c 24 50       	cmp    %rdi,0x50(%rsp)
  4086be:	0f 84 0b fe ff ff    	je     4084cf <DoStringSortIteration+0x40f>
  4086c4:	48 29 04 f3          	sub    %rax,(%rbx,%rsi,8)
  4086c8:	e9 02 fe ff ff       	jmpq   4084cf <DoStringSortIteration+0x40f>
  4086cd:	0f 1f 00             	nopl   (%rax)

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  4086d0:	be 01 00 00 00       	mov    $0x1,%esi
  4086d5:	e9 a6 fd ff ff       	jmpq   408480 <DoStringSortIteration+0x3c0>
  4086da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		*(strarray+*(optrarray+b)))
		return(TRUE);
	return(FALSE);
}

if(slen<0) return(TRUE);        /* a is strictly less than b */
  4086e0:	0f 88 ec fe ff ff    	js     4085d2 <DoStringSortIteration+0x512>
elapsed=StopStopwatch(elapsed);

#ifdef DEBUG
{
	unsigned long i;
	for(i=0;i<nstrings-1;i++)
  4086e6:	4c 39 fd             	cmp    %r15,%rbp
/*
** Determine which string has the minimum length.  Use that
** to call strncmp().  If they match up to that point, the
** string with the longer length wins.
*/
slen=(int)*(strarray+*(optrarray+a));
  4086e9:	44 89 eb             	mov    %r13d,%ebx
elapsed=StopStopwatch(elapsed);

#ifdef DEBUG
{
	unsigned long i;
	for(i=0;i<nstrings-1;i++)
  4086ec:	0f 85 a6 fe ff ff    	jne    408598 <DoStringSortIteration+0x4d8>
  4086f2:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  4086f7:	e9 ef fe ff ff       	jmpq   4085eb <DoStringSortIteration+0x52b>
  4086fc:	0f 1f 40 00          	nopl   0x0(%rax)

/*
** We have to adjust the offset pointer array.
** This covers string i+1 to numstrings-1.
*/
for(j=i+1;j<nstrings;j++)
  408700:	be 01 00 00 00       	mov    $0x1,%esi
  408705:	e9 6b ff ff ff       	jmpq   408675 <DoStringSortIteration+0x5b5>
	}

	/*
	** Store length at curroffset and advance current offset.
	*/
	*(strarray+curroffset)=stringlength;
  40870a:	41 88 1c 2c          	mov    %bl,(%r12,%rbp,1)
	curroffset++;

	/*
	** Fill up the rest of the string with random bytes.
	*/
	for(i=0;i<stringlength;i++)
  40870e:	31 ed                	xor    %ebp,%ebp
  408710:	84 db                	test   %bl,%bl
  408712:	0f 85 3c fa ff ff    	jne    408154 <DoStringSortIteration+0x94>
  408718:	49 83 c7 01          	add    $0x1,%r15
** Note that this routine also builds the offset pointer
** array.
*/
static ulong DoStringSortIteration(faruchar *arraybase,
		uint numarrays,ulong arraysize)
{
  40871c:	4c 89 f5             	mov    %r14,%rbp
  40871f:	e9 f1 f9 ff ff       	jmpq   408115 <DoStringSortIteration+0x55>
/*
** Repeatedly extract maximum from heap and place it at the
** end of the array.  When we get done, we'll have a sorted
** array.
*/
for(i=top; i>0; --i)
  408724:	48 83 7c 24 30 00    	cmpq   $0x0,0x30(%rsp)
  40872a:	0f 84 04 fe ff ff    	je     408534 <DoStringSortIteration+0x474>
  408730:	e9 e5 fb ff ff       	jmpq   40831a <DoStringSortIteration+0x25a>
  408735:	0f 1f 00             	nopl   (%rax)
*/
optrarray=(farulong *)AllocateMemory(*nstrings * sizeof(unsigned long) *
		numarrays,
		&systemerror);
if(systemerror)
{       ReportError("CPU:Stringsort",systemerror);
  408738:	bf 53 de 40 00       	mov    $0x40de53,%edi
  40873d:	e8 2e 3a 00 00       	callq  40c170 <ReportError>
	FreeMemory((void *)strarray,&systemerror);
  408742:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
  408749:	00 
  40874a:	48 8d b4 24 9c 00 00 	lea    0x9c(%rsp),%rsi
  408751:	00 
  408752:	e8 d9 36 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  408757:	31 c0                	xor    %eax,%eax
  408759:	e8 42 3a 00 00       	callq  40c1a0 <ErrorExit>
  40875e:	e9 a5 fa ff ff       	jmpq   408208 <DoStringSortIteration+0x148>
tempsbase=arraybase;

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  408763:	31 c0                	xor    %eax,%eax
  408765:	e8 46 3a 00 00       	callq  40c1b0 <StartStopwatch>
  40876a:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
  408771:	00 

/*
** Execute heapsorts
*/
for(i=0;i<numarrays;i++)
  408772:	8b 44 24 64          	mov    0x64(%rsp),%eax
  408776:	85 c0                	test   %eax,%eax
  408778:	0f 84 d3 fd ff ff    	je     408551 <DoStringSortIteration+0x491>
  40877e:	e9 1f fb ff ff       	jmpq   4082a2 <DoStringSortIteration+0x1e2>

/*
** Return elapsed ticks.
*/
return(elapsed);
}
  408783:	e8 78 87 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  408788:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40878f:	00 

0000000000408790 <lusolve.constprop.6>:
*************
** Solve a linear set of equations: A x = b
** Original matrix A will be destroyed by this operation.
** Returns 0 if matrix is singular, 1 otherwise.
*/
static int lusolve(double a[][LUARRAYCOLS],
  408790:	41 57                	push   %r15
  408792:	41 56                	push   %r14
  408794:	49 89 f7             	mov    %rsi,%r15
  408797:	41 55                	push   %r13
  408799:	41 54                	push   %r12
  40879b:	55                   	push   %rbp
  40879c:	53                   	push   %rbx
  40879d:	66 0f ef db          	pxor   %xmm3,%xmm3
  4087a1:	48 81 ec c8 01 00 00 	sub    $0x1c8,%rsp
	for(j=0;j<n;j++)
		if((double)fabs(a[i][j]) > big)
			big=fabs(a[i][j]);
	/* Bail out on singular matrix */
	if(big==(double)0.0) return(0);
	LUtempvv[i]=1.0/big;
  4087a8:	4c 8b 2d 71 95 20 00 	mov    0x209571(%rip),%r13        # 611d20 <LUtempvv>
*************
** Solve a linear set of equations: A x = b
** Original matrix A will be destroyed by this operation.
** Returns 0 if matrix is singular, 1 otherwise.
*/
static int lusolve(double a[][LUARRAYCOLS],
  4087af:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4087b6:	00 00 
  4087b8:	48 89 84 24 b8 01 00 	mov    %rax,0x1b8(%rsp)
  4087bf:	00 
  4087c0:	31 c0                	xor    %eax,%eax
  4087c2:	48 8d 87 28 03 00 00 	lea    0x328(%rdi),%rax
  4087c9:	f2 0f 10 15 4f 5b 00 	movsd  0x5b4f(%rip),%xmm2        # 40e320 <jtable.3055+0x1590>
  4087d0:	00 
  4087d1:	49 8d b5 28 03 00 00 	lea    0x328(%r13),%rsi
	for(j=0;j<n;j++)
		if((double)fabs(a[i][j]) > big)
			big=fabs(a[i][j]);
	/* Bail out on singular matrix */
	if(big==(double)0.0) return(0);
	LUtempvv[i]=1.0/big;
  4087d8:	f2 0f 10 25 90 55 00 	movsd  0x5590(%rip),%xmm4        # 40dd70 <jtable.3055+0xfe0>
  4087df:	00 
  4087e0:	4c 89 e9             	mov    %r13,%rcx
  4087e3:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  4087e8:	48 89 c2             	mov    %rax,%rdx
  4087eb:	48 8d 82 d8 fc ff ff 	lea    -0x328(%rdx),%rax
*************
** Solve a linear set of equations: A x = b
** Original matrix A will be destroyed by this operation.
** Returns 0 if matrix is singular, 1 otherwise.
*/
static int lusolve(double a[][LUARRAYCOLS],
  4087f2:	66 0f 28 cb          	movapd %xmm3,%xmm1
  4087f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4087fd:	00 00 00 
*d=1;           /* No interchanges yet */

for(i=0;i<n;i++)
{       big=(double)0.0;
	for(j=0;j<n;j++)
		if((double)fabs(a[i][j]) > big)
  408800:	f2 0f 10 00          	movsd  (%rax),%xmm0
  408804:	48 83 c0 08          	add    $0x8,%rax

*d=1;           /* No interchanges yet */

for(i=0;i<n;i++)
{       big=(double)0.0;
	for(j=0;j<n;j++)
  408808:	48 39 c2             	cmp    %rax,%rdx
		if((double)fabs(a[i][j]) > big)
  40880b:	66 0f 54 c2          	andpd  %xmm2,%xmm0
  40880f:	f2 0f 5f c1          	maxsd  %xmm1,%xmm0
  408813:	66 0f 28 c8          	movapd %xmm0,%xmm1

*d=1;           /* No interchanges yet */

for(i=0;i<n;i++)
{       big=(double)0.0;
	for(j=0;j<n;j++)
  408817:	75 e7                	jne    408800 <lusolve.constprop.6+0x70>
		if((double)fabs(a[i][j]) > big)
			big=fabs(a[i][j]);
	/* Bail out on singular matrix */
	if(big==(double)0.0) return(0);
  408819:	66 0f 2e c3          	ucomisd %xmm3,%xmm0
  40881d:	7a 06                	jp     408825 <lusolve.constprop.6+0x95>
  40881f:	0f 84 ca 02 00 00    	je     408aef <lusolve.constprop.6+0x35f>
	LUtempvv[i]=1.0/big;
  408825:	66 0f 28 c4          	movapd %xmm4,%xmm0
  408829:	48 83 c1 08          	add    $0x8,%rcx
  40882d:	48 81 c2 28 03 00 00 	add    $0x328,%rdx
  408834:	f2 0f 5e c1          	divsd  %xmm1,%xmm0
  408838:	f2 0f 11 41 f8       	movsd  %xmm0,-0x8(%rcx)

tiny=(double)1.0e-20;

*d=1;           /* No interchanges yet */

for(i=0;i<n;i++)
  40883d:	48 39 ce             	cmp    %rcx,%rsi
  408840:	75 a9                	jne    4087eb <lusolve.constprop.6+0x5b>
  408842:	ba 10 00 00 00       	mov    $0x10,%edx
  408847:	48 8d 5f 08          	lea    0x8(%rdi),%rbx
  40884b:	49 89 fe             	mov    %rdi,%r14
  40884e:	48 29 fa             	sub    %rdi,%rdx
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  408851:	66 0f 28 f3          	movapd %xmm3,%xmm6
	** (at least as far as the precision of the machine
	** is concerned.)  We'll take the original author's
	** recommendation and replace 0.0 with "tiny".
	*/
	if(a[j][j]==(double)0.0)
		a[j][j]=tiny;
  408855:	f2 0f 10 2d 8b 5a 00 	movsd  0x5a8b(%rip),%xmm5        # 40e2e8 <jtable.3055+0x1558>
  40885c:	00 

tiny=(double)1.0e-20;

*d=1;           /* No interchanges yet */

for(i=0;i<n;i++)
  40885d:	49 89 f8             	mov    %rdi,%r8
  408860:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  408867:	00 
  408868:	31 c9                	xor    %ecx,%ecx
  40886a:	45 31 e4             	xor    %r12d,%r12d
  40886d:	31 c0                	xor    %eax,%eax
  40886f:	45 31 d2             	xor    %r10d,%r10d
  408872:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  408877:	49 63 d2             	movslq %r10d,%rdx
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  40887a:	66 0f 28 fe          	movapd %xmm6,%xmm7
  40887e:	49 8d 6c d5 00       	lea    0x0(%r13,%rdx,8),%rbp
  408883:	48 69 d2 28 03 00 00 	imul   $0x328,%rdx,%rdx
  40888a:	4c 8d 1c 17          	lea    (%rdi,%rdx,1),%r11
  40888e:	66 90                	xchg   %ax,%ax
			a[i][j]=sum;
		}
	big=(double)0.0;
	for(i=j;i<n;i++)
	{       sum=a[i][j];
		if(j!=0)
  408890:	85 c0                	test   %eax,%eax
					sum-=(a[i][k]*a[k][j]);
			a[i][j]=sum;
		}
	big=(double)0.0;
	for(i=j;i<n;i++)
	{       sum=a[i][j];
  408892:	f2 41 0f 10 0c cb    	movsd  (%r11,%rcx,8),%xmm1
		if(j!=0)
  408898:	74 31                	je     4088cb <lusolve.constprop.6+0x13b>
  40889a:	4c 8d 4b f8          	lea    -0x8(%rbx),%r9
  40889e:	4c 89 de             	mov    %r11,%rsi
  4088a1:	31 d2                	xor    %edx,%edx
  4088a3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
			for(k=0;k<j;k++)
				sum-=a[i][k]*a[k][j];
  4088a8:	f2 0f 10 06          	movsd  (%rsi),%xmm0
		}
	big=(double)0.0;
	for(i=j;i<n;i++)
	{       sum=a[i][j];
		if(j!=0)
			for(k=0;k<j;k++)
  4088ac:	83 c2 01             	add    $0x1,%edx
  4088af:	48 83 c6 08          	add    $0x8,%rsi
  4088b3:	49 81 c1 28 03 00 00 	add    $0x328,%r9
				sum-=a[i][k]*a[k][j];
  4088ba:	f2 41 0f 59 81 d8 fc 	mulsd  -0x328(%r9),%xmm0
  4088c1:	ff ff 
		}
	big=(double)0.0;
	for(i=j;i<n;i++)
	{       sum=a[i][j];
		if(j!=0)
			for(k=0;k<j;k++)
  4088c3:	39 c2                	cmp    %eax,%edx
				sum-=a[i][k]*a[k][j];
  4088c5:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
		}
	big=(double)0.0;
	for(i=j;i<n;i++)
	{       sum=a[i][j];
		if(j!=0)
			for(k=0;k<j;k++)
  4088c9:	7c dd                	jl     4088a8 <lusolve.constprop.6+0x118>
				sum-=a[i][k]*a[k][j];
		a[i][j]=sum;
  4088cb:	f2 41 0f 11 0c cb    	movsd  %xmm1,(%r11,%rcx,8)
		dum=LUtempvv[i]*fabs(sum);
  4088d1:	66 0f 54 ca          	andpd  %xmm2,%xmm1
  4088d5:	f2 0f 59 4d 00       	mulsd  0x0(%rbp),%xmm1
		if(dum>=big)
  4088da:	66 0f 2e cf          	ucomisd %xmm7,%xmm1
  4088de:	72 07                	jb     4088e7 <lusolve.constprop.6+0x157>
		{       big=dum;
  4088e0:	66 0f 28 f9          	movapd %xmm1,%xmm7
		if(j!=0)
			for(k=0;k<j;k++)
				sum-=a[i][k]*a[k][j];
		a[i][j]=sum;
		dum=LUtempvv[i]*fabs(sum);
		if(dum>=big)
  4088e4:	45 89 d4             	mov    %r10d,%r12d
				for(k=0;k<i;k++)
					sum-=(a[i][k]*a[k][j]);
			a[i][j]=sum;
		}
	big=(double)0.0;
	for(i=j;i<n;i++)
  4088e7:	41 83 c2 01          	add    $0x1,%r10d
  4088eb:	48 83 c5 08          	add    $0x8,%rbp
  4088ef:	49 81 c3 28 03 00 00 	add    $0x328,%r11
  4088f6:	41 83 fa 65          	cmp    $0x65,%r10d
  4088fa:	75 94                	jne    408890 <lusolve.constprop.6+0x100>
		if(dum>=big)
		{       big=dum;
			imax=i;
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
  4088fc:	41 39 c4             	cmp    %eax,%r12d
  4088ff:	0f 84 f5 00 00 00    	je     4089fa <lusolve.constprop.6+0x26a>
  408905:	49 63 ec             	movslq %r12d,%rbp
  408908:	48 8b 34 24          	mov    (%rsp),%rsi
  40890c:	48 69 d5 28 03 00 00 	imul   $0x328,%rbp,%rdx
  408913:	4c 8d 14 f5 00 00 00 	lea    0x0(,%rsi,8),%r10
  40891a:	00 
  40891b:	48 8d 72 10          	lea    0x10(%rdx),%rsi
  40891f:	4c 8d 0c 17          	lea    (%rdi,%rdx,1),%r9
  408923:	49 39 f2             	cmp    %rsi,%r10
  408926:	7d 11                	jge    408939 <lusolve.constprop.6+0x1a9>
  408928:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40892d:	4c 01 c6             	add    %r8,%rsi
  408930:	48 39 d6             	cmp    %rdx,%rsi
  408933:	0f 8f fe 01 00 00    	jg     408b37 <lusolve.constprop.6+0x3a7>
  408939:	41 f6 c1 08          	test   $0x8,%r9b
  40893d:	0f 84 dd 01 00 00    	je     408b20 <lusolve.constprop.6+0x390>
	{       for(k=0;k<n;k++)
		{       dum=a[imax][k];
  408943:	f2 41 0f 10 01       	movsd  (%r9),%xmm0
		{       big=dum;
			imax=i;
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
	{       for(k=0;k<n;k++)
  408948:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%rsp)
  40894f:	00 
		{       dum=a[imax][k];
			a[imax][k]=a[j][k];
			a[j][k]=dum;
  408950:	ba 01 00 00 00       	mov    $0x1,%edx
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
	{       for(k=0;k<n;k++)
		{       dum=a[imax][k];
			a[imax][k]=a[j][k];
  408955:	f2 41 0f 10 08       	movsd  (%r8),%xmm1
			a[j][k]=dum;
  40895a:	c7 44 24 14 64 00 00 	movl   $0x64,0x14(%rsp)
  408961:	00 
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
	{       for(k=0;k<n;k++)
		{       dum=a[imax][k];
			a[imax][k]=a[j][k];
  408962:	f2 41 0f 11 09       	movsd  %xmm1,(%r9)
			a[j][k]=dum;
  408967:	f2 41 0f 11 00       	movsd  %xmm0,(%r8)
  40896c:	48 8d 74 ad 00       	lea    0x0(%rbp,%rbp,4),%rsi
  408971:	48 8d 34 b6          	lea    (%rsi,%rsi,4),%rsi
  408975:	48 8d 74 b5 00       	lea    0x0(%rbp,%rsi,4),%rsi
  40897a:	48 01 d6             	add    %rdx,%rsi
  40897d:	48 03 14 24          	add    (%rsp),%rdx
  408981:	4c 8d 1c f7          	lea    (%rdi,%rsi,8),%r11
		if(dum>=big)
		{       big=dum;
			imax=i;
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
  408985:	31 f6                	xor    %esi,%esi
  408987:	4c 8d 14 d7          	lea    (%rdi,%rdx,8),%r10
  40898b:	31 d2                	xor    %edx,%edx
  40898d:	0f 1f 00             	nopl   (%rax)
	{       for(k=0;k<n;k++)
		{       dum=a[imax][k];
  408990:	66 41 0f 28 04 13    	movapd (%r11,%rdx,1),%xmm0
  408996:	83 c6 01             	add    $0x1,%esi
			a[imax][k]=a[j][k];
  408999:	66 41 0f 10 0c 12    	movupd (%r10,%rdx,1),%xmm1
  40899f:	41 0f 29 0c 13       	movaps %xmm1,(%r11,%rdx,1)
			a[j][k]=dum;
  4089a4:	41 0f 11 04 12       	movups %xmm0,(%r10,%rdx,1)
  4089a9:	48 83 c2 10          	add    $0x10,%rdx
  4089ad:	83 fe 31             	cmp    $0x31,%esi
  4089b0:	76 de                	jbe    408990 <lusolve.constprop.6+0x200>
  4089b2:	8b 54 24 10          	mov    0x10(%rsp),%edx
  4089b6:	83 c2 64             	add    $0x64,%edx
  4089b9:	83 7c 24 14 64       	cmpl   $0x64,0x14(%rsp)
  4089be:	74 1f                	je     4089df <lusolve.constprop.6+0x24f>
  4089c0:	48 63 d2             	movslq %edx,%rdx
  4089c3:	48 c1 e2 03          	shl    $0x3,%rdx
  4089c7:	49 01 d1             	add    %rdx,%r9
  4089ca:	4c 01 c2             	add    %r8,%rdx
			imax=i;
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
	{       for(k=0;k<n;k++)
		{       dum=a[imax][k];
  4089cd:	f2 41 0f 10 01       	movsd  (%r9),%xmm0
			a[imax][k]=a[j][k];
  4089d2:	f2 0f 10 0a          	movsd  (%rdx),%xmm1
  4089d6:	f2 41 0f 11 09       	movsd  %xmm1,(%r9)
			a[j][k]=dum;
  4089db:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
		}
		*d=-*d;         /* Change parity of d */
		dum=LUtempvv[imax];
  4089df:	49 8d 54 ed 00       	lea    0x0(%r13,%rbp,8),%rdx
		LUtempvv[imax]=LUtempvv[j]; /* Don't forget scale factor */
  4089e4:	f2 41 0f 10 4c cd 00 	movsd  0x0(%r13,%rcx,8),%xmm1
		{       dum=a[imax][k];
			a[imax][k]=a[j][k];
			a[j][k]=dum;
		}
		*d=-*d;         /* Change parity of d */
		dum=LUtempvv[imax];
  4089eb:	f2 0f 10 02          	movsd  (%rdx),%xmm0
		LUtempvv[imax]=LUtempvv[j]; /* Don't forget scale factor */
  4089ef:	f2 0f 11 0a          	movsd  %xmm1,(%rdx)
		LUtempvv[j]=dum;
  4089f3:	f2 41 0f 11 44 cd 00 	movsd  %xmm0,0x0(%r13,%rcx,8)
  4089fa:	48 63 d0             	movslq %eax,%rdx
	}
	indx[j]=imax;
  4089fd:	44 89 64 8c 20       	mov    %r12d,0x20(%rsp,%rcx,4)
  408a02:	49 8d 14 d0          	lea    (%r8,%rdx,8),%rdx
	** If the pivot element is zero, the matrix is singular
	** (at least as far as the precision of the machine
	** is concerned.)  We'll take the original author's
	** recommendation and replace 0.0 with "tiny".
	*/
	if(a[j][j]==(double)0.0)
  408a06:	f2 0f 10 02          	movsd  (%rdx),%xmm0
  408a0a:	66 0f 2e c3          	ucomisd %xmm3,%xmm0
  408a0e:	7a 0a                	jp     408a1a <lusolve.constprop.6+0x28a>
  408a10:	75 08                	jne    408a1a <lusolve.constprop.6+0x28a>
		a[j][j]=tiny;
  408a12:	f2 0f 11 2a          	movsd  %xmm5,(%rdx)
  408a16:	66 0f 28 c5          	movapd %xmm5,%xmm0

	if(j!=(n-1))
  408a1a:	83 f8 64             	cmp    $0x64,%eax
  408a1d:	0f 84 47 01 00 00    	je     408b6a <lusolve.constprop.6+0x3da>
	{       dum=1.0/a[j][j];
  408a23:	66 0f 28 cc          	movapd %xmm4,%xmm1
		for(i=j+1;i<n;i++)
  408a27:	44 8d 50 01          	lea    0x1(%rax),%r10d
  408a2b:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	*/
	if(a[j][j]==(double)0.0)
		a[j][j]=tiny;

	if(j!=(n-1))
	{       dum=1.0/a[j][j];
  408a30:	f2 0f 5e c8          	divsd  %xmm0,%xmm1
		for(i=j+1;i<n;i++)
  408a34:	44 89 d2             	mov    %r10d,%edx
  408a37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  408a3e:	00 00 
  408a40:	83 c2 01             	add    $0x1,%edx
  408a43:	48 05 28 03 00 00    	add    $0x328,%rax
			a[i][j]=a[i][j]*dum;
  408a49:	f2 0f 10 80 d8 fc ff 	movsd  -0x328(%rax),%xmm0
  408a50:	ff 
  408a51:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  408a55:	f2 0f 11 80 d8 fc ff 	movsd  %xmm0,-0x328(%rax)
  408a5c:	ff 
	if(a[j][j]==(double)0.0)
		a[j][j]=tiny;

	if(j!=(n-1))
	{       dum=1.0/a[j][j];
		for(i=j+1;i<n;i++)
  408a5d:	83 fa 65             	cmp    $0x65,%edx
  408a60:	75 de                	jne    408a40 <lusolve.constprop.6+0x2b0>
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
		{       sum=a[i][j];
  408a62:	45 31 db             	xor    %r11d,%r11d
  408a65:	f2 0f 10 0b          	movsd  (%rbx),%xmm1
  408a69:	48 89 dd             	mov    %rbx,%rbp
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  408a6c:	41 83 c3 01          	add    $0x1,%r11d
  408a70:	48 83 c1 01          	add    $0x1,%rcx
		{       sum=a[i][j];
  408a74:	49 89 f9             	mov    %rdi,%r9
  408a77:	48 29 fd             	sub    %rdi,%rbp
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  408a7a:	45 39 d3             	cmp    %r10d,%r11d
		{       sum=a[i][j];
			if(i!=0)
				for(k=0;k<i;k++)
					sum-=(a[i][k]*a[k][j]);
			a[i][j]=sum;
  408a7d:	f2 41 0f 11 0c c9    	movsd  %xmm1,(%r9,%rcx,8)
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  408a83:	74 49                	je     408ace <lusolve.constprop.6+0x33e>
		{       sum=a[i][j];
  408a85:	49 81 c1 28 03 00 00 	add    $0x328,%r9
  408a8c:	48 89 d8             	mov    %rbx,%rax
  408a8f:	f2 41 0f 10 0c c9    	movsd  (%r9,%rcx,8),%xmm1
  408a95:	49 8d 34 29          	lea    (%r9,%rbp,1),%rsi
  408a99:	4c 89 ca             	mov    %r9,%rdx
  408a9c:	0f 1f 40 00          	nopl   0x0(%rax)
			if(i!=0)
				for(k=0;k<i;k++)
					sum-=(a[i][k]*a[k][j]);
  408aa0:	f2 0f 10 02          	movsd  (%rdx),%xmm0
  408aa4:	48 05 28 03 00 00    	add    $0x328,%rax
  408aaa:	48 83 c2 08          	add    $0x8,%rdx
  408aae:	f2 0f 59 80 d8 fc ff 	mulsd  -0x328(%rax),%xmm0
  408ab5:	ff 
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
		{       sum=a[i][j];
			if(i!=0)
				for(k=0;k<i;k++)
  408ab6:	48 39 c6             	cmp    %rax,%rsi
					sum-=(a[i][k]*a[k][j]);
  408ab9:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
		{       sum=a[i][j];
			if(i!=0)
				for(k=0;k<i;k++)
  408abd:	75 e1                	jne    408aa0 <lusolve.constprop.6+0x310>
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  408abf:	41 83 c3 01          	add    $0x1,%r11d
		{       sum=a[i][j];
			if(i!=0)
				for(k=0;k<i;k++)
					sum-=(a[i][k]*a[k][j]);
			a[i][j]=sum;
  408ac3:	f2 41 0f 11 0c c9    	movsd  %xmm1,(%r9,%rcx,8)
/*
** Crout's algorithm...loop over columns.
*/
for(j=0;j<n;j++)
{       if(j!=0)
		for(i=0;i<j;i++)
  408ac9:	45 39 d3             	cmp    %r10d,%r11d
  408acc:	75 b7                	jne    408a85 <lusolve.constprop.6+0x2f5>
  408ace:	48 81 44 24 08 30 03 	addq   $0x330,0x8(%rsp)
  408ad5:	00 00 
  408ad7:	49 81 c0 28 03 00 00 	add    $0x328,%r8
  408ade:	48 83 04 24 65       	addq   $0x65,(%rsp)
  408ae3:	48 83 c3 08          	add    $0x8,%rbx
  408ae7:	44 89 d0             	mov    %r10d,%eax
  408aea:	e9 88 fd ff ff       	jmpq   408877 <lusolve.constprop.6+0xe7>
int d;
#ifdef DEBUG
int i,j;
#endif

if(ludcmp(a,n,indx,&d)==0) return(0);
  408aef:	31 c0                	xor    %eax,%eax
}
printf("\n");
#endif

return(1);
}
  408af1:	48 8b 9c 24 b8 01 00 	mov    0x1b8(%rsp),%rbx
  408af8:	00 
  408af9:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  408b00:	00 00 
  408b02:	0f 85 76 01 00 00    	jne    408c7e <lusolve.constprop.6+0x4ee>
  408b08:	48 81 c4 c8 01 00 00 	add    $0x1c8,%rsp
  408b0f:	5b                   	pop    %rbx
  408b10:	5d                   	pop    %rbp
  408b11:	41 5c                	pop    %r12
  408b13:	41 5d                	pop    %r13
  408b15:	41 5e                	pop    %r14
  408b17:	41 5f                	pop    %r15
  408b19:	c3                   	retq   
  408b1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		if(dum>=big)
		{       big=dum;
			imax=i;
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
  408b20:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
  408b27:	00 
  408b28:	31 d2                	xor    %edx,%edx
  408b2a:	c7 44 24 14 65 00 00 	movl   $0x65,0x14(%rsp)
  408b31:	00 
  408b32:	e9 35 fe ff ff       	jmpq   40896c <lusolve.constprop.6+0x1dc>
  408b37:	31 d2                	xor    %edx,%edx
  408b39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	{       for(k=0;k<n;k++)
		{       dum=a[imax][k];
  408b40:	f2 41 0f 10 04 11    	movsd  (%r9,%rdx,1),%xmm0
			a[imax][k]=a[j][k];
  408b46:	f2 41 0f 10 0c 10    	movsd  (%r8,%rdx,1),%xmm1
  408b4c:	f2 41 0f 11 0c 11    	movsd  %xmm1,(%r9,%rdx,1)
			a[j][k]=dum;
  408b52:	f2 41 0f 11 04 10    	movsd  %xmm0,(%r8,%rdx,1)
  408b58:	48 83 c2 08          	add    $0x8,%rdx
		{       big=dum;
			imax=i;
		}
	}
	if(j!=imax)             /* Interchange rows if necessary */
	{       for(k=0;k<n;k++)
  408b5c:	48 81 fa 28 03 00 00 	cmp    $0x328,%rdx
  408b63:	75 db                	jne    408b40 <lusolve.constprop.6+0x3b0>
  408b65:	e9 75 fe ff ff       	jmpq   4089df <lusolve.constprop.6+0x24f>
	** recommendation and replace 0.0 with "tiny".
	*/
	if(a[j][j]==(double)0.0)
		a[j][j]=tiny;

	if(j!=(n-1))
  408b6a:	31 f6                	xor    %esi,%esi
  408b6c:	41 b9 ff ff ff ff    	mov    $0xffffffff,%r9d
** is to unscramble the permutation as we go.
*/
ii=-1;
for(i=0;i<n;i++)
{       ip=indx[i];
	sum=b[ip];
  408b72:	48 63 44 b4 20       	movslq 0x20(%rsp,%rsi,4),%rax
	b[ip]=b[i];
  408b77:	f2 41 0f 10 04 f7    	movsd  (%r15,%rsi,8),%xmm0
	if(ii!=-1)
  408b7d:	41 83 f9 ff          	cmp    $0xffffffff,%r9d
  408b81:	41 89 f0             	mov    %esi,%r8d
** is to unscramble the permutation as we go.
*/
ii=-1;
for(i=0;i<n;i++)
{       ip=indx[i];
	sum=b[ip];
  408b84:	49 8d 04 c7          	lea    (%r15,%rax,8),%rax
  408b88:	f2 0f 10 08          	movsd  (%rax),%xmm1
	b[ip]=b[i];
  408b8c:	f2 0f 11 00          	movsd  %xmm0,(%rax)
	if(ii!=-1)
  408b90:	0f 84 d4 00 00 00    	je     408c6a <lusolve.constprop.6+0x4da>
		for(j=ii;j<i;j++)
  408b96:	44 39 ce             	cmp    %r9d,%esi
  408b99:	7e 28                	jle    408bc3 <lusolve.constprop.6+0x433>
  408b9b:	49 63 c1             	movslq %r9d,%rax
  408b9e:	49 8d 14 c7          	lea    (%r15,%rax,8),%rdx
  408ba2:	44 89 c8             	mov    %r9d,%eax
			sum=sum-a[i][j]*b[j];
  408ba5:	48 63 c8             	movslq %eax,%rcx
for(i=0;i<n;i++)
{       ip=indx[i];
	sum=b[ip];
	b[ip]=b[i];
	if(ii!=-1)
		for(j=ii;j<i;j++)
  408ba8:	83 c0 01             	add    $0x1,%eax
  408bab:	48 83 c2 08          	add    $0x8,%rdx
			sum=sum-a[i][j]*b[j];
  408baf:	f2 41 0f 10 04 ce    	movsd  (%r14,%rcx,8),%xmm0
  408bb5:	f2 0f 59 42 f8       	mulsd  -0x8(%rdx),%xmm0
for(i=0;i<n;i++)
{       ip=indx[i];
	sum=b[ip];
	b[ip]=b[i];
	if(ii!=-1)
		for(j=ii;j<i;j++)
  408bba:	41 39 c0             	cmp    %eax,%r8d
			sum=sum-a[i][j]*b[j];
  408bbd:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
for(i=0;i<n;i++)
{       ip=indx[i];
	sum=b[ip];
	b[ip]=b[i];
	if(ii!=-1)
		for(j=ii;j<i;j++)
  408bc1:	75 e2                	jne    408ba5 <lusolve.constprop.6+0x415>
		** If a nonzero element is encountered, we have
		** to do the sums in the loop above.
		*/
		if(sum!=(double)0.0)
			ii=i;
	b[i]=sum;
  408bc3:	f2 41 0f 11 0c f7    	movsd  %xmm1,(%r15,%rsi,8)
  408bc9:	48 83 c6 01          	add    $0x1,%rsi
  408bcd:	49 81 c6 28 03 00 00 	add    $0x328,%r14
** the index of the first nonvanishing element of b[].
** We now do the forward substitution. The only wrinkle
** is to unscramble the permutation as we go.
*/
ii=-1;
for(i=0;i<n;i++)
  408bd4:	48 83 fe 65          	cmp    $0x65,%rsi
  408bd8:	75 98                	jne    408b72 <lusolve.constprop.6+0x3e2>
  408bda:	49 8d 9f 28 03 00 00 	lea    0x328(%r15),%rbx
  408be1:	41 b8 63 00 00 00    	mov    $0x63,%r8d
  408be7:	4c 8d 8f c0 3e 01 00 	lea    0x13ec0(%rdi),%r9
  408bee:	48 81 c7 a0 3b 01 00 	add    $0x13ba0,%rdi
** Do backsubstitution
*/
for(i=(n-1);i>=0;i--)
{
	sum=b[i];
	if(i!=(n-1))
  408bf5:	41 83 f8 63          	cmp    $0x63,%r8d
** the index of the first nonvanishing element of b[].
** We now do the forward substitution. The only wrinkle
** is to unscramble the permutation as we go.
*/
ii=-1;
for(i=0;i<n;i++)
  408bf9:	48 89 de             	mov    %rbx,%rsi
/*
** Do backsubstitution
*/
for(i=(n-1);i>=0;i--)
{
	sum=b[i];
  408bfc:	f2 0f 10 4e f8       	movsd  -0x8(%rsi),%xmm1
	if(i!=(n-1))
  408c01:	74 5b                	je     408c5e <lusolve.constprop.6+0x4ce>
  408c03:	41 8d 40 02          	lea    0x2(%r8),%eax
  408c07:	48 89 f2             	mov    %rsi,%rdx
  408c0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		for(j=(i+1);j<n;j++)
			sum=sum-a[i][j]*b[j];
  408c10:	48 63 c8             	movslq %eax,%rcx
*/
for(i=(n-1);i>=0;i--)
{
	sum=b[i];
	if(i!=(n-1))
		for(j=(i+1);j<n;j++)
  408c13:	83 c0 01             	add    $0x1,%eax
  408c16:	48 83 c2 08          	add    $0x8,%rdx
			sum=sum-a[i][j]*b[j];
  408c1a:	f2 0f 10 04 cf       	movsd  (%rdi,%rcx,8),%xmm0
  408c1f:	f2 0f 59 42 f8       	mulsd  -0x8(%rdx),%xmm0
*/
for(i=(n-1);i>=0;i--)
{
	sum=b[i];
	if(i!=(n-1))
		for(j=(i+1);j<n;j++)
  408c24:	83 f8 65             	cmp    $0x65,%eax
			sum=sum-a[i][j]*b[j];
  408c27:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
*/
for(i=(n-1);i>=0;i--)
{
	sum=b[i];
	if(i!=(n-1))
		for(j=(i+1);j<n;j++)
  408c2b:	75 e3                	jne    408c10 <lusolve.constprop.6+0x480>
			sum=sum-a[i][j]*b[j];
	b[i]=sum/a[i][i];
  408c2d:	f2 41 0f 5e 09       	divsd  (%r9),%xmm1
	b[i]=sum;
}
/*
** Do backsubstitution
*/
for(i=(n-1);i>=0;i--)
  408c32:	41 83 f8 ff          	cmp    $0xffffffff,%r8d
{
	sum=b[i];
	if(i!=(n-1))
		for(j=(i+1);j<n;j++)
			sum=sum-a[i][j]*b[j];
	b[i]=sum/a[i][i];
  408c36:	f2 0f 11 4e f8       	movsd  %xmm1,-0x8(%rsi)
	b[i]=sum;
}
/*
** Do backsubstitution
*/
for(i=(n-1);i>=0;i--)
  408c3b:	74 46                	je     408c83 <lusolve.constprop.6+0x4f3>
  408c3d:	41 83 e8 01          	sub    $0x1,%r8d
  408c41:	48 83 ee 08          	sub    $0x8,%rsi
  408c45:	49 81 e9 30 03 00 00 	sub    $0x330,%r9
  408c4c:	48 81 ef 28 03 00 00 	sub    $0x328,%rdi
{
	sum=b[i];
	if(i!=(n-1))
  408c53:	41 83 f8 63          	cmp    $0x63,%r8d
/*
** Do backsubstitution
*/
for(i=(n-1);i>=0;i--)
{
	sum=b[i];
  408c57:	f2 0f 10 4e f8       	movsd  -0x8(%rsi),%xmm1
	if(i!=(n-1))
  408c5c:	75 a5                	jne    408c03 <lusolve.constprop.6+0x473>
		for(j=(i+1);j<n;j++)
			sum=sum-a[i][j]*b[j];
	b[i]=sum/a[i][i];
  408c5e:	f2 41 0f 5e 09       	divsd  (%r9),%xmm1
  408c63:	f2 0f 11 4e f8       	movsd  %xmm1,-0x8(%rsi)
  408c68:	eb d3                	jmp    408c3d <lusolve.constprop.6+0x4ad>
	else
		/*
		** If a nonzero element is encountered, we have
		** to do the sums in the loop above.
		*/
		if(sum!=(double)0.0)
  408c6a:	66 0f 2e cb          	ucomisd %xmm3,%xmm1
  408c6e:	7a 06                	jp     408c76 <lusolve.constprop.6+0x4e6>
  408c70:	0f 84 4d ff ff ff    	je     408bc3 <lusolve.constprop.6+0x433>
  408c76:	45 89 c1             	mov    %r8d,%r9d
  408c79:	e9 45 ff ff ff       	jmpq   408bc3 <lusolve.constprop.6+0x433>
}
printf("\n");
#endif

return(1);
}
  408c7e:	e8 7d 82 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  408c83:	bf 62 de 40 00       	mov    $0x40de62,%edi
  408c88:	4c 89 fd             	mov    %r15,%rbp
  408c8b:	e8 00 82 ff ff       	callq  400e90 <puts@plt>
  408c90:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
  408c95:	be 6c de 40 00       	mov    $0x40de6c,%esi
  408c9a:	bf 01 00 00 00       	mov    $0x1,%edi
  408c9f:	b8 01 00 00 00       	mov    $0x1,%eax
  408ca4:	48 83 c5 08          	add    $0x8,%rbp
  408ca8:	e8 63 83 ff ff       	callq  401010 <__printf_chk@plt>
/* Matrix not singular -- proceed */
lubksb(a,n,indx,b);

#ifdef DEBUG
printf("Solution:\n");
for(i=0;i<n;i++)
  408cad:	48 39 eb             	cmp    %rbp,%rbx
  408cb0:	75 de                	jne    408c90 <lusolve.constprop.6+0x500>
  408cb2:	bf 0a 00 00 00       	mov    $0xa,%edi
  408cb7:	e8 84 81 ff ff       	callq  400e40 <putchar@plt>
  */
}
printf("\n");
#endif

return(1);
  408cbc:	b8 01 00 00 00       	mov    $0x1,%eax
  408cc1:	e9 2b fe ff ff       	jmpq   408af1 <lusolve.constprop.6+0x361>
  408cc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  408ccd:	00 00 00 

0000000000408cd0 <DoNumSort>:
**  returned result in # of longword sorted per second.
**  Not so; the routine returns # of iterations per sec.
*/

void DoNumSort(void)
{
  408cd0:	41 54                	push   %r12
  408cd2:	55                   	push   %rbp
  408cd3:	53                   	push   %rbx
  408cd4:	48 83 ec 20          	sub    $0x20,%rsp
errorcontext="CPU:Numeric Sort";

/*
** See if we need to do self adjustment code.
*/
if(numsortstruct->adjust==0)
  408cd8:	8b 35 62 80 20 00    	mov    0x208062(%rip),%esi        # 610d40 <global_numsortstruct>
**  returned result in # of longword sorted per second.
**  Not so; the routine returns # of iterations per sec.
*/

void DoNumSort(void)
{
  408cde:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  408ce5:	00 00 
  408ce7:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  408cec:	31 c0                	xor    %eax,%eax
errorcontext="CPU:Numeric Sort";

/*
** See if we need to do self adjustment code.
*/
if(numsortstruct->adjust==0)
  408cee:	85 f6                	test   %esi,%esi
  408cf0:	0f 85 aa 00 00 00    	jne    408da0 <DoNumSort+0xd0>
	** Self-adjustment code.  The system begins by sorting 1
	** array.  If it does that in no time, then two arrays
	** are built and sorted.  This process continues until
	** enough arrays are built to handle the tolerance.
	*/
	numsortstruct->numarrays=1;
  408cf6:	b9 01 00 00 00       	mov    $0x1,%ecx
  408cfb:	bf 01 00 00 00       	mov    $0x1,%edi
  408d00:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
  408d05:	66 89 0d 4c 80 20 00 	mov    %cx,0x20804c(%rip)        # 610d58 <global_numsortstruct+0x18>
  408d0c:	eb 4b                	jmp    408d59 <DoNumSort+0x89>
  408d0e:	66 90                	xchg   %ax,%ax
		** Do an iteration of the numeric sort.  If the
		** elapsed time is less than or equal to the permitted
		** minimum, then allocate for more arrays and
		** try again.
		*/
		if(DoNumSortIteration(arraybase,
  408d10:	0f b7 15 41 80 20 00 	movzwl 0x208041(%rip),%edx        # 610d58 <global_numsortstruct+0x18>
  408d17:	48 8b 35 42 80 20 00 	mov    0x208042(%rip),%rsi        # 610d60 <global_numsortstruct+0x20>
  408d1e:	48 89 df             	mov    %rbx,%rdi
  408d21:	e8 fa ed ff ff       	callq  407b20 <DoNumSortIteration>
  408d26:	48 3b 05 93 79 20 00 	cmp    0x207993(%rip),%rax        # 6106c0 <global_min_ticks>
  408d2d:	0f 87 bd 00 00 00    	ja     408df0 <DoNumSort+0x120>
			numsortstruct->arraysize,
			numsortstruct->numarrays)>global_min_ticks)
			break;          /* We're ok...exit */

		FreeMemory((farvoid *)arraybase,&systemerror);
  408d33:	48 89 df             	mov    %rbx,%rdi
  408d36:	48 89 ee             	mov    %rbp,%rsi
  408d39:	e8 f2 30 00 00       	callq  40be30 <FreeMemory>
		if(numsortstruct->numarrays++>NUMNUMARRAYS)
  408d3e:	0f b7 05 13 80 20 00 	movzwl 0x208013(%rip),%eax        # 610d58 <global_numsortstruct+0x18>
  408d45:	8d 78 01             	lea    0x1(%rax),%edi
  408d48:	66 3d 10 27          	cmp    $0x2710,%ax
  408d4c:	66 89 3d 05 80 20 00 	mov    %di,0x208005(%rip)        # 610d58 <global_numsortstruct+0x18>
  408d53:	0f 87 77 01 00 00    	ja     408ed0 <DoNumSort+0x200>
	while(1)
	{
		/*
		** Allocate space for arrays
		*/
		arraybase=(farlong *)AllocateMemory(sizeof(long) *
  408d59:	0f b7 ff             	movzwl %di,%edi
  408d5c:	48 89 ee             	mov    %rbp,%rsi
  408d5f:	48 0f af 3d f9 7f 20 	imul   0x207ff9(%rip),%rdi        # 610d60 <global_numsortstruct+0x20>
  408d66:	00 
  408d67:	48 c1 e7 03          	shl    $0x3,%rdi
  408d6b:	e8 c0 2f 00 00       	callq  40bd30 <AllocateMemory>
			numsortstruct->numarrays * numsortstruct->arraysize,
			&systemerror);
		if(systemerror)
  408d70:	8b 74 24 14          	mov    0x14(%rsp),%esi
	while(1)
	{
		/*
		** Allocate space for arrays
		*/
		arraybase=(farlong *)AllocateMemory(sizeof(long) *
  408d74:	48 89 c3             	mov    %rax,%rbx
			numsortstruct->numarrays * numsortstruct->arraysize,
			&systemerror);
		if(systemerror)
  408d77:	85 f6                	test   %esi,%esi
  408d79:	74 95                	je     408d10 <DoNumSort+0x40>
		{       ReportError(errorcontext,systemerror);
  408d7b:	bf 73 de 40 00       	mov    $0x40de73,%edi
  408d80:	e8 eb 33 00 00       	callq  40c170 <ReportError>
			FreeMemory((farvoid *)arraybase,
  408d85:	48 89 ee             	mov    %rbp,%rsi
  408d88:	48 89 df             	mov    %rbx,%rdi
  408d8b:	e8 a0 30 00 00       	callq  40be30 <FreeMemory>
				  &systemerror);
			ErrorExit();
  408d90:	31 c0                	xor    %eax,%eax
  408d92:	e8 09 34 00 00       	callq  40c1a0 <ErrorExit>
  408d97:	e9 74 ff ff ff       	jmpq   408d10 <DoNumSort+0x40>
  408d9c:	0f 1f 40 00          	nopl   0x0(%rax)
}
else
{       /*
	** Allocate space for arrays
	*/
	arraybase=(farlong *)AllocateMemory(sizeof(long) *
  408da0:	48 8b 05 b9 7f 20 00 	mov    0x207fb9(%rip),%rax        # 610d60 <global_numsortstruct+0x20>
  408da7:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
  408dac:	48 89 ee             	mov    %rbp,%rsi
  408daf:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
  408db6:	00 
  408db7:	0f b7 05 9a 7f 20 00 	movzwl 0x207f9a(%rip),%eax        # 610d58 <global_numsortstruct+0x18>
  408dbe:	48 0f af f8          	imul   %rax,%rdi
  408dc2:	e8 69 2f 00 00       	callq  40bd30 <AllocateMemory>
		numsortstruct->numarrays * numsortstruct->arraysize,
		&systemerror);
	if(systemerror)
  408dc7:	8b 74 24 14          	mov    0x14(%rsp),%esi
}
else
{       /*
	** Allocate space for arrays
	*/
	arraybase=(farlong *)AllocateMemory(sizeof(long) *
  408dcb:	48 89 c3             	mov    %rax,%rbx
		numsortstruct->numarrays * numsortstruct->arraysize,
		&systemerror);
	if(systemerror)
  408dce:	85 f6                	test   %esi,%esi
  408dd0:	74 1e                	je     408df0 <DoNumSort+0x120>
	{       ReportError(errorcontext,systemerror);
  408dd2:	bf 73 de 40 00       	mov    $0x40de73,%edi
  408dd7:	e8 94 33 00 00       	callq  40c170 <ReportError>
		FreeMemory((farvoid *)arraybase,
  408ddc:	48 89 ee             	mov    %rbp,%rsi
  408ddf:	48 89 df             	mov    %rbx,%rdi
  408de2:	e8 49 30 00 00       	callq  40be30 <FreeMemory>
			  &systemerror);
		ErrorExit();
  408de7:	31 c0                	xor    %eax,%eax
  408de9:	e8 b2 33 00 00       	callq  40c1a0 <ErrorExit>
  408dee:	66 90                	xchg   %ax,%ax
/*
** All's well if we get here.  Repeatedly perform sorts until the
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
iterations=(double)0.0;
  408df0:	66 0f ef e4          	pxor   %xmm4,%xmm4
}
/*
** All's well if we get here.  Repeatedly perform sorts until the
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
  408df4:	45 31 e4             	xor    %r12d,%r12d
iterations=(double)0.0;
  408df7:	f2 0f 11 64 24 08    	movsd  %xmm4,0x8(%rsp)
  408dfd:	0f 1f 00             	nopl   (%rax)

do {
	accumtime+=DoNumSortIteration(arraybase,
  408e00:	0f b7 15 51 7f 20 00 	movzwl 0x207f51(%rip),%edx        # 610d58 <global_numsortstruct+0x18>
  408e07:	48 8b 35 52 7f 20 00 	mov    0x207f52(%rip),%rsi        # 610d60 <global_numsortstruct+0x20>
  408e0e:	48 89 df             	mov    %rbx,%rdi
  408e11:	e8 0a ed ff ff       	callq  407b20 <DoNumSortIteration>
		numsortstruct->arraysize,
		numsortstruct->numarrays);
	iterations+=(double)1.0;
  408e16:	f2 0f 10 15 52 4f 00 	movsd  0x4f52(%rip),%xmm2        # 40dd70 <jtable.3055+0xfe0>
  408e1d:	00 
*/
accumtime=0L;
iterations=(double)0.0;

do {
	accumtime+=DoNumSortIteration(arraybase,
  408e1e:	49 01 c4             	add    %rax,%r12
		numsortstruct->arraysize,
		numsortstruct->numarrays);
	iterations+=(double)1.0;
} while(TicksToSecs(accumtime)<numsortstruct->request_secs);
  408e21:	4c 89 e7             	mov    %r12,%rdi

do {
	accumtime+=DoNumSortIteration(arraybase,
		numsortstruct->arraysize,
		numsortstruct->numarrays);
	iterations+=(double)1.0;
  408e24:	f2 0f 58 54 24 08    	addsd  0x8(%rsp),%xmm2
  408e2a:	f2 0f 11 54 24 08    	movsd  %xmm2,0x8(%rsp)
} while(TicksToSecs(accumtime)<numsortstruct->request_secs);
  408e30:	e8 9b 33 00 00       	callq  40c1d0 <TicksToSecs>
  408e35:	48 3b 05 0c 7f 20 00 	cmp    0x207f0c(%rip),%rax        # 610d48 <global_numsortstruct+0x8>
  408e3c:	72 c2                	jb     408e00 <DoNumSort+0x130>

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);
  408e3e:	48 89 ee             	mov    %rbp,%rsi
  408e41:	48 89 df             	mov    %rbx,%rdi
  408e44:	e8 e7 2f 00 00       	callq  40be30 <FreeMemory>

numsortstruct->sortspersec=iterations *
  408e49:	0f b7 05 08 7f 20 00 	movzwl 0x207f08(%rip),%eax        # 610d58 <global_numsortstruct+0x18>
  408e50:	66 0f ef c9          	pxor   %xmm1,%xmm1
	(double)numsortstruct->numarrays / TicksToFracSecs(accumtime);
  408e54:	4c 89 e7             	mov    %r12,%rdi
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

numsortstruct->sortspersec=iterations *
  408e57:	f2 0f 2a c8          	cvtsi2sd %eax,%xmm1
  408e5b:	f2 0f 59 4c 24 08    	mulsd  0x8(%rsp),%xmm1
  408e61:	f2 0f 11 4c 24 08    	movsd  %xmm1,0x8(%rsp)
	(double)numsortstruct->numarrays / TicksToFracSecs(accumtime);
  408e67:	e8 84 33 00 00       	callq  40c1f0 <TicksToFracSecs>
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

numsortstruct->sortspersec=iterations *
  408e6c:	f2 0f 10 4c 24 08    	movsd  0x8(%rsp),%xmm1
	(double)numsortstruct->numarrays / TicksToFracSecs(accumtime);

if(numsortstruct->adjust==0)
  408e72:	8b 15 c8 7e 20 00    	mov    0x207ec8(%rip),%edx        # 610d40 <global_numsortstruct>
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

numsortstruct->sortspersec=iterations *
  408e78:	f2 0f 5e c8          	divsd  %xmm0,%xmm1
	(double)numsortstruct->numarrays / TicksToFracSecs(accumtime);

if(numsortstruct->adjust==0)
  408e7c:	85 d2                	test   %edx,%edx
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

numsortstruct->sortspersec=iterations *
  408e7e:	f2 0f 11 0d ca 7e 20 	movsd  %xmm1,0x207eca(%rip)        # 610d50 <global_numsortstruct+0x10>
  408e85:	00 
	(double)numsortstruct->numarrays / TicksToFracSecs(accumtime);

if(numsortstruct->adjust==0)
  408e86:	75 0a                	jne    408e92 <DoNumSort+0x1c2>
	numsortstruct->adjust=1;
  408e88:	c7 05 ae 7e 20 00 01 	movl   $0x1,0x207eae(%rip)        # 610d40 <global_numsortstruct>
  408e8f:	00 00 00 

#ifdef DEBUG
if (numsort_status==0) printf("Numeric sort: OK\n");
  408e92:	8b 05 14 78 20 00    	mov    0x207814(%rip),%eax        # 6106ac <numsort_status>
  408e98:	85 c0                	test   %eax,%eax
  408e9a:	75 0a                	jne    408ea6 <DoNumSort+0x1d6>
  408e9c:	bf 84 de 40 00       	mov    $0x40de84,%edi
  408ea1:	e8 ea 7f ff ff       	callq  400e90 <puts@plt>
numsort_status=0;
#endif
return;
}
  408ea6:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  408eab:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  408eb2:	00 00 
if(numsortstruct->adjust==0)
	numsortstruct->adjust=1;

#ifdef DEBUG
if (numsort_status==0) printf("Numeric sort: OK\n");
numsort_status=0;
  408eb4:	c7 05 ee 77 20 00 00 	movl   $0x0,0x2077ee(%rip)        # 6106ac <numsort_status>
  408ebb:	00 00 00 
#endif
return;
}
  408ebe:	75 2d                	jne    408eed <DoNumSort+0x21d>
  408ec0:	48 83 c4 20          	add    $0x20,%rsp
  408ec4:	5b                   	pop    %rbx
  408ec5:	5d                   	pop    %rbp
  408ec6:	41 5c                	pop    %r12
  408ec8:	c3                   	retq   
  408ec9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  408ed0:	bf b0 e0 40 00       	mov    $0x40e0b0,%edi
  408ed5:	e8 b6 7f ff ff       	callq  400e90 <puts@plt>
			break;          /* We're ok...exit */

		FreeMemory((farvoid *)arraybase,&systemerror);
		if(numsortstruct->numarrays++>NUMNUMARRAYS)
		{       printf("CPU:NSORT -- NUMNUMARRAYS hit.\n");
			ErrorExit();
  408eda:	31 c0                	xor    %eax,%eax
  408edc:	e8 bf 32 00 00       	callq  40c1a0 <ErrorExit>
  408ee1:	0f b7 3d 70 7e 20 00 	movzwl 0x207e70(%rip),%edi        # 610d58 <global_numsortstruct+0x18>
  408ee8:	e9 6c fe ff ff       	jmpq   408d59 <DoNumSort+0x89>
#ifdef DEBUG
if (numsort_status==0) printf("Numeric sort: OK\n");
numsort_status=0;
#endif
return;
}
  408eed:	e8 0e 80 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  408ef2:	0f 1f 40 00          	nopl   0x0(%rax)
  408ef6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  408efd:	00 00 00 

0000000000408f00 <DoStringSort>:
** Arguments:
**      requested_secs = # of seconds to execute test
**      stringspersec = # of strings per second sorted (RETURNED)
*/
void DoStringSort(void)
{
  408f00:	41 54                	push   %r12
  408f02:	55                   	push   %rbp
  408f03:	53                   	push   %rbx
  408f04:	48 83 ec 20          	sub    $0x20,%rsp
errorcontext="CPU:String Sort";

/*
** See if we have to perform self-adjustment code
*/
if(strsortstruct->adjust==0)
  408f08:	8b 35 12 79 20 00    	mov    0x207912(%rip),%esi        # 610820 <global_strsortstruct>
** Arguments:
**      requested_secs = # of seconds to execute test
**      stringspersec = # of strings per second sorted (RETURNED)
*/
void DoStringSort(void)
{
  408f0e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  408f15:	00 00 
  408f17:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  408f1c:	31 c0                	xor    %eax,%eax
errorcontext="CPU:String Sort";

/*
** See if we have to perform self-adjustment code
*/
if(strsortstruct->adjust==0)
  408f1e:	85 f6                	test   %esi,%esi
  408f20:	0f 85 9a 00 00 00    	jne    408fc0 <DoStringSort+0xc0>
{
	/*
	** Initialize the number of arrays.
	*/
	strsortstruct->numarrays=1;
  408f26:	b9 01 00 00 00       	mov    $0x1,%ecx
  408f2b:	b8 01 00 00 00       	mov    $0x1,%eax
  408f30:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
  408f35:	66 89 0d fc 78 20 00 	mov    %cx,0x2078fc(%rip)        # 610838 <global_strsortstruct+0x18>
  408f3c:	eb 41                	jmp    408f7f <DoStringSort+0x7f>
  408f3e:	66 90                	xchg   %ax,%ax
		** Do an iteration of the string sort.  If the
		** elapsed time is less than or equal to the permitted
		** minimum, then de-allocate the array, reallocate a
		** an additional array, and try again.
		*/
		if(DoStringSortIteration(arraybase,
  408f40:	0f b7 35 f1 78 20 00 	movzwl 0x2078f1(%rip),%esi        # 610838 <global_strsortstruct+0x18>
  408f47:	48 8b 15 f2 78 20 00 	mov    0x2078f2(%rip),%rdx        # 610840 <global_strsortstruct+0x20>
  408f4e:	48 89 df             	mov    %rbx,%rdi
  408f51:	e8 6a f1 ff ff       	callq  4080c0 <DoStringSortIteration>
  408f56:	48 3b 05 63 77 20 00 	cmp    0x207763(%rip),%rax        # 6106c0 <global_min_ticks>
  408f5d:	0f 87 9d 00 00 00    	ja     409000 <DoStringSort+0x100>
			strsortstruct->numarrays,
			strsortstruct->arraysize)>global_min_ticks)
			break;          /* We're ok...exit */

		FreeMemory((farvoid *)arraybase,&systemerror);
  408f63:	48 89 ee             	mov    %rbp,%rsi
  408f66:	48 89 df             	mov    %rbx,%rdi
  408f69:	e8 c2 2e 00 00       	callq  40be30 <FreeMemory>
		strsortstruct->numarrays+=1;
  408f6e:	0f b7 05 c3 78 20 00 	movzwl 0x2078c3(%rip),%eax        # 610838 <global_strsortstruct+0x18>
  408f75:	83 c0 01             	add    $0x1,%eax
  408f78:	66 89 05 b9 78 20 00 	mov    %ax,0x2078b9(%rip)        # 610838 <global_strsortstruct+0x18>
		/*
		** Allocate space for array.  We'll add an extra 100
		** bytes to protect memory as strings move around
		** (this can happen during string adjustment)
		*/
		arraybase=(faruchar *)AllocateMemory((strsortstruct->arraysize+100L) *
  408f7f:	48 8b 0d ba 78 20 00 	mov    0x2078ba(%rip),%rcx        # 610840 <global_strsortstruct+0x20>
  408f86:	0f b7 c0             	movzwl %ax,%eax
  408f89:	48 89 ee             	mov    %rbp,%rsi
  408f8c:	48 8d 79 64          	lea    0x64(%rcx),%rdi
  408f90:	48 0f af f8          	imul   %rax,%rdi
  408f94:	e8 97 2d 00 00       	callq  40bd30 <AllocateMemory>
			(long)strsortstruct->numarrays,&systemerror);
		if(systemerror)
  408f99:	8b 74 24 14          	mov    0x14(%rsp),%esi
		/*
		** Allocate space for array.  We'll add an extra 100
		** bytes to protect memory as strings move around
		** (this can happen during string adjustment)
		*/
		arraybase=(faruchar *)AllocateMemory((strsortstruct->arraysize+100L) *
  408f9d:	48 89 c3             	mov    %rax,%rbx
			(long)strsortstruct->numarrays,&systemerror);
		if(systemerror)
  408fa0:	85 f6                	test   %esi,%esi
  408fa2:	74 9c                	je     408f40 <DoStringSort+0x40>
		{       ReportError(errorcontext,systemerror);
  408fa4:	bf 95 de 40 00       	mov    $0x40de95,%edi
  408fa9:	e8 c2 31 00 00       	callq  40c170 <ReportError>
			ErrorExit();
  408fae:	31 c0                	xor    %eax,%eax
  408fb0:	e8 eb 31 00 00       	callq  40c1a0 <ErrorExit>
  408fb5:	eb 89                	jmp    408f40 <DoStringSort+0x40>
  408fb7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  408fbe:	00 00 
{
	/*
	** We don't have to perform self adjustment code.
	** Simply allocate the space for the array.
	*/
	arraybase=(faruchar *)AllocateMemory((strsortstruct->arraysize+100L) *
  408fc0:	48 8b 05 79 78 20 00 	mov    0x207879(%rip),%rax        # 610840 <global_strsortstruct+0x20>
  408fc7:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
  408fcc:	48 89 ee             	mov    %rbp,%rsi
  408fcf:	48 8d 78 64          	lea    0x64(%rax),%rdi
  408fd3:	0f b7 05 5e 78 20 00 	movzwl 0x20785e(%rip),%eax        # 610838 <global_strsortstruct+0x18>
  408fda:	48 0f af f8          	imul   %rax,%rdi
  408fde:	e8 4d 2d 00 00       	callq  40bd30 <AllocateMemory>
		(long)strsortstruct->numarrays,&systemerror);
	if(systemerror)
  408fe3:	8b 74 24 14          	mov    0x14(%rsp),%esi
{
	/*
	** We don't have to perform self adjustment code.
	** Simply allocate the space for the array.
	*/
	arraybase=(faruchar *)AllocateMemory((strsortstruct->arraysize+100L) *
  408fe7:	48 89 c3             	mov    %rax,%rbx
		(long)strsortstruct->numarrays,&systemerror);
	if(systemerror)
  408fea:	85 f6                	test   %esi,%esi
  408fec:	74 12                	je     409000 <DoStringSort+0x100>
	{       ReportError(errorcontext,systemerror);
  408fee:	bf 95 de 40 00       	mov    $0x40de95,%edi
  408ff3:	e8 78 31 00 00       	callq  40c170 <ReportError>
		ErrorExit();
  408ff8:	31 c0                	xor    %eax,%eax
  408ffa:	e8 a1 31 00 00       	callq  40c1a0 <ErrorExit>
  408fff:	90                   	nop
/*
** All's well if we get here.  Repeatedly perform sorts until the
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
iterations=(double)0.0;
  409000:	66 0f ef db          	pxor   %xmm3,%xmm3
}
/*
** All's well if we get here.  Repeatedly perform sorts until the
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
  409004:	45 31 e4             	xor    %r12d,%r12d
iterations=(double)0.0;
  409007:	f2 0f 11 5c 24 08    	movsd  %xmm3,0x8(%rsp)
  40900d:	0f 1f 00             	nopl   (%rax)

do {
	accumtime+=DoStringSortIteration(arraybase,
  409010:	0f b7 35 21 78 20 00 	movzwl 0x207821(%rip),%esi        # 610838 <global_strsortstruct+0x18>
  409017:	48 8b 15 22 78 20 00 	mov    0x207822(%rip),%rdx        # 610840 <global_strsortstruct+0x20>
  40901e:	48 89 df             	mov    %rbx,%rdi
  409021:	e8 9a f0 ff ff       	callq  4080c0 <DoStringSortIteration>
  409026:	49 01 c4             	add    %rax,%r12
				strsortstruct->numarrays,
				strsortstruct->arraysize);
	iterations+=(double)strsortstruct->numarrays;
  409029:	0f b7 05 08 78 20 00 	movzwl 0x207808(%rip),%eax        # 610838 <global_strsortstruct+0x18>
  409030:	66 0f ef c0          	pxor   %xmm0,%xmm0
} while(TicksToSecs(accumtime)<strsortstruct->request_secs);
  409034:	4c 89 e7             	mov    %r12,%rdi

do {
	accumtime+=DoStringSortIteration(arraybase,
				strsortstruct->numarrays,
				strsortstruct->arraysize);
	iterations+=(double)strsortstruct->numarrays;
  409037:	f2 0f 2a c0          	cvtsi2sd %eax,%xmm0
  40903b:	f2 0f 58 44 24 08    	addsd  0x8(%rsp),%xmm0
  409041:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
} while(TicksToSecs(accumtime)<strsortstruct->request_secs);
  409047:	e8 84 31 00 00       	callq  40c1d0 <TicksToSecs>
  40904c:	48 3b 05 d5 77 20 00 	cmp    0x2077d5(%rip),%rax        # 610828 <global_strsortstruct+0x8>
  409053:	72 bb                	jb     409010 <DoStringSort+0x110>

/*
** Clean up, calculate results, and go home.
** Set flag to show we don't need to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);
  409055:	48 89 ee             	mov    %rbp,%rsi
  409058:	48 89 df             	mov    %rbx,%rdi
  40905b:	e8 d0 2d 00 00       	callq  40be30 <FreeMemory>
strsortstruct->sortspersec=iterations / (double)TicksToFracSecs(accumtime);
  409060:	4c 89 e7             	mov    %r12,%rdi
  409063:	e8 88 31 00 00       	callq  40c1f0 <TicksToFracSecs>
  409068:	f2 0f 10 54 24 08    	movsd  0x8(%rsp),%xmm2
if(strsortstruct->adjust==0)
  40906e:	8b 15 ac 77 20 00    	mov    0x2077ac(%rip),%edx        # 610820 <global_strsortstruct>
/*
** Clean up, calculate results, and go home.
** Set flag to show we don't need to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);
strsortstruct->sortspersec=iterations / (double)TicksToFracSecs(accumtime);
  409074:	f2 0f 5e d0          	divsd  %xmm0,%xmm2
if(strsortstruct->adjust==0)
  409078:	85 d2                	test   %edx,%edx
/*
** Clean up, calculate results, and go home.
** Set flag to show we don't need to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);
strsortstruct->sortspersec=iterations / (double)TicksToFracSecs(accumtime);
  40907a:	f2 0f 11 15 ae 77 20 	movsd  %xmm2,0x2077ae(%rip)        # 610830 <global_strsortstruct+0x10>
  409081:	00 
if(strsortstruct->adjust==0)
  409082:	75 0a                	jne    40908e <DoStringSort+0x18e>
	strsortstruct->adjust=1;
  409084:	c7 05 92 77 20 00 01 	movl   $0x1,0x207792(%rip)        # 610820 <global_strsortstruct>
  40908b:	00 00 00 
#ifdef DEBUG
if (stringsort_status==0) printf("String sort: OK\n");
  40908e:	8b 05 14 76 20 00    	mov    0x207614(%rip),%eax        # 6106a8 <stringsort_status>
  409094:	85 c0                	test   %eax,%eax
  409096:	75 0a                	jne    4090a2 <DoStringSort+0x1a2>
  409098:	bf a5 de 40 00       	mov    $0x40dea5,%edi
  40909d:	e8 ee 7d ff ff       	callq  400e90 <puts@plt>
stringsort_status=0;
#endif
return;
}
  4090a2:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4090a7:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4090ae:	00 00 
strsortstruct->sortspersec=iterations / (double)TicksToFracSecs(accumtime);
if(strsortstruct->adjust==0)
	strsortstruct->adjust=1;
#ifdef DEBUG
if (stringsort_status==0) printf("String sort: OK\n");
stringsort_status=0;
  4090b0:	c7 05 ee 75 20 00 00 	movl   $0x0,0x2075ee(%rip)        # 6106a8 <stringsort_status>
  4090b7:	00 00 00 
#endif
return;
}
  4090ba:	75 09                	jne    4090c5 <DoStringSort+0x1c5>
  4090bc:	48 83 c4 20          	add    $0x20,%rsp
  4090c0:	5b                   	pop    %rbx
  4090c1:	5d                   	pop    %rbp
  4090c2:	41 5c                	pop    %r12
  4090c4:	c3                   	retq   
  4090c5:	e8 36 7e ff ff       	callq  400f00 <__stack_chk_fail@plt>
  4090ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004090d0 <DoBitops>:
**************
** Perform the bit operations test portion of the CPU
** benchmark.  Returns the iterations per second.
*/
void DoBitops(void)
{
  4090d0:	41 57                	push   %r15
  4090d2:	41 56                	push   %r14
  4090d4:	41 55                	push   %r13
  4090d6:	41 54                	push   %r12
  4090d8:	55                   	push   %rbp
  4090d9:	53                   	push   %rbx
  4090da:	48 83 ec 38          	sub    $0x38,%rsp
errorcontext="CPU:Bitfields";

/*
** See if we need to run adjustment code.
*/
if(locbitopstruct->adjust==0)
  4090de:	8b 15 fc 76 20 00    	mov    0x2076fc(%rip),%edx        # 6107e0 <global_bitopstruct>
**************
** Perform the bit operations test portion of the CPU
** benchmark.  Returns the iterations per second.
*/
void DoBitops(void)
{
  4090e4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4090eb:	00 00 
  4090ed:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  4090f2:	31 c0                	xor    %eax,%eax
/*
** See if we need to run adjustment code.
*/
if(locbitopstruct->adjust==0)
{
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
  4090f4:	48 8b 05 05 77 20 00 	mov    0x207705(%rip),%rax        # 610800 <global_bitopstruct+0x20>
  4090fb:	4c 8d 74 24 1c       	lea    0x1c(%rsp),%r14
errorcontext="CPU:Bitfields";

/*
** See if we need to run adjustment code.
*/
if(locbitopstruct->adjust==0)
  409100:	85 d2                	test   %edx,%edx
{
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
  409102:	4c 89 f6             	mov    %r14,%rsi
  409105:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
  40910c:	00 
errorcontext="CPU:Bitfields";

/*
** See if we need to run adjustment code.
*/
if(locbitopstruct->adjust==0)
  40910d:	0f 85 bd 00 00 00    	jne    4091d0 <DoBitops+0x100>
{
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
  409113:	e8 18 2c 00 00       	callq  40bd30 <AllocateMemory>
		sizeof(ulong),&systemerror);
	if(systemerror)
  409118:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
/*
** See if we need to run adjustment code.
*/
if(locbitopstruct->adjust==0)
{
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
  40911c:	48 89 c3             	mov    %rax,%rbx
		sizeof(ulong),&systemerror);
	if(systemerror)
  40911f:	85 f6                	test   %esi,%esi
  409121:	0f 85 b9 02 00 00    	jne    4093e0 <DoBitops+0x310>
	}

	/*
	** Initialize bitfield operations array to [2,30] elements
	*/
	locbitopstruct->bitoparraysize=30L;
  409127:	48 c7 05 c6 76 20 00 	movq   $0x1e,0x2076c6(%rip)        # 6107f8 <global_bitopstruct+0x18>
  40912e:	1e 00 00 00 
  409132:	bf 1e 00 00 00       	mov    $0x1e,%edi
  409137:	4c 8d 6c 24 20       	lea    0x20(%rsp),%r13
  40913c:	eb 59                	jmp    409197 <DoBitops+0xc7>
  40913e:	66 90                	xchg   %ax,%ax
		** Do an iteration of the bitmap test.  If the
		** elapsed time is less than or equal to the permitted
		** minimum, then de-allocate the array, reallocate a
		** larger version, and try again.
		*/
		ticks=DoBitfieldIteration(bitarraybase,
  409140:	48 8b 15 b1 76 20 00 	mov    0x2076b1(%rip),%rdx        # 6107f8 <global_bitopstruct+0x18>
  409147:	4c 89 e9             	mov    %r13,%rcx
  40914a:	4c 89 e6             	mov    %r12,%rsi
  40914d:	48 89 df             	mov    %rbx,%rdi
  409150:	e8 8b c1 ff ff       	callq  4052e0 <DoBitfieldIteration>
					   bitoparraybase,
					   locbitopstruct->bitoparraysize,
					   &nbitops);
#ifdef DEBUG
#ifdef LINUX
	        if (locbitopstruct->bitoparraysize==30L){
  409155:	48 83 3d 9b 76 20 00 	cmpq   $0x1e,0x20769b(%rip)        # 6107f8 <global_bitopstruct+0x18>
  40915c:	1e 
		** Do an iteration of the bitmap test.  If the
		** elapsed time is less than or equal to the permitted
		** minimum, then de-allocate the array, reallocate a
		** larger version, and try again.
		*/
		ticks=DoBitfieldIteration(bitarraybase,
  40915d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
					   bitoparraybase,
					   locbitopstruct->bitoparraysize,
					   &nbitops);
#ifdef DEBUG
#ifdef LINUX
	        if (locbitopstruct->bitoparraysize==30L){
  409162:	0f 84 a8 01 00 00    	je     409310 <DoBitops+0x240>
		  printf("\nWrote the file debugbit.dat, you may want to compare it to debugbit.good\n");
		}
#endif
#endif

		if (ticks>global_min_ticks) break;      /* We're ok...exit */
  409168:	48 63 6c 24 08       	movslq 0x8(%rsp),%rbp
  40916d:	48 3b 2d 4c 75 20 00 	cmp    0x20754c(%rip),%rbp        # 6106c0 <global_min_ticks>
  409174:	0f 87 b6 00 00 00    	ja     409230 <DoBitops+0x160>

		FreeMemory((farvoid *)bitoparraybase,&systemerror);
  40917a:	4c 89 e7             	mov    %r12,%rdi
  40917d:	4c 89 f6             	mov    %r14,%rsi
  409180:	e8 ab 2c 00 00       	callq  40be30 <FreeMemory>
		locbitopstruct->bitoparraysize+=100L;
  409185:	48 8b 05 6c 76 20 00 	mov    0x20766c(%rip),%rax        # 6107f8 <global_bitopstruct+0x18>
  40918c:	48 8d 78 64          	lea    0x64(%rax),%rdi
  409190:	48 89 3d 61 76 20 00 	mov    %rdi,0x207661(%rip)        # 6107f8 <global_bitopstruct+0x18>
	while(1)
	{
		/*
		** Allocate space for operations array
		*/
		bitoparraybase=(farulong *)AllocateMemory(locbitopstruct->bitoparraysize*2L*
  409197:	48 c1 e7 04          	shl    $0x4,%rdi
  40919b:	4c 89 f6             	mov    %r14,%rsi
  40919e:	e8 8d 2b 00 00       	callq  40bd30 <AllocateMemory>
			sizeof(ulong),
			&systemerror);
		if(systemerror)
  4091a3:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
	while(1)
	{
		/*
		** Allocate space for operations array
		*/
		bitoparraybase=(farulong *)AllocateMemory(locbitopstruct->bitoparraysize*2L*
  4091a7:	49 89 c4             	mov    %rax,%r12
			sizeof(ulong),
			&systemerror);
		if(systemerror)
  4091aa:	85 f6                	test   %esi,%esi
  4091ac:	74 92                	je     409140 <DoBitops+0x70>
		{       ReportError(errorcontext,systemerror);
  4091ae:	bf b5 de 40 00       	mov    $0x40deb5,%edi
  4091b3:	e8 b8 2f 00 00       	callq  40c170 <ReportError>
			FreeMemory((farvoid *)bitarraybase,&systemerror);
  4091b8:	4c 89 f6             	mov    %r14,%rsi
  4091bb:	48 89 df             	mov    %rbx,%rdi
  4091be:	e8 6d 2c 00 00       	callq  40be30 <FreeMemory>
			ErrorExit();
  4091c3:	31 c0                	xor    %eax,%eax
  4091c5:	e8 d6 2f 00 00       	callq  40c1a0 <ErrorExit>
  4091ca:	e9 71 ff ff ff       	jmpq   409140 <DoBitops+0x70>
  4091cf:	90                   	nop
{
	/*
	** Don't need to do self adjustment, just allocate
	** the array space.
	*/
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
  4091d0:	e8 5b 2b 00 00       	callq  40bd30 <AllocateMemory>
		sizeof(ulong),&systemerror);
	if(systemerror)
  4091d5:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
{
	/*
	** Don't need to do self adjustment, just allocate
	** the array space.
	*/
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
  4091d9:	48 89 c3             	mov    %rax,%rbx
		sizeof(ulong),&systemerror);
	if(systemerror)
  4091dc:	85 f6                	test   %esi,%esi
  4091de:	74 11                	je     4091f1 <DoBitops+0x121>
	{       ReportError(errorcontext,systemerror);
  4091e0:	bf b5 de 40 00       	mov    $0x40deb5,%edi
  4091e5:	e8 86 2f 00 00       	callq  40c170 <ReportError>
		ErrorExit();
  4091ea:	31 c0                	xor    %eax,%eax
  4091ec:	e8 af 2f 00 00       	callq  40c1a0 <ErrorExit>
	}
	bitoparraybase=(farulong *)AllocateMemory(locbitopstruct->bitoparraysize*2L*
  4091f1:	48 8b 3d 00 76 20 00 	mov    0x207600(%rip),%rdi        # 6107f8 <global_bitopstruct+0x18>
  4091f8:	4c 89 f6             	mov    %r14,%rsi
  4091fb:	4c 8d 6c 24 20       	lea    0x20(%rsp),%r13
  409200:	48 c1 e7 04          	shl    $0x4,%rdi
  409204:	e8 27 2b 00 00       	callq  40bd30 <AllocateMemory>
		sizeof(ulong),
		&systemerror);
	if(systemerror)
  409209:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
		sizeof(ulong),&systemerror);
	if(systemerror)
	{       ReportError(errorcontext,systemerror);
		ErrorExit();
	}
	bitoparraybase=(farulong *)AllocateMemory(locbitopstruct->bitoparraysize*2L*
  40920d:	49 89 c4             	mov    %rax,%r12
		sizeof(ulong),
		&systemerror);
	if(systemerror)
  409210:	85 f6                	test   %esi,%esi
  409212:	74 1c                	je     409230 <DoBitops+0x160>
	{       ReportError(errorcontext,systemerror);
  409214:	bf b5 de 40 00       	mov    $0x40deb5,%edi
  409219:	e8 52 2f 00 00       	callq  40c170 <ReportError>
		FreeMemory((farvoid *)bitarraybase,&systemerror);
  40921e:	4c 89 f6             	mov    %r14,%rsi
  409221:	48 89 df             	mov    %rbx,%rdi
  409224:	e8 07 2c 00 00       	callq  40be30 <FreeMemory>
		ErrorExit();
  409229:	31 c0                	xor    %eax,%eax
  40922b:	e8 70 2f 00 00       	callq  40c1a0 <ErrorExit>
/*
** All's well if we get here.  Repeatedly perform bitops until the
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
iterations=(double)0.0;
  409230:	66 0f ef db          	pxor   %xmm3,%xmm3

/*
** All's well if we get here.  Repeatedly perform bitops until the
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
  409234:	31 ed                	xor    %ebp,%ebp
iterations=(double)0.0;
  409236:	f2 0f 11 5c 24 08    	movsd  %xmm3,0x8(%rsp)
  40923c:	eb 28                	jmp    409266 <DoBitops+0x196>
  40923e:	66 90                	xchg   %ax,%ax
do {
	accumtime+=DoBitfieldIteration(bitarraybase,
			bitoparraybase,
			locbitopstruct->bitoparraysize,&nbitops);
	iterations+=(double)nbitops;
  409240:	66 0f ef c0          	pxor   %xmm0,%xmm0
  409244:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  409249:	f2 0f 58 44 24 08    	addsd  0x8(%rsp),%xmm0
} while(TicksToSecs(accumtime)<locbitopstruct->request_secs);
  40924f:	48 89 ef             	mov    %rbp,%rdi
iterations=(double)0.0;
do {
	accumtime+=DoBitfieldIteration(bitarraybase,
			bitoparraybase,
			locbitopstruct->bitoparraysize,&nbitops);
	iterations+=(double)nbitops;
  409252:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
} while(TicksToSecs(accumtime)<locbitopstruct->request_secs);
  409258:	e8 73 2f 00 00       	callq  40c1d0 <TicksToSecs>
  40925d:	48 3b 05 84 75 20 00 	cmp    0x207584(%rip),%rax        # 6107e8 <global_bitopstruct+0x8>
  409264:	73 42                	jae    4092a8 <DoBitops+0x1d8>
** accumulated elapsed time is greater than # of seconds requested.
*/
accumtime=0L;
iterations=(double)0.0;
do {
	accumtime+=DoBitfieldIteration(bitarraybase,
  409266:	48 8b 15 8b 75 20 00 	mov    0x20758b(%rip),%rdx        # 6107f8 <global_bitopstruct+0x18>
  40926d:	4c 89 e9             	mov    %r13,%rcx
  409270:	4c 89 e6             	mov    %r12,%rsi
  409273:	48 89 df             	mov    %rbx,%rdi
  409276:	e8 65 c0 ff ff       	callq  4052e0 <DoBitfieldIteration>
  40927b:	48 01 c5             	add    %rax,%rbp
			bitoparraybase,
			locbitopstruct->bitoparraysize,&nbitops);
	iterations+=(double)nbitops;
  40927e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  409283:	48 85 c0             	test   %rax,%rax
  409286:	79 b8                	jns    409240 <DoBitops+0x170>
  409288:	48 89 c2             	mov    %rax,%rdx
  40928b:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40928f:	48 d1 ea             	shr    %rdx
  409292:	83 e0 01             	and    $0x1,%eax
  409295:	48 09 c2             	or     %rax,%rdx
  409298:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  40929d:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  4092a1:	eb a6                	jmp    409249 <DoBitops+0x179>
  4092a3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
/*
** Clean up, calculate results, and go home.
** Also, set adjustment flag to show that we don't have
** to do self adjusting in the future.
*/
FreeMemory((farvoid *)bitarraybase,&systemerror);
  4092a8:	4c 89 f6             	mov    %r14,%rsi
  4092ab:	48 89 df             	mov    %rbx,%rdi
  4092ae:	e8 7d 2b 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)bitoparraybase,&systemerror);
  4092b3:	4c 89 f6             	mov    %r14,%rsi
  4092b6:	4c 89 e7             	mov    %r12,%rdi
  4092b9:	e8 72 2b 00 00       	callq  40be30 <FreeMemory>
locbitopstruct->bitopspersec=iterations /TicksToFracSecs(accumtime);
  4092be:	48 89 ef             	mov    %rbp,%rdi
  4092c1:	e8 2a 2f 00 00       	callq  40c1f0 <TicksToFracSecs>
  4092c6:	f2 0f 10 54 24 08    	movsd  0x8(%rsp),%xmm2
if(locbitopstruct->adjust==0)
  4092cc:	8b 05 0e 75 20 00    	mov    0x20750e(%rip),%eax        # 6107e0 <global_bitopstruct>
** Also, set adjustment flag to show that we don't have
** to do self adjusting in the future.
*/
FreeMemory((farvoid *)bitarraybase,&systemerror);
FreeMemory((farvoid *)bitoparraybase,&systemerror);
locbitopstruct->bitopspersec=iterations /TicksToFracSecs(accumtime);
  4092d2:	f2 0f 5e d0          	divsd  %xmm0,%xmm2
if(locbitopstruct->adjust==0)
  4092d6:	85 c0                	test   %eax,%eax
** Also, set adjustment flag to show that we don't have
** to do self adjusting in the future.
*/
FreeMemory((farvoid *)bitarraybase,&systemerror);
FreeMemory((farvoid *)bitoparraybase,&systemerror);
locbitopstruct->bitopspersec=iterations /TicksToFracSecs(accumtime);
  4092d8:	f2 0f 11 15 10 75 20 	movsd  %xmm2,0x207510(%rip)        # 6107f0 <global_bitopstruct+0x10>
  4092df:	00 
if(locbitopstruct->adjust==0)
  4092e0:	75 0a                	jne    4092ec <DoBitops+0x21c>
	locbitopstruct->adjust=1;
  4092e2:	c7 05 f4 74 20 00 01 	movl   $0x1,0x2074f4(%rip)        # 6107e0 <global_bitopstruct>
  4092e9:	00 00 00 

return;
}
  4092ec:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  4092f1:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4092f8:	00 00 
  4092fa:	0f 85 f6 00 00 00    	jne    4093f6 <DoBitops+0x326>
  409300:	48 83 c4 38          	add    $0x38,%rsp
  409304:	5b                   	pop    %rbx
  409305:	5d                   	pop    %rbp
  409306:	41 5c                	pop    %r12
  409308:	41 5d                	pop    %r13
  40930a:	41 5e                	pop    %r14
  40930c:	41 5f                	pop    %r15
  40930e:	c3                   	retq   
  40930f:	90                   	nop
	        if (locbitopstruct->bitoparraysize==30L){
		  /* this is the first loop, write a debug file */
		  FILE *file;
		  unsigned long *running_base; /* same as farulong */
		  long counter;
		  file=fopen("debugbit.dat","w");
  409310:	be 9e e0 40 00       	mov    $0x40e09e,%esi
  409315:	bf c3 de 40 00       	mov    $0x40dec3,%edi
  40931a:	e8 21 7d ff ff       	callq  401040 <fopen@plt>
		  running_base=bitarraybase;
		  for (counter=0;counter<(long)(locbitopstruct->bitfieldarraysize);counter++){
  40931f:	48 83 3d d9 74 20 00 	cmpq   $0x0,0x2074d9(%rip)        # 610800 <global_bitopstruct+0x20>
  409326:	00 
	        if (locbitopstruct->bitoparraysize==30L){
		  /* this is the first loop, write a debug file */
		  FILE *file;
		  unsigned long *running_base; /* same as farulong */
		  long counter;
		  file=fopen("debugbit.dat","w");
  409327:	49 89 c7             	mov    %rax,%r15
		  running_base=bitarraybase;
		  for (counter=0;counter<(long)(locbitopstruct->bitfieldarraysize);counter++){
  40932a:	0f 8e 98 00 00 00    	jle    4093c8 <DoBitops+0x2f8>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  409330:	8b 0b                	mov    (%rbx),%ecx
  409332:	48 89 c7             	mov    %rax,%rdi
  409335:	ba d0 de 40 00       	mov    $0x40ded0,%edx
  40933a:	be 01 00 00 00       	mov    $0x1,%esi
  40933f:	31 c0                	xor    %eax,%eax
#ifdef LONG64
		    fprintf(file,"%08X",(unsigned int)(*running_base&0xFFFFFFFFL));
		    fprintf(file,"%08X",(unsigned int)((*running_base>>32)&0xFFFFFFFFL));
		    if ((counter+1)%4==0) fprintf(file,"\n");
  409341:	bd 01 00 00 00       	mov    $0x1,%ebp
  409346:	e8 35 7d ff ff       	callq  401080 <__fprintf_chk@plt>
  40934b:	48 8b 0b             	mov    (%rbx),%rcx
  40934e:	ba d0 de 40 00       	mov    $0x40ded0,%edx
  409353:	be 01 00 00 00       	mov    $0x1,%esi
  409358:	4c 89 ff             	mov    %r15,%rdi
  40935b:	31 c0                	xor    %eax,%eax
  40935d:	48 c1 e9 20          	shr    $0x20,%rcx
  409361:	e8 1a 7d ff ff       	callq  401080 <__fprintf_chk@plt>
  409366:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40936d:	00 00 00 
		  FILE *file;
		  unsigned long *running_base; /* same as farulong */
		  long counter;
		  file=fopen("debugbit.dat","w");
		  running_base=bitarraybase;
		  for (counter=0;counter<(long)(locbitopstruct->bitfieldarraysize);counter++){
  409370:	48 39 2d 89 74 20 00 	cmp    %rbp,0x207489(%rip)        # 610800 <global_bitopstruct+0x20>
  409377:	7e 4f                	jle    4093c8 <DoBitops+0x2f8>
  409379:	8b 0c eb             	mov    (%rbx,%rbp,8),%ecx
  40937c:	ba d0 de 40 00       	mov    $0x40ded0,%edx
  409381:	be 01 00 00 00       	mov    $0x1,%esi
  409386:	4c 89 ff             	mov    %r15,%rdi
  409389:	31 c0                	xor    %eax,%eax
  40938b:	e8 f0 7c ff ff       	callq  401080 <__fprintf_chk@plt>
  409390:	8b 4c eb 04          	mov    0x4(%rbx,%rbp,8),%ecx
  409394:	31 c0                	xor    %eax,%eax
  409396:	ba d0 de 40 00       	mov    $0x40ded0,%edx
  40939b:	be 01 00 00 00       	mov    $0x1,%esi
  4093a0:	4c 89 ff             	mov    %r15,%rdi
#ifdef LONG64
		    fprintf(file,"%08X",(unsigned int)(*running_base&0xFFFFFFFFL));
		    fprintf(file,"%08X",(unsigned int)((*running_base>>32)&0xFFFFFFFFL));
		    if ((counter+1)%4==0) fprintf(file,"\n");
  4093a3:	48 83 c5 01          	add    $0x1,%rbp
  4093a7:	e8 d4 7c ff ff       	callq  401080 <__fprintf_chk@plt>
  4093ac:	40 f6 c5 03          	test   $0x3,%bpl
  4093b0:	75 be                	jne    409370 <DoBitops+0x2a0>
  4093b2:	4c 89 fe             	mov    %r15,%rsi
  4093b5:	bf 0a 00 00 00       	mov    $0xa,%edi
  4093ba:	e8 c1 7b ff ff       	callq  400f80 <fputc@plt>
		  FILE *file;
		  unsigned long *running_base; /* same as farulong */
		  long counter;
		  file=fopen("debugbit.dat","w");
		  running_base=bitarraybase;
		  for (counter=0;counter<(long)(locbitopstruct->bitfieldarraysize);counter++){
  4093bf:	48 39 2d 3a 74 20 00 	cmp    %rbp,0x20743a(%rip)        # 610800 <global_bitopstruct+0x20>
  4093c6:	7f b1                	jg     409379 <DoBitops+0x2a9>
		    fprintf(file,"%08lX",*running_base);
		    if ((counter+1)%8==0) fprintf(file,"\n");
#endif
		    running_base=running_base+1;
		  }
		  fclose(file);
  4093c8:	4c 89 ff             	mov    %r15,%rdi
  4093cb:	e8 10 7b ff ff       	callq  400ee0 <fclose@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  4093d0:	bf d0 e0 40 00       	mov    $0x40e0d0,%edi
  4093d5:	e8 b6 7a ff ff       	callq  400e90 <puts@plt>
  4093da:	e9 89 fd ff ff       	jmpq   409168 <DoBitops+0x98>
  4093df:	90                   	nop
if(locbitopstruct->adjust==0)
{
	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
		sizeof(ulong),&systemerror);
	if(systemerror)
	{       ReportError(errorcontext,systemerror);
  4093e0:	bf b5 de 40 00       	mov    $0x40deb5,%edi
  4093e5:	e8 86 2d 00 00       	callq  40c170 <ReportError>
		ErrorExit();
  4093ea:	31 c0                	xor    %eax,%eax
  4093ec:	e8 af 2d 00 00       	callq  40c1a0 <ErrorExit>
  4093f1:	e9 31 fd ff ff       	jmpq   409127 <DoBitops+0x57>
locbitopstruct->bitopspersec=iterations /TicksToFracSecs(accumtime);
if(locbitopstruct->adjust==0)
	locbitopstruct->adjust=1;

return;
}
  4093f6:	e8 05 7b ff ff       	callq  400f00 <__stack_chk_fail@plt>
  4093fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000409400 <DoEmFloat>:
***************
** Perform the floating-point emulation routines portion of the
** CPU benchmark.  Returns the operations per second.
*/
void DoEmFloat(void)
{
  409400:	41 55                	push   %r13
  409402:	41 54                	push   %r12
  409404:	55                   	push   %rbp
  409405:	53                   	push   %rbx
  409406:	48 83 ec 28          	sub    $0x28,%rsp
  40940a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  409411:	00 00 
  409413:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  409418:	31 c0                	xor    %eax,%eax
** Test the emulation routines.
*/
#ifdef DEBUG
#endif

abase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
  40941a:	48 8b 05 ef 78 20 00 	mov    0x2078ef(%rip),%rax        # 610d10 <global_emfloatstruct+0x10>
  409421:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409426:	48 8d 3c 40          	lea    (%rax,%rax,2),%rdi
  40942a:	48 c1 e7 02          	shl    $0x2,%rdi
  40942e:	e8 fd 28 00 00       	callq  40bd30 <AllocateMemory>
		&systemerror);
if(systemerror)
  409433:	8b 74 24 14          	mov    0x14(%rsp),%esi
** Test the emulation routines.
*/
#ifdef DEBUG
#endif

abase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
  409437:	48 89 c5             	mov    %rax,%rbp
		&systemerror);
if(systemerror)
  40943a:	85 f6                	test   %esi,%esi
  40943c:	0f 85 76 02 00 00    	jne    4096b8 <DoEmFloat+0x2b8>
{       ReportError(errorcontext,systemerror);
	ErrorExit();
}

bbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
  409442:	48 8b 05 c7 78 20 00 	mov    0x2078c7(%rip),%rax        # 610d10 <global_emfloatstruct+0x10>
  409449:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  40944e:	48 8d 3c 40          	lea    (%rax,%rax,2),%rdi
  409452:	48 c1 e7 02          	shl    $0x2,%rdi
  409456:	e8 d5 28 00 00       	callq  40bd30 <AllocateMemory>
		&systemerror);
if(systemerror)
  40945b:	8b 74 24 14          	mov    0x14(%rsp),%esi
if(systemerror)
{       ReportError(errorcontext,systemerror);
	ErrorExit();
}

bbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
  40945f:	49 89 c4             	mov    %rax,%r12
		&systemerror);
if(systemerror)
  409462:	85 f6                	test   %esi,%esi
  409464:	0f 85 26 02 00 00    	jne    409690 <DoEmFloat+0x290>
{       ReportError(errorcontext,systemerror);
	FreeMemory((farvoid *)abase,&systemerror);
	ErrorExit();
}

cbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
  40946a:	48 8b 05 9f 78 20 00 	mov    0x20789f(%rip),%rax        # 610d10 <global_emfloatstruct+0x10>
  409471:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409476:	48 8d 3c 40          	lea    (%rax,%rax,2),%rdi
  40947a:	48 c1 e7 02          	shl    $0x2,%rdi
  40947e:	e8 ad 28 00 00       	callq  40bd30 <AllocateMemory>
		&systemerror);
if(systemerror)
  409483:	8b 74 24 14          	mov    0x14(%rsp),%esi
{       ReportError(errorcontext,systemerror);
	FreeMemory((farvoid *)abase,&systemerror);
	ErrorExit();
}

cbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
  409487:	49 89 c5             	mov    %rax,%r13
		&systemerror);
if(systemerror)
  40948a:	85 f6                	test   %esi,%esi
  40948c:	0f 85 c6 01 00 00    	jne    409658 <DoEmFloat+0x258>
}

/*
** Set up the arrays
*/
SetupCPUEmFloatArrays(abase,bbase,cbase,locemfloatstruct->arraysize);
  409492:	48 8b 0d 77 78 20 00 	mov    0x207877(%rip),%rcx        # 610d10 <global_emfloatstruct+0x10>
  409499:	4c 89 ea             	mov    %r13,%rdx
  40949c:	4c 89 e6             	mov    %r12,%rsi
  40949f:	48 89 ef             	mov    %rbp,%rdi
  4094a2:	e8 59 ab ff ff       	callq  404000 <SetupCPUEmFloatArrays>

/*
** See if we need to do self-adjusting code.
*/
if(locemfloatstruct->adjust==0)
  4094a7:	8b 15 53 78 20 00    	mov    0x207853(%rip),%edx        # 610d00 <global_emfloatstruct>
  4094ad:	85 d2                	test   %edx,%edx
  4094af:	75 48                	jne    4094f9 <DoEmFloat+0xf9>
{
	locemfloatstruct->loops=0;
  4094b1:	48 c7 05 5c 78 20 00 	movq   $0x0,0x20785c(%rip)        # 610d18 <global_emfloatstruct+0x18>
  4094b8:	00 00 00 00 
	/*
	** Do an iteration of the tests.  If the elapsed time is
	** less than minimum, increase the loop count and try
	** again.
	*/
	for(loops=1;loops<CPUEMFLOATLOOPMAX;loops+=loops)
  4094bc:	bb 01 00 00 00       	mov    $0x1,%ebx
  4094c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	{       tickcount=DoEmFloatIteration(abase,bbase,cbase,
  4094c8:	48 8b 0d 41 78 20 00 	mov    0x207841(%rip),%rcx        # 610d10 <global_emfloatstruct+0x10>
  4094cf:	49 89 d8             	mov    %rbx,%r8
  4094d2:	4c 89 ea             	mov    %r13,%rdx
  4094d5:	4c 89 e6             	mov    %r12,%rsi
  4094d8:	48 89 ef             	mov    %rbp,%rdi
  4094db:	e8 f0 ad ff ff       	callq  4042d0 <DoEmFloatIteration>
			locemfloatstruct->arraysize,
			loops);
		if(tickcount>global_min_ticks)
  4094e0:	48 3b 05 d9 71 20 00 	cmp    0x2071d9(%rip),%rax        # 6106c0 <global_min_ticks>
  4094e7:	0f 87 e3 01 00 00    	ja     4096d0 <DoEmFloat+0x2d0>
	/*
	** Do an iteration of the tests.  If the elapsed time is
	** less than minimum, increase the loop count and try
	** again.
	*/
	for(loops=1;loops<CPUEMFLOATLOOPMAX;loops+=loops)
  4094ed:	48 01 db             	add    %rbx,%rbx
  4094f0:	48 81 fb 1f a1 07 00 	cmp    $0x7a11f,%rbx
  4094f7:	76 cf                	jbe    4094c8 <DoEmFloat+0xc8>
  4094f9:	4c 8b 05 18 78 20 00 	mov    0x207818(%rip),%r8        # 610d18 <global_emfloatstruct+0x18>
}

/*
** Verify that selft adjustment code worked.
*/
if(locemfloatstruct->loops==0)
  409500:	4d 85 c0             	test   %r8,%r8
  409503:	0f 84 07 01 00 00    	je     409610 <DoEmFloat+0x210>
	for(loops=1;loops<CPUEMFLOATLOOPMAX;loops+=loops)
	{       tickcount=DoEmFloatIteration(abase,bbase,cbase,
			locemfloatstruct->arraysize,
			loops);
		if(tickcount>global_min_ticks)
		{       locemfloatstruct->loops=loops;
  409509:	66 0f ef e4          	pxor   %xmm4,%xmm4
  40950d:	31 db                	xor    %ebx,%ebx
  40950f:	f2 0f 11 64 24 08    	movsd  %xmm4,0x8(%rsp)
  409515:	eb 10                	jmp    409527 <DoEmFloat+0x127>
  409517:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40951e:	00 00 
  409520:	4c 8b 05 f1 77 20 00 	mov    0x2077f1(%rip),%r8        # 610d18 <global_emfloatstruct+0x18>
** Each iteration performs arraysize * 3 operations.
*/
accumtime=0L;
iterations=(double)0.0;
do {
	accumtime+=DoEmFloatIteration(abase,bbase,cbase,
  409527:	48 8b 0d e2 77 20 00 	mov    0x2077e2(%rip),%rcx        # 610d10 <global_emfloatstruct+0x10>
  40952e:	4c 89 ea             	mov    %r13,%rdx
  409531:	4c 89 e6             	mov    %r12,%rsi
  409534:	48 89 ef             	mov    %rbp,%rdi
  409537:	e8 94 ad ff ff       	callq  4042d0 <DoEmFloatIteration>
			locemfloatstruct->arraysize,
			locemfloatstruct->loops);
	iterations+=(double)1.0;
  40953c:	f2 0f 10 15 2c 48 00 	movsd  0x482c(%rip),%xmm2        # 40dd70 <jtable.3055+0xfe0>
  409543:	00 
** Each iteration performs arraysize * 3 operations.
*/
accumtime=0L;
iterations=(double)0.0;
do {
	accumtime+=DoEmFloatIteration(abase,bbase,cbase,
  409544:	48 01 c3             	add    %rax,%rbx
			locemfloatstruct->arraysize,
			locemfloatstruct->loops);
	iterations+=(double)1.0;
} while(TicksToSecs(accumtime)<locemfloatstruct->request_secs);
  409547:	48 89 df             	mov    %rbx,%rdi
iterations=(double)0.0;
do {
	accumtime+=DoEmFloatIteration(abase,bbase,cbase,
			locemfloatstruct->arraysize,
			locemfloatstruct->loops);
	iterations+=(double)1.0;
  40954a:	f2 0f 58 54 24 08    	addsd  0x8(%rsp),%xmm2
  409550:	f2 0f 11 54 24 08    	movsd  %xmm2,0x8(%rsp)
} while(TicksToSecs(accumtime)<locemfloatstruct->request_secs);
  409556:	e8 75 2c 00 00       	callq  40c1d0 <TicksToSecs>
  40955b:	48 3b 05 a6 77 20 00 	cmp    0x2077a6(%rip),%rax        # 610d08 <global_emfloatstruct+0x8>
  409562:	72 bc                	jb     409520 <DoEmFloat+0x120>

/*
** Clean up, calculate results, and go home.
** Also, indicate that adjustment is done.
*/
FreeMemory((farvoid *)abase,&systemerror);
  409564:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409569:	48 89 ef             	mov    %rbp,%rdi
  40956c:	e8 bf 28 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)bbase,&systemerror);
  409571:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409576:	4c 89 e7             	mov    %r12,%rdi
  409579:	e8 b2 28 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)cbase,&systemerror);
  40957e:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409583:	4c 89 ef             	mov    %r13,%rdi
  409586:	e8 a5 28 00 00       	callq  40be30 <FreeMemory>

locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
  40958b:	48 8b 05 86 77 20 00 	mov    0x207786(%rip),%rax        # 610d18 <global_emfloatstruct+0x18>
  409592:	48 85 c0             	test   %rax,%rax
  409595:	0f 88 45 01 00 00    	js     4096e0 <DoEmFloat+0x2e0>
  40959b:	66 0f ef c9          	pxor   %xmm1,%xmm1
  40959f:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
  4095a4:	f2 0f 59 4c 24 08    	mulsd  0x8(%rsp),%xmm1
		(double)TicksToFracSecs(accumtime);
  4095aa:	48 89 df             	mov    %rbx,%rdi
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);
FreeMemory((farvoid *)cbase,&systemerror);

locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
  4095ad:	f2 0f 11 4c 24 08    	movsd  %xmm1,0x8(%rsp)
		(double)TicksToFracSecs(accumtime);
  4095b3:	e8 38 2c 00 00       	callq  40c1f0 <TicksToFracSecs>
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);
FreeMemory((farvoid *)cbase,&systemerror);

locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
  4095b8:	f2 0f 10 4c 24 08    	movsd  0x8(%rsp),%xmm1
		(double)TicksToFracSecs(accumtime);
if(locemfloatstruct->adjust==0)
  4095be:	8b 05 3c 77 20 00    	mov    0x20773c(%rip),%eax        # 610d00 <global_emfloatstruct>
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);
FreeMemory((farvoid *)cbase,&systemerror);

locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
  4095c4:	f2 0f 5e c8          	divsd  %xmm0,%xmm1
		(double)TicksToFracSecs(accumtime);
if(locemfloatstruct->adjust==0)
  4095c8:	85 c0                	test   %eax,%eax
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);
FreeMemory((farvoid *)cbase,&systemerror);

locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
  4095ca:	f2 0f 11 0d 4e 77 20 	movsd  %xmm1,0x20774e(%rip)        # 610d20 <global_emfloatstruct+0x20>
  4095d1:	00 
		(double)TicksToFracSecs(accumtime);
if(locemfloatstruct->adjust==0)
  4095d2:	75 0a                	jne    4095de <DoEmFloat+0x1de>
	locemfloatstruct->adjust=1;
  4095d4:	c7 05 22 77 20 00 01 	movl   $0x1,0x207722(%rip)        # 610d00 <global_emfloatstruct>
  4095db:	00 00 00 
  4095de:	bf 50 e1 40 00       	mov    $0x40e150,%edi
  4095e3:	e8 a8 78 ff ff       	callq  400e90 <puts@plt>

#ifdef DEBUG
printf("----------------------------------------------------------------------------\n");
#endif
return;
}
  4095e8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4095ed:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4095f4:	00 00 
  4095f6:	0f 85 02 01 00 00    	jne    4096fe <DoEmFloat+0x2fe>
  4095fc:	48 83 c4 28          	add    $0x28,%rsp
  409600:	5b                   	pop    %rbx
  409601:	5d                   	pop    %rbp
  409602:	41 5c                	pop    %r12
  409604:	41 5d                	pop    %r13
  409606:	c3                   	retq   
  409607:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40960e:	00 00 
  409610:	bf 20 e1 40 00       	mov    $0x40e120,%edi
  409615:	e8 76 78 ff ff       	callq  400e90 <puts@plt>
/*
** Verify that selft adjustment code worked.
*/
if(locemfloatstruct->loops==0)
{       printf("CPU:EMFPU -- CMPUEMFLOATLOOPMAX limit hit\n");
	FreeMemory((farvoid *)abase,&systemerror);
  40961a:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  40961f:	48 89 ef             	mov    %rbp,%rdi
  409622:	e8 09 28 00 00       	callq  40be30 <FreeMemory>
	FreeMemory((farvoid *)bbase,&systemerror);
  409627:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  40962c:	4c 89 e7             	mov    %r12,%rdi
  40962f:	e8 fc 27 00 00       	callq  40be30 <FreeMemory>
	FreeMemory((farvoid *)cbase,&systemerror);
  409634:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409639:	4c 89 ef             	mov    %r13,%rdi
  40963c:	e8 ef 27 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  409641:	31 c0                	xor    %eax,%eax
  409643:	e8 58 2b 00 00       	callq  40c1a0 <ErrorExit>
  409648:	4c 8b 05 c9 76 20 00 	mov    0x2076c9(%rip),%r8        # 610d18 <global_emfloatstruct+0x18>
  40964f:	e9 b5 fe ff ff       	jmpq   409509 <DoEmFloat+0x109>
  409654:	0f 1f 40 00          	nopl   0x0(%rax)
}

cbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
		&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  409658:	bf d5 de 40 00       	mov    $0x40ded5,%edi
  40965d:	e8 0e 2b 00 00       	callq  40c170 <ReportError>
	FreeMemory((farvoid *)abase,&systemerror);
  409662:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409667:	48 89 ef             	mov    %rbp,%rdi
  40966a:	e8 c1 27 00 00       	callq  40be30 <FreeMemory>
	FreeMemory((farvoid *)bbase,&systemerror);
  40966f:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  409674:	4c 89 e7             	mov    %r12,%rdi
  409677:	e8 b4 27 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  40967c:	31 c0                	xor    %eax,%eax
  40967e:	e8 1d 2b 00 00       	callq  40c1a0 <ErrorExit>
  409683:	e9 0a fe ff ff       	jmpq   409492 <DoEmFloat+0x92>
  409688:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40968f:	00 
}

bbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
		&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  409690:	bf d5 de 40 00       	mov    $0x40ded5,%edi
  409695:	e8 d6 2a 00 00       	callq  40c170 <ReportError>
	FreeMemory((farvoid *)abase,&systemerror);
  40969a:	48 8d 74 24 14       	lea    0x14(%rsp),%rsi
  40969f:	48 89 ef             	mov    %rbp,%rdi
  4096a2:	e8 89 27 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  4096a7:	31 c0                	xor    %eax,%eax
  4096a9:	e8 f2 2a 00 00       	callq  40c1a0 <ErrorExit>
  4096ae:	e9 b7 fd ff ff       	jmpq   40946a <DoEmFloat+0x6a>
  4096b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
#endif

abase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
		&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  4096b8:	bf d5 de 40 00       	mov    $0x40ded5,%edi
  4096bd:	e8 ae 2a 00 00       	callq  40c170 <ReportError>
	ErrorExit();
  4096c2:	31 c0                	xor    %eax,%eax
  4096c4:	e8 d7 2a 00 00       	callq  40c1a0 <ErrorExit>
  4096c9:	e9 74 fd ff ff       	jmpq   409442 <DoEmFloat+0x42>
  4096ce:	66 90                	xchg   %ax,%ax
	for(loops=1;loops<CPUEMFLOATLOOPMAX;loops+=loops)
	{       tickcount=DoEmFloatIteration(abase,bbase,cbase,
			locemfloatstruct->arraysize,
			loops);
		if(tickcount>global_min_ticks)
		{       locemfloatstruct->loops=loops;
  4096d0:	48 89 1d 41 76 20 00 	mov    %rbx,0x207641(%rip)        # 610d18 <global_emfloatstruct+0x18>
  4096d7:	49 89 d8             	mov    %rbx,%r8
  4096da:	e9 2a fe ff ff       	jmpq   409509 <DoEmFloat+0x109>
  4096df:	90                   	nop
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);
FreeMemory((farvoid *)cbase,&systemerror);

locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
  4096e0:	48 89 c2             	mov    %rax,%rdx
  4096e3:	66 0f ef c9          	pxor   %xmm1,%xmm1
  4096e7:	48 d1 ea             	shr    %rdx
  4096ea:	83 e0 01             	and    $0x1,%eax
  4096ed:	48 09 c2             	or     %rax,%rdx
  4096f0:	f2 48 0f 2a ca       	cvtsi2sd %rdx,%xmm1
  4096f5:	f2 0f 58 c9          	addsd  %xmm1,%xmm1
  4096f9:	e9 a6 fe ff ff       	jmpq   4095a4 <DoEmFloat+0x1a4>

#ifdef DEBUG
printf("----------------------------------------------------------------------------\n");
#endif
return;
}
  4096fe:	e8 fd 77 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  409703:	0f 1f 00             	nopl   (%rax)
  409706:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40970d:	00 00 00 

0000000000409710 <DoFourier>:
** benchmark.  This benchmark calculates the first n
** fourier coefficients of the function (x+1)^x defined
** on the interval 0,2.
*/
void DoFourier(void)
{
  409710:	41 55                	push   %r13
  409712:	41 54                	push   %r12
  409714:	55                   	push   %rbp
  409715:	53                   	push   %rbx
  409716:	48 83 ec 28          	sub    $0x28,%rsp
errorcontext="FPU:Transcendental";

/*
** See if we need to do self-adjustment code.
*/
if(locfourierstruct->adjust==0)
  40971a:	8b 15 80 75 20 00    	mov    0x207580(%rip),%edx        # 610ca0 <global_fourierstruct>
** benchmark.  This benchmark calculates the first n
** fourier coefficients of the function (x+1)^x defined
** on the interval 0,2.
*/
void DoFourier(void)
{
  409720:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  409727:	00 00 
  409729:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40972e:	31 c0                	xor    %eax,%eax
errorcontext="FPU:Transcendental";

/*
** See if we need to do self-adjustment code.
*/
if(locfourierstruct->adjust==0)
  409730:	85 d2                	test   %edx,%edx
  409732:	0f 85 e0 00 00 00    	jne    409818 <DoFourier+0x108>
{
	locfourierstruct->arraysize=100L;       /* Start at 100 elements */
  409738:	48 c7 05 6d 75 20 00 	movq   $0x64,0x20756d(%rip)        # 610cb0 <global_fourierstruct+0x10>
  40973f:	64 00 00 00 
  409743:	bf 64 00 00 00       	mov    $0x64,%edi
  409748:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
  40974d:	eb 6a                	jmp    4097b9 <DoFourier+0xa9>
  40974f:	90                   	nop
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
			ErrorExit();
		}

		bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  409750:	48 8b 05 59 75 20 00 	mov    0x207559(%rip),%rax        # 610cb0 <global_fourierstruct+0x10>
  409757:	48 89 ee             	mov    %rbp,%rsi
  40975a:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
  409761:	00 
  409762:	e8 c9 25 00 00       	callq  40bd30 <AllocateMemory>
				&systemerror);
		if(systemerror)
  409767:	8b 74 24 14          	mov    0x14(%rsp),%esi
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
			ErrorExit();
		}

		bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  40976b:	49 89 c4             	mov    %rax,%r12
				&systemerror);
		if(systemerror)
  40976e:	85 f6                	test   %esi,%esi
  409770:	75 7e                	jne    4097f0 <DoFourier+0xe0>
		/*
		** Do an iteration of the tests.  If the elapsed time is
		** less than or equal to the permitted minimum, re-allocate
		** larger arrays and try again.
		*/
		if(DoFPUTransIteration(abase,bbase,
  409772:	48 8b 15 37 75 20 00 	mov    0x207537(%rip),%rdx        # 610cb0 <global_fourierstruct+0x10>
  409779:	4c 89 e6             	mov    %r12,%rsi
  40977c:	48 89 df             	mov    %rbx,%rdi
  40977f:	e8 ec dd ff ff       	callq  407570 <DoFPUTransIteration>
  409784:	48 3b 05 35 6f 20 00 	cmp    0x206f35(%rip),%rax        # 6106c0 <global_min_ticks>
  40978b:	0f 87 f7 00 00 00    	ja     409888 <DoFourier+0x178>
			break;          /* We're ok...exit */

		/*
		** Make bigger arrays and try again.
		*/
		FreeMemory((farvoid *)abase,&systemerror);
  409791:	48 89 ee             	mov    %rbp,%rsi
  409794:	48 89 df             	mov    %rbx,%rdi
  409797:	e8 94 26 00 00       	callq  40be30 <FreeMemory>
		FreeMemory((farvoid *)bbase,&systemerror);
  40979c:	4c 89 e7             	mov    %r12,%rdi
  40979f:	48 89 ee             	mov    %rbp,%rsi
  4097a2:	e8 89 26 00 00       	callq  40be30 <FreeMemory>
		locfourierstruct->arraysize+=50L;
  4097a7:	48 8b 05 02 75 20 00 	mov    0x207502(%rip),%rax        # 610cb0 <global_fourierstruct+0x10>
  4097ae:	48 8d 78 32          	lea    0x32(%rax),%rdi
  4097b2:	48 89 3d f7 74 20 00 	mov    %rdi,0x2074f7(%rip)        # 610cb0 <global_fourierstruct+0x10>
{
	locfourierstruct->arraysize=100L;       /* Start at 100 elements */
	while(1)
	{

		abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  4097b9:	48 c1 e7 03          	shl    $0x3,%rdi
  4097bd:	48 89 ee             	mov    %rbp,%rsi
  4097c0:	e8 6b 25 00 00       	callq  40bd30 <AllocateMemory>
				&systemerror);
		if(systemerror)
  4097c5:	8b 74 24 14          	mov    0x14(%rsp),%esi
{
	locfourierstruct->arraysize=100L;       /* Start at 100 elements */
	while(1)
	{

		abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  4097c9:	48 89 c3             	mov    %rax,%rbx
				&systemerror);
		if(systemerror)
  4097cc:	85 f6                	test   %esi,%esi
  4097ce:	74 80                	je     409750 <DoFourier+0x40>
		{       ReportError(errorcontext,systemerror);
  4097d0:	bf ec de 40 00       	mov    $0x40deec,%edi
  4097d5:	e8 96 29 00 00       	callq  40c170 <ReportError>
			ErrorExit();
  4097da:	31 c0                	xor    %eax,%eax
  4097dc:	e8 bf 29 00 00       	callq  40c1a0 <ErrorExit>
  4097e1:	e9 6a ff ff ff       	jmpq   409750 <DoFourier+0x40>
  4097e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4097ed:	00 00 00 
		}

		bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
				&systemerror);
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
  4097f0:	bf ec de 40 00       	mov    $0x40deec,%edi
  4097f5:	e8 76 29 00 00       	callq  40c170 <ReportError>
			FreeMemory((void *)abase,&systemerror);
  4097fa:	48 89 ee             	mov    %rbp,%rsi
  4097fd:	48 89 df             	mov    %rbx,%rdi
  409800:	e8 2b 26 00 00       	callq  40be30 <FreeMemory>
			ErrorExit();
  409805:	31 c0                	xor    %eax,%eax
  409807:	e8 94 29 00 00       	callq  40c1a0 <ErrorExit>
  40980c:	e9 61 ff ff ff       	jmpq   409772 <DoFourier+0x62>
  409811:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
else
{       /*
	** Don't need self-adjustment.  Just allocate the
	** arrays, and go.
	*/
	abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  409818:	48 8b 05 91 74 20 00 	mov    0x207491(%rip),%rax        # 610cb0 <global_fourierstruct+0x10>
  40981f:	48 8d 6c 24 14       	lea    0x14(%rsp),%rbp
  409824:	48 89 ee             	mov    %rbp,%rsi
  409827:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
  40982e:	00 
  40982f:	e8 fc 24 00 00       	callq  40bd30 <AllocateMemory>
			&systemerror);
	if(systemerror)
  409834:	8b 74 24 14          	mov    0x14(%rsp),%esi
else
{       /*
	** Don't need self-adjustment.  Just allocate the
	** arrays, and go.
	*/
	abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  409838:	48 89 c3             	mov    %rax,%rbx
			&systemerror);
	if(systemerror)
  40983b:	85 f6                	test   %esi,%esi
  40983d:	0f 85 2c 01 00 00    	jne    40996f <DoFourier+0x25f>
	{       ReportError(errorcontext,systemerror);
		ErrorExit();
	}

	bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  409843:	48 8b 05 66 74 20 00 	mov    0x207466(%rip),%rax        # 610cb0 <global_fourierstruct+0x10>
  40984a:	48 89 ee             	mov    %rbp,%rsi
  40984d:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
  409854:	00 
  409855:	e8 d6 24 00 00       	callq  40bd30 <AllocateMemory>
			&systemerror);
	if(systemerror)
  40985a:	8b 74 24 14          	mov    0x14(%rsp),%esi
	if(systemerror)
	{       ReportError(errorcontext,systemerror);
		ErrorExit();
	}

	bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
  40985e:	49 89 c4             	mov    %rax,%r12
			&systemerror);
	if(systemerror)
  409861:	85 f6                	test   %esi,%esi
  409863:	74 23                	je     409888 <DoFourier+0x178>
	{       ReportError(errorcontext,systemerror);
  409865:	bf ec de 40 00       	mov    $0x40deec,%edi
  40986a:	e8 01 29 00 00       	callq  40c170 <ReportError>
		FreeMemory((void *)abase,&systemerror);
  40986f:	48 89 ee             	mov    %rbp,%rsi
  409872:	48 89 df             	mov    %rbx,%rdi
  409875:	e8 b6 25 00 00       	callq  40be30 <FreeMemory>
		ErrorExit();
  40987a:	31 c0                	xor    %eax,%eax
  40987c:	e8 1f 29 00 00       	callq  40c1a0 <ErrorExit>
  409881:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
** All's well if we get here.  Repeatedly perform integration
** tests until the accumulated time is greater than the
** # of seconds requested.
*/
accumtime=0L;
iterations=(double)0.0;
  409888:	66 0f ef db          	pxor   %xmm3,%xmm3
/*
** All's well if we get here.  Repeatedly perform integration
** tests until the accumulated time is greater than the
** # of seconds requested.
*/
accumtime=0L;
  40988c:	45 31 ed             	xor    %r13d,%r13d
iterations=(double)0.0;
  40988f:	f2 0f 11 5c 24 08    	movsd  %xmm3,0x8(%rsp)
  409895:	eb 3b                	jmp    4098d2 <DoFourier+0x1c2>
  409897:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40989e:	00 00 
do {
	accumtime+=DoFPUTransIteration(abase,bbase,locfourierstruct->arraysize);
	iterations+=(double)locfourierstruct->arraysize*(double)2.0-(double)1.0;
  4098a0:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4098a4:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  4098a9:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
} while(TicksToSecs(accumtime)<locfourierstruct->request_secs);
  4098ad:	4c 89 ef             	mov    %r13,%rdi
*/
accumtime=0L;
iterations=(double)0.0;
do {
	accumtime+=DoFPUTransIteration(abase,bbase,locfourierstruct->arraysize);
	iterations+=(double)locfourierstruct->arraysize*(double)2.0-(double)1.0;
  4098b0:	f2 0f 5c 05 b8 44 00 	subsd  0x44b8(%rip),%xmm0        # 40dd70 <jtable.3055+0xfe0>
  4098b7:	00 
  4098b8:	f2 0f 58 44 24 08    	addsd  0x8(%rsp),%xmm0
  4098be:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
} while(TicksToSecs(accumtime)<locfourierstruct->request_secs);
  4098c4:	e8 07 29 00 00       	callq  40c1d0 <TicksToSecs>
  4098c9:	48 3b 05 d8 73 20 00 	cmp    0x2073d8(%rip),%rax        # 610ca8 <global_fourierstruct+0x8>
  4098d0:	73 3e                	jae    409910 <DoFourier+0x200>
** # of seconds requested.
*/
accumtime=0L;
iterations=(double)0.0;
do {
	accumtime+=DoFPUTransIteration(abase,bbase,locfourierstruct->arraysize);
  4098d2:	48 8b 15 d7 73 20 00 	mov    0x2073d7(%rip),%rdx        # 610cb0 <global_fourierstruct+0x10>
  4098d9:	4c 89 e6             	mov    %r12,%rsi
  4098dc:	48 89 df             	mov    %rbx,%rdi
  4098df:	e8 8c dc ff ff       	callq  407570 <DoFPUTransIteration>
  4098e4:	49 01 c5             	add    %rax,%r13
	iterations+=(double)locfourierstruct->arraysize*(double)2.0-(double)1.0;
  4098e7:	48 8b 05 c2 73 20 00 	mov    0x2073c2(%rip),%rax        # 610cb0 <global_fourierstruct+0x10>
  4098ee:	48 85 c0             	test   %rax,%rax
  4098f1:	79 ad                	jns    4098a0 <DoFourier+0x190>
  4098f3:	48 89 c2             	mov    %rax,%rdx
  4098f6:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4098fa:	48 d1 ea             	shr    %rdx
  4098fd:	83 e0 01             	and    $0x1,%eax
  409900:	48 09 c2             	or     %rax,%rdx
  409903:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  409908:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40990c:	eb 9b                	jmp    4098a9 <DoFourier+0x199>
  40990e:	66 90                	xchg   %ax,%ax

/*
** Clean up, calculate results, and go home.
** Also set adjustment flag to indicate no adjust code needed.
*/
FreeMemory((farvoid *)abase,&systemerror);
  409910:	48 89 ee             	mov    %rbp,%rsi
  409913:	48 89 df             	mov    %rbx,%rdi
  409916:	e8 15 25 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)bbase,&systemerror);
  40991b:	48 89 ee             	mov    %rbp,%rsi
  40991e:	4c 89 e7             	mov    %r12,%rdi
  409921:	e8 0a 25 00 00       	callq  40be30 <FreeMemory>

locfourierstruct->fflops=iterations/(double)TicksToFracSecs(accumtime);
  409926:	4c 89 ef             	mov    %r13,%rdi
  409929:	e8 c2 28 00 00       	callq  40c1f0 <TicksToFracSecs>
  40992e:	f2 0f 10 54 24 08    	movsd  0x8(%rsp),%xmm2

if(locfourierstruct->adjust==0)
  409934:	8b 05 66 73 20 00    	mov    0x207366(%rip),%eax        # 610ca0 <global_fourierstruct>
** Also set adjustment flag to indicate no adjust code needed.
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);

locfourierstruct->fflops=iterations/(double)TicksToFracSecs(accumtime);
  40993a:	f2 0f 5e d0          	divsd  %xmm0,%xmm2

if(locfourierstruct->adjust==0)
  40993e:	85 c0                	test   %eax,%eax
** Also set adjustment flag to indicate no adjust code needed.
*/
FreeMemory((farvoid *)abase,&systemerror);
FreeMemory((farvoid *)bbase,&systemerror);

locfourierstruct->fflops=iterations/(double)TicksToFracSecs(accumtime);
  409940:	f2 0f 11 15 70 73 20 	movsd  %xmm2,0x207370(%rip)        # 610cb8 <global_fourierstruct+0x18>
  409947:	00 

if(locfourierstruct->adjust==0)
  409948:	75 0a                	jne    409954 <DoFourier+0x244>
	locfourierstruct->adjust=1;
  40994a:	c7 05 4c 73 20 00 01 	movl   $0x1,0x20734c(%rip)        # 610ca0 <global_fourierstruct>
  409951:	00 00 00 

return;
}
  409954:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  409959:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  409960:	00 00 
  409962:	75 21                	jne    409985 <DoFourier+0x275>
  409964:	48 83 c4 28          	add    $0x28,%rsp
  409968:	5b                   	pop    %rbx
  409969:	5d                   	pop    %rbp
  40996a:	41 5c                	pop    %r12
  40996c:	41 5d                	pop    %r13
  40996e:	c3                   	retq   
	** arrays, and go.
	*/
	abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
			&systemerror);
	if(systemerror)
	{       ReportError(errorcontext,systemerror);
  40996f:	bf ec de 40 00       	mov    $0x40deec,%edi
  409974:	e8 f7 27 00 00       	callq  40c170 <ReportError>
		ErrorExit();
  409979:	31 c0                	xor    %eax,%eax
  40997b:	e8 20 28 00 00       	callq  40c1a0 <ErrorExit>
  409980:	e9 be fe ff ff       	jmpq   409843 <DoFourier+0x133>

if(locfourierstruct->adjust==0)
	locfourierstruct->adjust=1;

return;
}
  409985:	e8 76 75 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  40998a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000409990 <DoAssign>:
**    This makes for some algorithmically-correct but
**    probably non-optimal constructs.
**
*/
void DoAssign(void)
{
  409990:	41 57                	push   %r15
  409992:	41 56                	push   %r14
  409994:	41 55                	push   %r13
  409996:	41 54                	push   %r12
  409998:	55                   	push   %rbp
  409999:	53                   	push   %rbx
  40999a:	48 83 ec 38          	sub    $0x38,%rsp
errorcontext="CPU:Assignment";

/*
** See if we need to do self adjustment code.
*/
if(locassignstruct->adjust==0)
  40999e:	8b 15 bc 6e 20 00    	mov    0x206ebc(%rip),%edx        # 610860 <global_assignstruct>
**    This makes for some algorithmically-correct but
**    probably non-optimal constructs.
**
*/
void DoAssign(void)
{
  4099a4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4099ab:	00 00 
  4099ad:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  4099b2:	31 c0                	xor    %eax,%eax
errorcontext="CPU:Assignment";

/*
** See if we need to do self adjustment code.
*/
if(locassignstruct->adjust==0)
  4099b4:	85 d2                	test   %edx,%edx
  4099b6:	0f 85 92 01 00 00    	jne    409b4e <DoAssign+0x1be>
  4099bc:	48 8d 5c 24 24       	lea    0x24(%rsp),%rbx
	** Self-adjustment code.  The system begins by working on 1
	** array.  If it does that in no time, then two arrays
	** are built.  This process continues until
	** enough arrays are built to handle the tolerance.
	*/
	locassignstruct->numarrays=1;
  4099c1:	48 c7 05 a4 6e 20 00 	movq   $0x1,0x206ea4(%rip)        # 610870 <global_assignstruct+0x10>
  4099c8:	01 00 00 00 
  4099cc:	b8 01 00 00 00       	mov    $0x1,%eax
  4099d1:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
  4099d6:	48 89 de             	mov    %rbx,%rsi
	while(1)
	{
		/*
		** Allocate space for arrays
		*/
		arraybase=(farlong *) AllocateMemory(sizeof(long)*
  4099d9:	48 69 f8 c8 3e 01 00 	imul   $0x13ec8,%rax,%rdi
  4099e0:	e8 4b 23 00 00       	callq  40bd30 <AllocateMemory>
			ASSIGNROWS*ASSIGNCOLS*locassignstruct->numarrays,
			 &systemerror);
		if(systemerror)
  4099e5:	8b 74 24 24          	mov    0x24(%rsp),%esi
	while(1)
	{
		/*
		** Allocate space for arrays
		*/
		arraybase=(farlong *) AllocateMemory(sizeof(long)*
  4099e9:	48 89 c3             	mov    %rax,%rbx
			ASSIGNROWS*ASSIGNCOLS*locassignstruct->numarrays,
			 &systemerror);
		if(systemerror)
  4099ec:	85 f6                	test   %esi,%esi
  4099ee:	74 1e                	je     409a0e <DoAssign+0x7e>
		{       ReportError(errorcontext,systemerror);
  4099f0:	bf ff de 40 00       	mov    $0x40deff,%edi
  4099f5:	e8 76 27 00 00       	callq  40c170 <ReportError>
			FreeMemory((farvoid *)arraybase,
  4099fa:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  4099ff:	48 89 df             	mov    %rbx,%rdi
  409a02:	e8 29 24 00 00       	callq  40be30 <FreeMemory>
			  &systemerror);
			ErrorExit();
  409a07:	31 c0                	xor    %eax,%eax
  409a09:	e8 92 27 00 00       	callq  40c1a0 <ErrorExit>

/*
** Reset random number generator so things repeat.
*/
/* randnum(13L); */
randnum((int32)13);
  409a0e:	bf 0d 00 00 00       	mov    $0xd,%edi
		** Do an iteration of the assignment alg.  If the
		** elapsed time is less than or equal to the permitted
		** minimum, then allocate for more arrays and
		** try again.
		*/
		if(DoAssignIteration(arraybase,
  409a13:	48 8b 2d 56 6e 20 00 	mov    0x206e56(%rip),%rbp        # 610870 <global_assignstruct+0x10>

/*
** Reset random number generator so things repeat.
*/
/* randnum(13L); */
randnum((int32)13);
  409a1a:	49 89 dc             	mov    %rbx,%r12
  409a1d:	e8 be ad ff ff       	callq  4047e0 <randnum>
  409a22:	48 8d 83 c8 3e 01 00 	lea    0x13ec8(%rbx),%rax
  409a29:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  409a2e:	4d 8d ac 24 28 03 00 	lea    0x328(%r12),%r13
  409a35:	00 
  409a36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  409a3d:	00 00 00 

for(i=0;i<ASSIGNROWS;i++)
  for(j=0;j<ASSIGNROWS;j++){
    /* arraybase[i][j]=abs_randwc(5000000L);*/
    arraybase[i][j]=abs_randwc((int32)5000000);
  409a40:	bf 40 4b 4c 00       	mov    $0x4c4b40,%edi
  409a45:	49 83 c4 08          	add    $0x8,%r12
  409a49:	e8 32 ad ff ff       	callq  404780 <abs_randwc>
  409a4e:	89 c0                	mov    %eax,%eax
  409a50:	49 89 44 24 f8       	mov    %rax,-0x8(%r12)
*/
/* randnum(13L); */
randnum((int32)13);

for(i=0;i<ASSIGNROWS;i++)
  for(j=0;j<ASSIGNROWS;j++){
  409a55:	4d 39 ec             	cmp    %r13,%r12
  409a58:	75 e6                	jne    409a40 <DoAssign+0xb0>
** Reset random number generator so things repeat.
*/
/* randnum(13L); */
randnum((int32)13);

for(i=0;i<ASSIGNROWS;i++)
  409a5a:	4c 39 64 24 18       	cmp    %r12,0x18(%rsp)
  409a5f:	75 cd                	jne    409a2e <DoAssign+0x9e>
/*
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
  409a61:	48 83 fd 01          	cmp    $0x1,%rbp
	while(1)
	{
		/*
		** Allocate space for arrays
		*/
		arraybase=(farlong *) AllocateMemory(sizeof(long)*
  409a65:	49 89 dd             	mov    %rbx,%r13
/*
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
  409a68:	41 be 01 00 00 00    	mov    $0x1,%r14d
  409a6e:	0f 86 ad 03 00 00    	jbe    409e21 <DoAssign+0x491>
	for(i=1;i<numarrays;i++)
	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
	        /* Fixed  by Eike Dierks */
	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409a74:	4d 8d 9d c8 3e 01 00 	lea    0x13ec8(%r13),%r11
  409a7b:	49 c7 c1 38 c1 fe ff 	mov    $0xfffffffffffec138,%r9
  409a82:	4d 8d 95 90 7d 02 00 	lea    0x27d90(%r13),%r10
  409a89:	48 89 de             	mov    %rbx,%rsi
  409a8c:	45 31 c0             	xor    %r8d,%r8d
  409a8f:	4d 29 e9             	sub    %r13,%r9
  409a92:	4c 89 d9             	mov    %r11,%rcx
  409a95:	0f 1f 00             	nopl   (%rax)
  409a98:	48 8d 46 10          	lea    0x10(%rsi),%rax
  409a9c:	49 8d 14 09          	lea    (%r9,%rcx,1),%rdx
  409aa0:	48 39 c1             	cmp    %rax,%rcx
  409aa3:	73 0d                	jae    409ab2 <DoAssign+0x122>
  409aa5:	48 8d 41 10          	lea    0x10(%rcx),%rax
  409aa9:	48 39 c6             	cmp    %rax,%rsi
  409aac:	0f 82 0b 03 00 00    	jb     409dbd <DoAssign+0x42d>
  409ab2:	40 f6 c6 08          	test   $0x8,%sil
  409ab6:	0f 84 f4 02 00 00    	je     409db0 <DoAssign+0x420>
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
		arrayto[i][j]=arrayfrom[i][j];
  409abc:	48 8b 06             	mov    (%rsi),%rax
  409abf:	41 bf 64 00 00 00    	mov    $0x64,%r15d
  409ac5:	48 89 01             	mov    %rax,(%rcx)
  409ac8:	b8 01 00 00 00       	mov    $0x1,%eax
  409acd:	48 8d 3c c2          	lea    (%rdx,%rax,8),%rdi
  409ad1:	49 8d 84 00 d9 27 00 	lea    0x27d9(%r8,%rax,1),%rax
  409ad8:	00 
  409ad9:	31 d2                	xor    %edx,%edx
  409adb:	4d 8d 64 c5 00       	lea    0x0(%r13,%rax,8),%r12
  409ae0:	48 01 df             	add    %rbx,%rdi
  409ae3:	31 c0                	xor    %eax,%eax
  409ae5:	0f 1f 00             	nopl   (%rax)
  409ae8:	66 0f 6f 04 07       	movdqa (%rdi,%rax,1),%xmm0
  409aed:	83 c2 01             	add    $0x1,%edx
  409af0:	41 0f 11 04 04       	movups %xmm0,(%r12,%rax,1)
  409af5:	48 83 c0 10          	add    $0x10,%rax
  409af9:	66 83 fa 31          	cmp    $0x31,%dx
  409afd:	76 e9                	jbe    409ae8 <DoAssign+0x158>
  409aff:	66 41 83 ff 64       	cmp    $0x64,%r15w
  409b04:	74 0e                	je     409b14 <DoAssign+0x184>
  409b06:	48 8b 86 20 03 00 00 	mov    0x320(%rsi),%rax
  409b0d:	48 89 81 20 03 00 00 	mov    %rax,0x320(%rcx)
  409b14:	48 81 c1 28 03 00 00 	add    $0x328,%rcx
  409b1b:	48 81 c6 28 03 00 00 	add    $0x328,%rsi
  409b22:	49 83 c0 65          	add    $0x65,%r8
static void CopyToAssign(farlong arrayfrom[ASSIGNROWS][ASSIGNCOLS],
		farlong arrayto[ASSIGNROWS][ASSIGNCOLS])
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
  409b26:	49 39 ca             	cmp    %rcx,%r10
  409b29:	0f 85 69 ff ff ff    	jne    409a98 <DoAssign+0x108>
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
	for(i=1;i<numarrays;i++)
  409b2f:	49 83 c6 01          	add    $0x1,%r14
	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
	        /* Fixed  by Eike Dierks */
	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409b33:	4d 89 dd             	mov    %r11,%r13
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
	for(i=1;i<numarrays;i++)
  409b36:	4c 39 f5             	cmp    %r14,%rbp
  409b39:	0f 85 35 ff ff ff    	jne    409a74 <DoAssign+0xe4>
LoadAssignArrayWithRand(arraybase,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  409b3f:	31 c0                	xor    %eax,%eax
  409b41:	e8 6a 26 00 00       	callq  40c1b0 <StartStopwatch>
  409b46:	49 89 c6             	mov    %rax,%r14
  409b49:	e9 e2 02 00 00       	jmpq   409e30 <DoAssign+0x4a0>
}
else
{       /*
	** Allocate space for arrays
	*/
	arraybase=(farlong *)AllocateMemory(sizeof(long)*
  409b4e:	48 69 3d 17 6d 20 00 	imul   $0x13ec8,0x206d17(%rip),%rdi        # 610870 <global_assignstruct+0x10>
  409b55:	c8 3e 01 00 
  409b59:	48 8d 44 24 24       	lea    0x24(%rsp),%rax
  409b5e:	48 89 c6             	mov    %rax,%rsi
  409b61:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  409b66:	e8 c5 21 00 00       	callq  40bd30 <AllocateMemory>
		ASSIGNROWS*ASSIGNCOLS*locassignstruct->numarrays,
		 &systemerror);
	if(systemerror)
  409b6b:	8b 74 24 24          	mov    0x24(%rsp),%esi
}
else
{       /*
	** Allocate space for arrays
	*/
	arraybase=(farlong *)AllocateMemory(sizeof(long)*
  409b6f:	48 89 c3             	mov    %rax,%rbx
  409b72:	48 8d 80 c8 3e 01 00 	lea    0x13ec8(%rax),%rax
  409b79:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
		ASSIGNROWS*ASSIGNCOLS*locassignstruct->numarrays,
		 &systemerror);
	if(systemerror)
  409b7e:	85 f6                	test   %esi,%esi
  409b80:	74 1e                	je     409ba0 <DoAssign+0x210>
	{       ReportError(errorcontext,systemerror);
  409b82:	bf ff de 40 00       	mov    $0x40deff,%edi
  409b87:	e8 e4 25 00 00       	callq  40c170 <ReportError>
		FreeMemory((farvoid *)arraybase,
  409b8c:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  409b91:	48 89 df             	mov    %rbx,%rdi
  409b94:	e8 97 22 00 00       	callq  40be30 <FreeMemory>
		  &systemerror);
		ErrorExit();
  409b99:	31 c0                	xor    %eax,%eax
  409b9b:	e8 00 26 00 00       	callq  40c1a0 <ErrorExit>

/*
** All's well if we get here.  Do the tests.
*/
accumtime=0L;
iterations=(double)0.0;
  409ba0:	66 0f ef db          	pxor   %xmm3,%xmm3
}

/*
** All's well if we get here.  Do the tests.
*/
accumtime=0L;
  409ba4:	45 31 ff             	xor    %r15d,%r15d
iterations=(double)0.0;
  409ba7:	f2 0f 11 5c 24 10    	movsd  %xmm3,0x10(%rsp)

/*
** Reset random number generator so things repeat.
*/
/* randnum(13L); */
randnum((int32)13);
  409bad:	bf 0d 00 00 00       	mov    $0xd,%edi
  409bb2:	49 89 dc             	mov    %rbx,%r12
*/
accumtime=0L;
iterations=(double)0.0;

do {
	accumtime+=DoAssignIteration(arraybase,
  409bb5:	48 8b 2d b4 6c 20 00 	mov    0x206cb4(%rip),%rbp        # 610870 <global_assignstruct+0x10>

/*
** Reset random number generator so things repeat.
*/
/* randnum(13L); */
randnum((int32)13);
  409bbc:	e8 1f ac ff ff       	callq  4047e0 <randnum>
  409bc1:	4d 8d ac 24 28 03 00 	lea    0x328(%r12),%r13
  409bc8:	00 
  409bc9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

for(i=0;i<ASSIGNROWS;i++)
  for(j=0;j<ASSIGNROWS;j++){
    /* arraybase[i][j]=abs_randwc(5000000L);*/
    arraybase[i][j]=abs_randwc((int32)5000000);
  409bd0:	bf 40 4b 4c 00       	mov    $0x4c4b40,%edi
  409bd5:	49 83 c4 08          	add    $0x8,%r12
  409bd9:	e8 a2 ab ff ff       	callq  404780 <abs_randwc>
  409bde:	89 c0                	mov    %eax,%eax
  409be0:	49 89 44 24 f8       	mov    %rax,-0x8(%r12)
*/
/* randnum(13L); */
randnum((int32)13);

for(i=0;i<ASSIGNROWS;i++)
  for(j=0;j<ASSIGNROWS;j++){
  409be5:	4d 39 e5             	cmp    %r12,%r13
  409be8:	75 e6                	jne    409bd0 <DoAssign+0x240>
** Reset random number generator so things repeat.
*/
/* randnum(13L); */
randnum((int32)13);

for(i=0;i<ASSIGNROWS;i++)
  409bea:	4c 39 6c 24 18       	cmp    %r13,0x18(%rsp)
  409bef:	4d 89 ec             	mov    %r13,%r12
  409bf2:	75 cd                	jne    409bc1 <DoAssign+0x231>
/*
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
  409bf4:	48 83 fd 01          	cmp    $0x1,%rbp
  409bf8:	49 89 da             	mov    %rbx,%r10
  409bfb:	41 bb 01 00 00 00    	mov    $0x1,%r11d
  409c01:	0f 86 02 02 00 00    	jbe    409e09 <DoAssign+0x479>
	for(i=1;i<numarrays;i++)
	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
	        /* Fixed  by Eike Dierks */
	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409c07:	4d 8d a2 c8 3e 01 00 	lea    0x13ec8(%r10),%r12
  409c0e:	4d 8d 8a 90 7d 02 00 	lea    0x27d90(%r10),%r9
  409c15:	48 89 de             	mov    %rbx,%rsi
  409c18:	45 31 c0             	xor    %r8d,%r8d
  409c1b:	4c 89 e1             	mov    %r12,%rcx
  409c1e:	66 90                	xchg   %ax,%ax
  409c20:	48 8d 41 10          	lea    0x10(%rcx),%rax
  409c24:	4a 8d 14 c5 00 00 00 	lea    0x0(,%r8,8),%rdx
  409c2b:	00 
  409c2c:	48 39 c6             	cmp    %rax,%rsi
  409c2f:	73 0d                	jae    409c3e <DoAssign+0x2ae>
  409c31:	48 8d 46 10          	lea    0x10(%rsi),%rax
  409c35:	48 39 c1             	cmp    %rax,%rcx
  409c38:	0f 82 af 01 00 00    	jb     409ded <DoAssign+0x45d>
  409c3e:	40 f6 c6 08          	test   $0x8,%sil
  409c42:	0f 84 98 01 00 00    	je     409de0 <DoAssign+0x450>
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
		arrayto[i][j]=arrayfrom[i][j];
  409c48:	48 8b 06             	mov    (%rsi),%rax
  409c4b:	41 be 64 00 00 00    	mov    $0x64,%r14d
  409c51:	48 89 01             	mov    %rax,(%rcx)
  409c54:	b8 01 00 00 00       	mov    $0x1,%eax
  409c59:	48 8d 3c c2          	lea    (%rdx,%rax,8),%rdi
  409c5d:	4a 8d 84 00 d9 27 00 	lea    0x27d9(%rax,%r8,1),%rax
  409c64:	00 
  409c65:	31 d2                	xor    %edx,%edx
  409c67:	4d 8d 2c c2          	lea    (%r10,%rax,8),%r13
  409c6b:	48 01 df             	add    %rbx,%rdi
  409c6e:	31 c0                	xor    %eax,%eax
  409c70:	66 0f 6f 04 07       	movdqa (%rdi,%rax,1),%xmm0
  409c75:	83 c2 01             	add    $0x1,%edx
  409c78:	41 0f 11 44 05 00    	movups %xmm0,0x0(%r13,%rax,1)
  409c7e:	48 83 c0 10          	add    $0x10,%rax
  409c82:	66 83 fa 31          	cmp    $0x31,%dx
  409c86:	76 e8                	jbe    409c70 <DoAssign+0x2e0>
  409c88:	66 41 83 fe 64       	cmp    $0x64,%r14w
  409c8d:	74 0e                	je     409c9d <DoAssign+0x30d>
  409c8f:	48 8b 86 20 03 00 00 	mov    0x320(%rsi),%rax
  409c96:	48 89 81 20 03 00 00 	mov    %rax,0x320(%rcx)
  409c9d:	48 81 c1 28 03 00 00 	add    $0x328,%rcx
  409ca4:	48 81 c6 28 03 00 00 	add    $0x328,%rsi
  409cab:	49 83 c0 65          	add    $0x65,%r8
static void CopyToAssign(farlong arrayfrom[ASSIGNROWS][ASSIGNCOLS],
		farlong arrayto[ASSIGNROWS][ASSIGNCOLS])
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
  409caf:	49 39 c9             	cmp    %rcx,%r9
  409cb2:	0f 85 68 ff ff ff    	jne    409c20 <DoAssign+0x290>
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
	for(i=1;i<numarrays;i++)
  409cb8:	49 83 c3 01          	add    $0x1,%r11
	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
	        /* Fixed  by Eike Dierks */
	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409cbc:	4d 89 e2             	mov    %r12,%r10
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
	for(i=1;i<numarrays;i++)
  409cbf:	4c 39 dd             	cmp    %r11,%rbp
  409cc2:	0f 85 3f ff ff ff    	jne    409c07 <DoAssign+0x277>
LoadAssignArrayWithRand(arraybase,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  409cc8:	31 c0                	xor    %eax,%eax
  409cca:	e8 e1 24 00 00       	callq  40c1b0 <StartStopwatch>
  409ccf:	49 89 c6             	mov    %rax,%r14
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
	for(i=1;i<numarrays;i++)
	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
	        /* Fixed  by Eike Dierks */
	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409cd2:	49 89 dd             	mov    %rbx,%r13
  409cd5:	45 31 e4             	xor    %r12d,%r12d
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        /* Fixed  by Eike Dierks */
	Assignment(*abase.ptrs.ap);
  409cd8:	4c 89 ef             	mov    %r13,%rdi
elapsed=StartStopwatch();

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409cdb:	49 83 c4 01          	add    $0x1,%r12
{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        /* Fixed  by Eike Dierks */
	Assignment(*abase.ptrs.ap);
	abase.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409cdf:	49 81 c5 c8 3e 01 00 	add    $0x13ec8,%r13
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        /* Fixed  by Eike Dierks */
	Assignment(*abase.ptrs.ap);
  409ce6:	e8 35 af ff ff       	callq  404c20 <Assignment>
elapsed=StartStopwatch();

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409ceb:	4c 39 e5             	cmp    %r12,%rbp
  409cee:	75 e8                	jne    409cd8 <DoAssign+0x348>
}

/*
** Get elapsed time
*/
return(StopStopwatch(elapsed));
  409cf0:	4c 89 f7             	mov    %r14,%rdi
  409cf3:	e8 c8 24 00 00       	callq  40c1c0 <StopStopwatch>
iterations=(double)0.0;

do {
	accumtime+=DoAssignIteration(arraybase,
		locassignstruct->numarrays);
	iterations+=(double)1.0;
  409cf8:	f2 0f 10 15 70 40 00 	movsd  0x4070(%rip),%xmm2        # 40dd70 <jtable.3055+0xfe0>
  409cff:	00 
*/
accumtime=0L;
iterations=(double)0.0;

do {
	accumtime+=DoAssignIteration(arraybase,
  409d00:	49 01 c7             	add    %rax,%r15
		locassignstruct->numarrays);
	iterations+=(double)1.0;
} while(TicksToSecs(accumtime)<locassignstruct->request_secs);
  409d03:	4c 89 ff             	mov    %r15,%rdi
iterations=(double)0.0;

do {
	accumtime+=DoAssignIteration(arraybase,
		locassignstruct->numarrays);
	iterations+=(double)1.0;
  409d06:	f2 0f 58 54 24 10    	addsd  0x10(%rsp),%xmm2
  409d0c:	f2 0f 11 54 24 10    	movsd  %xmm2,0x10(%rsp)
} while(TicksToSecs(accumtime)<locassignstruct->request_secs);
  409d12:	e8 b9 24 00 00       	callq  40c1d0 <TicksToSecs>
  409d17:	48 3b 05 4a 6b 20 00 	cmp    0x206b4a(%rip),%rax        # 610868 <global_assignstruct+0x8>
  409d1e:	0f 82 89 fe ff ff    	jb     409bad <DoAssign+0x21d>

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);
  409d24:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  409d29:	48 89 df             	mov    %rbx,%rdi
  409d2c:	e8 ff 20 00 00       	callq  40be30 <FreeMemory>

locassignstruct->iterspersec=iterations *
  409d31:	48 8b 15 38 6b 20 00 	mov    0x206b38(%rip),%rdx        # 610870 <global_assignstruct+0x10>
  409d38:	48 85 d2             	test   %rdx,%rdx
  409d3b:	0f 88 4b 01 00 00    	js     409e8c <DoAssign+0x4fc>
  409d41:	66 0f ef c0          	pxor   %xmm0,%xmm0
  409d45:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  409d4a:	f2 0f 10 4c 24 10    	movsd  0x10(%rsp),%xmm1
	(double)locassignstruct->numarrays / TicksToFracSecs(accumtime);
  409d50:	4c 89 ff             	mov    %r15,%rdi
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

locassignstruct->iterspersec=iterations *
  409d53:	f2 0f 59 c8          	mulsd  %xmm0,%xmm1
  409d57:	f2 0f 11 4c 24 08    	movsd  %xmm1,0x8(%rsp)
	(double)locassignstruct->numarrays / TicksToFracSecs(accumtime);
  409d5d:	e8 8e 24 00 00       	callq  40c1f0 <TicksToFracSecs>
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

locassignstruct->iterspersec=iterations *
  409d62:	f2 0f 10 4c 24 08    	movsd  0x8(%rsp),%xmm1
	(double)locassignstruct->numarrays / TicksToFracSecs(accumtime);

if(locassignstruct->adjust==0)
  409d68:	8b 05 f2 6a 20 00    	mov    0x206af2(%rip),%eax        # 610860 <global_assignstruct>
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

locassignstruct->iterspersec=iterations *
  409d6e:	f2 0f 5e c8          	divsd  %xmm0,%xmm1
	(double)locassignstruct->numarrays / TicksToFracSecs(accumtime);

if(locassignstruct->adjust==0)
  409d72:	85 c0                	test   %eax,%eax
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

locassignstruct->iterspersec=iterations *
  409d74:	f2 0f 11 0d fc 6a 20 	movsd  %xmm1,0x206afc(%rip)        # 610878 <global_assignstruct+0x18>
  409d7b:	00 
	(double)locassignstruct->numarrays / TicksToFracSecs(accumtime);

if(locassignstruct->adjust==0)
  409d7c:	75 0a                	jne    409d88 <DoAssign+0x3f8>
	locassignstruct->adjust=1;
  409d7e:	c7 05 d8 6a 20 00 01 	movl   $0x1,0x206ad8(%rip)        # 610860 <global_assignstruct>
  409d85:	00 00 00 

return;

}
  409d88:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  409d8d:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  409d94:	00 00 
  409d96:	0f 85 0e 01 00 00    	jne    409eaa <DoAssign+0x51a>
  409d9c:	48 83 c4 38          	add    $0x38,%rsp
  409da0:	5b                   	pop    %rbx
  409da1:	5d                   	pop    %rbp
  409da2:	41 5c                	pop    %r12
  409da4:	41 5d                	pop    %r13
  409da6:	41 5e                	pop    %r14
  409da8:	41 5f                	pop    %r15
  409daa:	c3                   	retq   
  409dab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
		arrayto[i][j]=arrayfrom[i][j];
  409db0:	41 bf 65 00 00 00    	mov    $0x65,%r15d
  409db6:	31 c0                	xor    %eax,%eax
  409db8:	e9 10 fd ff ff       	jmpq   409acd <DoAssign+0x13d>
/*
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
  409dbd:	31 c0                	xor    %eax,%eax
  409dbf:	90                   	nop
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
		arrayto[i][j]=arrayfrom[i][j];
  409dc0:	48 8b 14 06          	mov    (%rsi,%rax,1),%rdx
  409dc4:	48 89 14 01          	mov    %rdx,(%rcx,%rax,1)
  409dc8:	48 83 c0 08          	add    $0x8,%rax
		farlong arrayto[ASSIGNROWS][ASSIGNCOLS])
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
  409dcc:	48 3d 28 03 00 00    	cmp    $0x328,%rax
  409dd2:	75 ec                	jne    409dc0 <DoAssign+0x430>
  409dd4:	e9 3b fd ff ff       	jmpq   409b14 <DoAssign+0x184>
  409dd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		arrayto[i][j]=arrayfrom[i][j];
  409de0:	41 be 65 00 00 00    	mov    $0x65,%r14d
  409de6:	31 c0                	xor    %eax,%eax
  409de8:	e9 6c fe ff ff       	jmpq   409c59 <DoAssign+0x2c9>
/*
** Set up the first array.  Then just copy it into the
** others.
*/
LoadAssign(*(abase.ptrs.ap));
if(numarrays>1)
  409ded:	31 c0                	xor    %eax,%eax
  409def:	90                   	nop
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
		arrayto[i][j]=arrayfrom[i][j];
  409df0:	48 8b 14 06          	mov    (%rsi,%rax,1),%rdx
  409df4:	48 89 14 01          	mov    %rdx,(%rcx,%rax,1)
  409df8:	48 83 c0 08          	add    $0x8,%rax
		farlong arrayto[ASSIGNROWS][ASSIGNCOLS])
{
ushort i,j;

for(i=0;i<ASSIGNROWS;i++)
	for(j=0;j<ASSIGNCOLS;j++)
  409dfc:	48 3d 28 03 00 00    	cmp    $0x328,%rax
  409e02:	75 ec                	jne    409df0 <DoAssign+0x460>
  409e04:	e9 94 fe ff ff       	jmpq   409c9d <DoAssign+0x30d>
LoadAssignArrayWithRand(arraybase,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  409e09:	31 c0                	xor    %eax,%eax
  409e0b:	e8 a0 23 00 00       	callq  40c1b0 <StartStopwatch>

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409e10:	48 85 ed             	test   %rbp,%rbp
LoadAssignArrayWithRand(arraybase,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  409e13:	49 89 c6             	mov    %rax,%r14

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409e16:	0f 85 b6 fe ff ff    	jne    409cd2 <DoAssign+0x342>
  409e1c:	e9 cf fe ff ff       	jmpq   409cf0 <DoAssign+0x360>
LoadAssignArrayWithRand(arraybase,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  409e21:	31 c0                	xor    %eax,%eax
  409e23:	e8 88 23 00 00       	callq  40c1b0 <StartStopwatch>

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409e28:	48 85 ed             	test   %rbp,%rbp
LoadAssignArrayWithRand(arraybase,numarrays);

/*
** Start the stopwatch
*/
elapsed=StartStopwatch();
  409e2b:	49 89 c6             	mov    %rax,%r14

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409e2e:	74 1e                	je     409e4e <DoAssign+0x4be>
	while(1)
	{
		/*
		** Allocate space for arrays
		*/
		arraybase=(farlong *) AllocateMemory(sizeof(long)*
  409e30:	49 89 dd             	mov    %rbx,%r13
  409e33:	45 31 e4             	xor    %r12d,%r12d
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        /* Fixed  by Eike Dierks */
	Assignment(*abase.ptrs.ap);
  409e36:	4c 89 ef             	mov    %r13,%rdi
elapsed=StartStopwatch();

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409e39:	49 83 c4 01          	add    $0x1,%r12
{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        /* Fixed  by Eike Dierks */
	Assignment(*abase.ptrs.ap);
	abase.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
  409e3d:	49 81 c5 c8 3e 01 00 	add    $0x13ec8,%r13
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        /* Fixed  by Eike Dierks */
	Assignment(*abase.ptrs.ap);
  409e44:	e8 d7 ad ff ff       	callq  404c20 <Assignment>
elapsed=StartStopwatch();

/*
** Execute assignment algorithms
*/
for(i=0;i<numarrays;i++)
  409e49:	4c 39 e5             	cmp    %r12,%rbp
  409e4c:	75 e8                	jne    409e36 <DoAssign+0x4a6>
}

/*
** Get elapsed time
*/
return(StopStopwatch(elapsed));
  409e4e:	4c 89 f7             	mov    %r14,%rdi
  409e51:	e8 6a 23 00 00       	callq  40c1c0 <StopStopwatch>
		** Do an iteration of the assignment alg.  If the
		** elapsed time is less than or equal to the permitted
		** minimum, then allocate for more arrays and
		** try again.
		*/
		if(DoAssignIteration(arraybase,
  409e56:	48 39 05 63 68 20 00 	cmp    %rax,0x206863(%rip)        # 6106c0 <global_min_ticks>
  409e5d:	0f 82 3d fd ff ff    	jb     409ba0 <DoAssign+0x210>
			locassignstruct->numarrays)>global_min_ticks)
			break;          /* We're ok...exit */

		FreeMemory((farvoid *)arraybase, &systemerror);
  409e63:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  409e68:	48 89 df             	mov    %rbx,%rdi
  409e6b:	e8 c0 1f 00 00       	callq  40be30 <FreeMemory>
		locassignstruct->numarrays++;
  409e70:	48 8b 05 f9 69 20 00 	mov    0x2069f9(%rip),%rax        # 610870 <global_assignstruct+0x10>
  409e77:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  409e7c:	48 83 c0 01          	add    $0x1,%rax
  409e80:	48 89 05 e9 69 20 00 	mov    %rax,0x2069e9(%rip)        # 610870 <global_assignstruct+0x10>
	}
  409e87:	e9 4d fb ff ff       	jmpq   4099d9 <DoAssign+0x49>
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)arraybase,&systemerror);

locassignstruct->iterspersec=iterations *
  409e8c:	48 89 d0             	mov    %rdx,%rax
  409e8f:	66 0f ef c0          	pxor   %xmm0,%xmm0
  409e93:	48 d1 e8             	shr    %rax
  409e96:	83 e2 01             	and    $0x1,%edx
  409e99:	48 09 d0             	or     %rdx,%rax
  409e9c:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  409ea1:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  409ea5:	e9 a0 fe ff ff       	jmpq   409d4a <DoAssign+0x3ba>
if(locassignstruct->adjust==0)
	locassignstruct->adjust=1;

return;

}
  409eaa:	e8 51 70 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  409eaf:	90                   	nop

0000000000409eb0 <DoIDEA>:
************
** Perform IDEA encryption.  Note that we time encryption & decryption
** time as being a single loop.
*/
void DoIDEA(void)
{
  409eb0:	41 57                	push   %r15
  409eb2:	41 56                	push   %r14

/*
** Re-init random-number generator.
*/
/* randnum(3L); */
randnum((int32)3);
  409eb4:	bf 03 00 00 00       	mov    $0x3,%edi
************
** Perform IDEA encryption.  Note that we time encryption & decryption
** time as being a single loop.
*/
void DoIDEA(void)
{
  409eb9:	41 55                	push   %r13
  409ebb:	41 54                	push   %r12
  409ebd:	55                   	push   %rbp
  409ebe:	53                   	push   %rbx
  409ebf:	48 81 ec a8 01 00 00 	sub    $0x1a8,%rsp
  409ec6:	48 8d 5c 24 40       	lea    0x40(%rsp),%rbx
  409ecb:	48 8d 6c 24 50       	lea    0x50(%rsp),%rbp
  409ed0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  409ed7:	00 00 
  409ed9:	48 89 84 24 98 01 00 	mov    %rax,0x198(%rsp)
  409ee0:	00 
  409ee1:	31 c0                	xor    %eax,%eax

/*
** Re-init random-number generator.
*/
/* randnum(3L); */
randnum((int32)3);
  409ee3:	e8 f8 a8 ff ff       	callq  4047e0 <randnum>
/*
** Build an encryption/decryption key
*/
for (i=0;i<8;i++)
        /* userkey[i]=(u16)(abs_randwc(60000L) & 0xFFFF); */
	userkey[i]=(u16)(abs_randwc((int32)60000) & 0xFFFF);
  409ee8:	bf 60 ea 00 00       	mov    $0xea60,%edi
  409eed:	48 83 c3 02          	add    $0x2,%rbx
  409ef1:	e8 8a a8 ff ff       	callq  404780 <abs_randwc>
  409ef6:	66 89 43 fe          	mov    %ax,-0x2(%rbx)
randnum((int32)3);

/*
** Build an encryption/decryption key
*/
for (i=0;i<8;i++)
  409efa:	48 39 eb             	cmp    %rbp,%rbx
  409efd:	75 e9                	jne    409ee8 <DoIDEA+0x38>
  409eff:	4c 8d 74 24 50       	lea    0x50(%rsp),%r14
  409f04:	31 c0                	xor    %eax,%eax
  409f06:	b9 0d 00 00 00       	mov    $0xd,%ecx
  409f0b:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
  409f10:	4c 89 f7             	mov    %r14,%rdi
  409f13:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  409f16:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  409f1b:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  409f20:	bf 2c 00 00 00       	mov    $0x2c,%edi
  409f25:	4c 89 f1             	mov    %r14,%rcx
  409f28:	31 d2                	xor    %edx,%edx
  409f2a:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
** shifts
*/
for(j=0;j<8;j++)
	Z[j]=*userkey++;
for(i=0;j<KEYLEN;j++)
{       i++;
  409f2f:	8d 42 01             	lea    0x1(%rdx),%eax
	Z[i+7]=(Z[i&7]<<9)| (Z[(i+1) & 7] >> 7);
  409f32:	83 c2 02             	add    $0x2,%edx
  409f35:	83 e2 07             	and    $0x7,%edx
  409f38:	0f b7 14 51          	movzwl (%rcx,%rdx,2),%edx
  409f3c:	41 89 c0             	mov    %eax,%r8d
  409f3f:	4c 63 c8             	movslq %eax,%r9
  409f42:	41 83 e0 07          	and    $0x7,%r8d
	Z+=i&8;
  409f46:	83 e0 08             	and    $0x8,%eax
  409f49:	48 98                	cltq   
*/
for(j=0;j<8;j++)
	Z[j]=*userkey++;
for(i=0;j<KEYLEN;j++)
{       i++;
	Z[i+7]=(Z[i&7]<<9)| (Z[(i+1) & 7] >> 7);
  409f4b:	66 c1 ea 07          	shr    $0x7,%dx
  409f4f:	89 d6                	mov    %edx,%esi
  409f51:	49 63 d0             	movslq %r8d,%rdx
  409f54:	0f b7 14 51          	movzwl (%rcx,%rdx,2),%edx
  409f58:	c1 e2 09             	shl    $0x9,%edx
  409f5b:	09 f2                	or     %esi,%edx
/*
** shifts
*/
for(j=0;j<8;j++)
	Z[j]=*userkey++;
for(i=0;j<KEYLEN;j++)
  409f5d:	83 ef 01             	sub    $0x1,%edi
{       i++;
	Z[i+7]=(Z[i&7]<<9)| (Z[(i+1) & 7] >> 7);
  409f60:	66 42 89 54 49 0e    	mov    %dx,0xe(%rcx,%r9,2)
	Z+=i&8;
  409f66:	48 8d 0c 41          	lea    (%rcx,%rax,2),%rcx
	i&=7;
  409f6a:	44 89 c2             	mov    %r8d,%edx
/*
** shifts
*/
for(j=0;j<8;j++)
	Z[j]=*userkey++;
for(i=0;j<KEYLEN;j++)
  409f6d:	75 c0                	jne    409f2f <DoIDEA+0x7f>
int j;
u16 t1, t2, t3;
u16 *p;
p=(u16 *)(TT+KEYLEN);

t1=inv(*Z++);
  409f6f:	0f b7 4c 24 50       	movzwl 0x50(%rsp),%ecx
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  409f74:	66 83 f9 01          	cmp    $0x1,%cx
  409f78:	0f 86 3e 08 00 00    	jbe    40a7bc <DoIDEA+0x90c>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  409f7e:	b8 01 00 01 00       	mov    $0x10001,%eax
  409f83:	0f b7 f1             	movzwl %cx,%esi
y=0x10001 % x;
if(y==1)
  409f86:	bf 01 00 00 00       	mov    $0x1,%edi
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  409f8b:	99                   	cltd   
  409f8c:	f7 fe                	idiv   %esi
y=0x10001 % x;
if(y==1)
  409f8e:	83 fa 01             	cmp    $0x1,%edx
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  409f91:	41 89 c0             	mov    %eax,%r8d
y=0x10001 % x;
  409f94:	89 d6                	mov    %edx,%esi
if(y==1)
  409f96:	75 21                	jne    409fb9 <DoIDEA+0x109>
  409f98:	e9 66 08 00 00       	jmpq   40a803 <DoIDEA+0x953>
  409f9d:	0f 1f 00             	nopl   (%rax)
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  409fa0:	89 f0                	mov    %esi,%eax
  409fa2:	31 d2                	xor    %edx,%edx
  409fa4:	66 f7 f1             	div    %cx
	t1+=q*t0;
  409fa7:	0f af c7             	imul   %edi,%eax
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  409faa:	89 d6                	mov    %edx,%esi
	t1+=q*t0;
  409fac:	41 01 c0             	add    %eax,%r8d
} while(y!=1);
  409faf:	66 83 fa 01          	cmp    $0x1,%dx
  409fb3:	0f 84 85 07 00 00    	je     40a73e <DoIDEA+0x88e>
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  409fb9:	89 c8                	mov    %ecx,%eax
  409fbb:	31 d2                	xor    %edx,%edx
  409fbd:	66 f7 f6             	div    %si
	t0+=q*t1;
  409fc0:	41 0f af c0          	imul   %r8d,%eax
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  409fc4:	89 d1                	mov    %edx,%ecx
	t0+=q*t1;
  409fc6:	01 c7                	add    %eax,%edi
	if(x==1) return(t0);
  409fc8:	66 83 fa 01          	cmp    $0x1,%dx
  409fcc:	75 d2                	jne    409fa0 <DoIDEA+0xf0>
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
	t0+=q*t1;
  409fce:	41 89 f8             	mov    %edi,%r8d
u16 t1, t2, t3;
u16 *p;
p=(u16 *)(TT+KEYLEN);

t1=inv(*Z++);
t2=-*Z++;
  409fd1:	44 0f b7 54 24 52    	movzwl 0x52(%rsp),%r10d
t3=-*Z++;
  409fd7:	44 0f b7 5c 24 54    	movzwl 0x54(%rsp),%r11d
*--p=inv(*Z++);
  409fdd:	0f b7 4c 24 56       	movzwl 0x56(%rsp),%ecx
u16 t1, t2, t3;
u16 *p;
p=(u16 *)(TT+KEYLEN);

t1=inv(*Z++);
t2=-*Z++;
  409fe2:	41 f7 da             	neg    %r10d
t3=-*Z++;
  409fe5:	41 f7 db             	neg    %r11d
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  409fe8:	66 83 f9 01          	cmp    $0x1,%cx
  409fec:	0f 86 d2 07 00 00    	jbe    40a7c4 <DoIDEA+0x914>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  409ff2:	b8 01 00 01 00       	mov    $0x10001,%eax
  409ff7:	0f b7 f1             	movzwl %cx,%esi
y=0x10001 % x;
if(y==1)
  409ffa:	bf 01 00 00 00       	mov    $0x1,%edi
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  409fff:	99                   	cltd   
  40a000:	f7 fe                	idiv   %esi
y=0x10001 % x;
if(y==1)
  40a002:	83 fa 01             	cmp    $0x1,%edx
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a005:	41 89 c1             	mov    %eax,%r9d
y=0x10001 % x;
  40a008:	89 d6                	mov    %edx,%esi
if(y==1)
  40a00a:	75 25                	jne    40a031 <DoIDEA+0x181>
  40a00c:	e9 da 07 00 00       	jmpq   40a7eb <DoIDEA+0x93b>
  40a011:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a018:	89 f0                	mov    %esi,%eax
  40a01a:	31 d2                	xor    %edx,%edx
  40a01c:	66 f7 f1             	div    %cx
	t1+=q*t0;
  40a01f:	0f af c7             	imul   %edi,%eax
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a022:	89 d6                	mov    %edx,%esi
	t1+=q*t0;
  40a024:	41 01 c1             	add    %eax,%r9d
} while(y!=1);
  40a027:	66 83 fa 01          	cmp    $0x1,%dx
  40a02b:	0f 84 18 07 00 00    	je     40a749 <DoIDEA+0x899>
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a031:	89 c8                	mov    %ecx,%eax
  40a033:	31 d2                	xor    %edx,%edx
  40a035:	66 f7 f6             	div    %si
	t0+=q*t1;
  40a038:	41 0f af c1          	imul   %r9d,%eax
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a03c:	89 d1                	mov    %edx,%ecx
	t0+=q*t1;
  40a03e:	01 c7                	add    %eax,%edi
	if(x==1) return(t0);
  40a040:	66 83 fa 01          	cmp    $0x1,%dx
  40a044:	75 d2                	jne    40a018 <DoIDEA+0x168>
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
*--p=t3;
*--p=t2;
*--p=t1;
  40a046:	48 8d 84 24 30 01 00 	lea    0x130(%rsp),%rax
  40a04d:	00 

t1=inv(*Z++);
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
*--p=t3;
  40a04e:	66 44 89 9c 24 94 01 	mov    %r11w,0x194(%rsp)
  40a055:	00 00 
*--p=t2;
  40a057:	66 44 89 94 24 92 01 	mov    %r10w,0x192(%rsp)
  40a05e:	00 00 
p=(u16 *)(TT+KEYLEN);

t1=inv(*Z++);
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
  40a060:	4d 8d 5e 08          	lea    0x8(%r14),%r11
*--p=t3;
*--p=t2;
*--p=t1;
  40a064:	4c 8d 94 24 90 01 00 	lea    0x190(%rsp),%r10
  40a06b:	00 
p=(u16 *)(TT+KEYLEN);

t1=inv(*Z++);
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
  40a06c:	66 89 bc 24 96 01 00 	mov    %di,0x196(%rsp)
  40a073:	00 
*--p=t3;
*--p=t2;
*--p=t1;

for(j=1;j<ROUNDS;j++)
  40a074:	48 8d 68 0c          	lea    0xc(%rax),%rbp
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
*--p=t3;
*--p=t2;
*--p=t1;
  40a078:	66 44 89 84 24 90 01 	mov    %r8w,0x190(%rsp)
  40a07f:	00 00 
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a081:	bb 01 00 01 00       	mov    $0x10001,%ebx
y=0x10001 % x;
if(y==1)
	return(low16(1-t1));
  40a086:	41 bc 01 00 00 00    	mov    $0x1,%r12d

for(j=1;j<ROUNDS;j++)
{       t1=*Z++;
	*--p=*Z++;
	*--p=t1;
	t1=inv(*Z++);
  40a08c:	41 0f b7 4b 04       	movzwl 0x4(%r11),%ecx
*--p=t3;
*--p=t2;
*--p=t1;

for(j=1;j<ROUNDS;j++)
{       t1=*Z++;
  40a091:	41 0f b7 03          	movzwl (%r11),%eax
	*--p=*Z++;
  40a095:	41 0f b7 53 02       	movzwl 0x2(%r11),%edx
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a09a:	66 83 f9 01          	cmp    $0x1,%cx
*--p=t1;

for(j=1;j<ROUNDS;j++)
{       t1=*Z++;
	*--p=*Z++;
	*--p=t1;
  40a09e:	66 41 89 42 fc       	mov    %ax,-0x4(%r10)
*--p=t2;
*--p=t1;

for(j=1;j<ROUNDS;j++)
{       t1=*Z++;
	*--p=*Z++;
  40a0a3:	66 41 89 52 fe       	mov    %dx,-0x2(%r10)
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a0a8:	0f 86 cf 05 00 00    	jbe    40a67d <DoIDEA+0x7cd>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a0ae:	89 d8                	mov    %ebx,%eax
  40a0b0:	0f b7 f1             	movzwl %cx,%esi
y=0x10001 % x;
if(y==1)
  40a0b3:	bf 01 00 00 00       	mov    $0x1,%edi
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a0b8:	99                   	cltd   
  40a0b9:	f7 fe                	idiv   %esi
y=0x10001 % x;
if(y==1)
  40a0bb:	83 fa 01             	cmp    $0x1,%edx
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a0be:	41 89 c0             	mov    %eax,%r8d
y=0x10001 % x;
  40a0c1:	89 d6                	mov    %edx,%esi
if(y==1)
  40a0c3:	75 24                	jne    40a0e9 <DoIDEA+0x239>
  40a0c5:	e9 ba 05 00 00       	jmpq   40a684 <DoIDEA+0x7d4>
  40a0ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a0d0:	89 f0                	mov    %esi,%eax
  40a0d2:	31 d2                	xor    %edx,%edx
  40a0d4:	66 f7 f1             	div    %cx
	t1+=q*t0;
  40a0d7:	0f af c7             	imul   %edi,%eax
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a0da:	89 d6                	mov    %edx,%esi
	t1+=q*t0;
  40a0dc:	41 01 c0             	add    %eax,%r8d
} while(y!=1);
  40a0df:	66 83 fa 01          	cmp    $0x1,%dx
  40a0e3:	0f 84 7b 05 00 00    	je     40a664 <DoIDEA+0x7b4>
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a0e9:	89 c8                	mov    %ecx,%eax
  40a0eb:	31 d2                	xor    %edx,%edx
  40a0ed:	66 f7 f6             	div    %si
	t0+=q*t1;
  40a0f0:	41 0f af c0          	imul   %r8d,%eax
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a0f4:	89 d1                	mov    %edx,%ecx
	t0+=q*t1;
  40a0f6:	01 c7                	add    %eax,%edi
	if(x==1) return(t0);
  40a0f8:	66 83 fa 01          	cmp    $0x1,%dx
  40a0fc:	75 d2                	jne    40a0d0 <DoIDEA+0x220>
for(j=1;j<ROUNDS;j++)
{       t1=*Z++;
	*--p=*Z++;
	*--p=t1;
	t1=inv(*Z++);
	t2=-*Z++;
  40a0fe:	45 0f b7 7b 06       	movzwl 0x6(%r11),%r15d
	t3=-*Z++;
  40a103:	45 0f b7 6b 08       	movzwl 0x8(%r11),%r13d
  40a108:	49 83 c3 0c          	add    $0xc,%r11
	*--p=inv(*Z++);
  40a10c:	41 0f b7 4b fe       	movzwl -0x2(%r11),%ecx
for(j=1;j<ROUNDS;j++)
{       t1=*Z++;
	*--p=*Z++;
	*--p=t1;
	t1=inv(*Z++);
	t2=-*Z++;
  40a111:	41 f7 df             	neg    %r15d
	t3=-*Z++;
  40a114:	41 f7 dd             	neg    %r13d
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a117:	66 83 f9 01          	cmp    $0x1,%cx
  40a11b:	76 56                	jbe    40a173 <DoIDEA+0x2c3>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a11d:	89 d8                	mov    %ebx,%eax
  40a11f:	0f b7 f1             	movzwl %cx,%esi
y=0x10001 % x;
if(y==1)
  40a122:	41 b8 01 00 00 00    	mov    $0x1,%r8d
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a128:	99                   	cltd   
  40a129:	f7 fe                	idiv   %esi
y=0x10001 % x;
if(y==1)
  40a12b:	83 fa 01             	cmp    $0x1,%edx
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a12e:	41 89 c1             	mov    %eax,%r9d
y=0x10001 % x;
  40a131:	89 d6                	mov    %edx,%esi
if(y==1)
  40a133:	75 25                	jne    40a15a <DoIDEA+0x2aa>
  40a135:	e9 54 05 00 00       	jmpq   40a68e <DoIDEA+0x7de>
  40a13a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a140:	89 f0                	mov    %esi,%eax
  40a142:	31 d2                	xor    %edx,%edx
  40a144:	66 f7 f1             	div    %cx
	t1+=q*t0;
  40a147:	41 0f af c0          	imul   %r8d,%eax
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a14b:	89 d6                	mov    %edx,%esi
	t1+=q*t0;
  40a14d:	41 01 c1             	add    %eax,%r9d
} while(y!=1);
  40a150:	66 83 fa 01          	cmp    $0x1,%dx
  40a154:	0f 84 00 05 00 00    	je     40a65a <DoIDEA+0x7aa>
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a15a:	89 c8                	mov    %ecx,%eax
  40a15c:	31 d2                	xor    %edx,%edx
  40a15e:	66 f7 f6             	div    %si
	t0+=q*t1;
  40a161:	41 0f af c1          	imul   %r9d,%eax
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a165:	89 d1                	mov    %edx,%ecx
	t0+=q*t1;
  40a167:	41 01 c0             	add    %eax,%r8d
	if(x==1) return(t0);
  40a16a:	66 83 fa 01          	cmp    $0x1,%dx
  40a16e:	75 d0                	jne    40a140 <DoIDEA+0x290>
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
	t0+=q*t1;
  40a170:	44 89 c1             	mov    %r8d,%ecx
	*--p=*Z++;
	*--p=t1;
	t1=inv(*Z++);
	t2=-*Z++;
	t3=-*Z++;
	*--p=inv(*Z++);
  40a173:	66 41 89 4a fa       	mov    %cx,-0x6(%r10)
	*--p=t2;
  40a178:	66 45 89 7a f8       	mov    %r15w,-0x8(%r10)
  40a17d:	49 83 ea 0c          	sub    $0xc,%r10
	*--p=t3;
  40a181:	66 45 89 6a 02       	mov    %r13w,0x2(%r10)
*--p=inv(*Z++);
*--p=t3;
*--p=t2;
*--p=t1;

for(j=1;j<ROUNDS;j++)
  40a186:	49 39 ea             	cmp    %rbp,%r10
	t2=-*Z++;
	t3=-*Z++;
	*--p=inv(*Z++);
	*--p=t2;
	*--p=t3;
	*--p=t1;
  40a189:	66 41 89 3a          	mov    %di,(%r10)
*--p=inv(*Z++);
*--p=t3;
*--p=t2;
*--p=t1;

for(j=1;j<ROUNDS;j++)
  40a18d:	0f 85 f9 fe ff ff    	jne    40a08c <DoIDEA+0x1dc>
	*--p=t2;
	*--p=t3;
	*--p=t1;
}
t1=*Z++;
*--p=*Z++;
  40a193:	0f b7 84 24 ae 00 00 	movzwl 0xae(%rsp),%eax
  40a19a:	00 
*--p=t1;
t1=inv(*Z++);
  40a19b:	0f b7 8c 24 b0 00 00 	movzwl 0xb0(%rsp),%ecx
  40a1a2:	00 
	*--p=t2;
	*--p=t3;
	*--p=t1;
}
t1=*Z++;
*--p=*Z++;
  40a1a3:	66 89 84 24 3a 01 00 	mov    %ax,0x13a(%rsp)
  40a1aa:	00 
*--p=t1;
  40a1ab:	0f b7 84 24 ac 00 00 	movzwl 0xac(%rsp),%eax
  40a1b2:	00 
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a1b3:	66 83 f9 01          	cmp    $0x1,%cx
	*--p=t3;
	*--p=t1;
}
t1=*Z++;
*--p=*Z++;
*--p=t1;
  40a1b7:	66 89 84 24 38 01 00 	mov    %ax,0x138(%rsp)
  40a1be:	00 
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a1bf:	0f 86 1e 06 00 00    	jbe    40a7e3 <DoIDEA+0x933>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a1c5:	b8 01 00 01 00       	mov    $0x10001,%eax
  40a1ca:	0f b7 f1             	movzwl %cx,%esi
y=0x10001 % x;
if(y==1)
  40a1cd:	bf 01 00 00 00       	mov    $0x1,%edi
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a1d2:	99                   	cltd   
  40a1d3:	f7 fe                	idiv   %esi
y=0x10001 % x;
if(y==1)
  40a1d5:	83 fa 01             	cmp    $0x1,%edx
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a1d8:	41 89 c0             	mov    %eax,%r8d
y=0x10001 % x;
  40a1db:	89 d6                	mov    %edx,%esi
if(y==1)
  40a1dd:	75 22                	jne    40a201 <DoIDEA+0x351>
  40a1df:	e9 0e 06 00 00       	jmpq   40a7f2 <DoIDEA+0x942>
  40a1e4:	0f 1f 40 00          	nopl   0x0(%rax)
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a1e8:	89 f0                	mov    %esi,%eax
  40a1ea:	31 d2                	xor    %edx,%edx
  40a1ec:	66 f7 f1             	div    %cx
	t1+=q*t0;
  40a1ef:	0f af c7             	imul   %edi,%eax
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a1f2:	89 d6                	mov    %edx,%esi
	t1+=q*t0;
  40a1f4:	41 01 c0             	add    %eax,%r8d
} while(y!=1);
  40a1f7:	66 83 fa 01          	cmp    $0x1,%dx
  40a1fb:	0f 84 28 05 00 00    	je     40a729 <DoIDEA+0x879>
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a201:	89 c8                	mov    %ecx,%eax
  40a203:	31 d2                	xor    %edx,%edx
  40a205:	66 f7 f6             	div    %si
	t0+=q*t1;
  40a208:	41 0f af c0          	imul   %r8d,%eax
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a20c:	89 d1                	mov    %edx,%ecx
	t0+=q*t1;
  40a20e:	01 c7                	add    %eax,%edi
	if(x==1) return(t0);
  40a210:	66 83 fa 01          	cmp    $0x1,%dx
  40a214:	75 d2                	jne    40a1e8 <DoIDEA+0x338>
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
	t0+=q*t1;
  40a216:	41 89 f8             	mov    %edi,%r8d
}
t1=*Z++;
*--p=*Z++;
*--p=t1;
t1=inv(*Z++);
t2=-*Z++;
  40a219:	44 0f b7 94 24 b2 00 	movzwl 0xb2(%rsp),%r10d
  40a220:	00 00 
t3=-*Z++;
  40a222:	44 0f b7 9c 24 b4 00 	movzwl 0xb4(%rsp),%r11d
  40a229:	00 00 
*--p=inv(*Z++);
  40a22b:	0f b7 8c 24 b6 00 00 	movzwl 0xb6(%rsp),%ecx
  40a232:	00 
}
t1=*Z++;
*--p=*Z++;
*--p=t1;
t1=inv(*Z++);
t2=-*Z++;
  40a233:	41 f7 da             	neg    %r10d
t3=-*Z++;
  40a236:	41 f7 db             	neg    %r11d
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a239:	66 83 f9 01          	cmp    $0x1,%cx
  40a23d:	0f 86 99 05 00 00    	jbe    40a7dc <DoIDEA+0x92c>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a243:	b8 01 00 01 00       	mov    $0x10001,%eax
  40a248:	0f b7 f1             	movzwl %cx,%esi
y=0x10001 % x;
if(y==1)
  40a24b:	bf 01 00 00 00       	mov    $0x1,%edi
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a250:	99                   	cltd   
  40a251:	f7 fe                	idiv   %esi
y=0x10001 % x;
if(y==1)
  40a253:	83 fa 01             	cmp    $0x1,%edx
u16 t0, t1;
u16 q, y;

if(x<=1)
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
  40a256:	41 89 c1             	mov    %eax,%r9d
y=0x10001 % x;
  40a259:	89 d6                	mov    %edx,%esi
if(y==1)
  40a25b:	75 24                	jne    40a281 <DoIDEA+0x3d1>
  40a25d:	e9 9a 05 00 00       	jmpq   40a7fc <DoIDEA+0x94c>
  40a262:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a268:	89 f0                	mov    %esi,%eax
  40a26a:	31 d2                	xor    %edx,%edx
  40a26c:	66 f7 f1             	div    %cx
	t1+=q*t0;
  40a26f:	0f af c7             	imul   %edi,%eax
	q=x/y;
	x=x%y;
	t0+=q*t1;
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
  40a272:	89 d6                	mov    %edx,%esi
	t1+=q*t0;
  40a274:	41 01 c1             	add    %eax,%r9d
} while(y!=1);
  40a277:	66 83 fa 01          	cmp    $0x1,%dx
  40a27b:	0f 84 b3 04 00 00    	je     40a734 <DoIDEA+0x884>
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a281:	89 c8                	mov    %ecx,%eax
  40a283:	31 d2                	xor    %edx,%edx
  40a285:	66 f7 f6             	div    %si
	t0+=q*t1;
  40a288:	41 0f af c1          	imul   %r9d,%eax
if(y==1)
	return(low16(1-t1));
t0=1;
do {
	q=x/y;
	x=x%y;
  40a28c:	89 d1                	mov    %edx,%ecx
	t0+=q*t1;
  40a28e:	01 c7                	add    %eax,%edi
	if(x==1) return(t0);
  40a290:	66 83 fa 01          	cmp    $0x1,%dx
  40a294:	75 d2                	jne    40a268 <DoIDEA+0x3b8>
*--p=t1;
/*
** Copy and destroy temp copy
*/
for(j=0,p=TT;j<KEYLEN;j++)
{       *DK++=*p;
  40a296:	0f b7 84 24 90 01 00 	movzwl 0x190(%rsp),%eax
  40a29d:	00 
*--p=*Z++;
*--p=t1;
t1=inv(*Z++);
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
  40a29e:	66 89 bc 24 36 01 00 	mov    %di,0x136(%rsp)
  40a2a5:	00 
** crypt1, and plain2.  It works like this:
**   plain1 >>encrypt>> crypt1 >>decrypt>> plain2.
** So, plain1 and plain2 should match.
** Also, fill up plain1 with sample text.
*/
plain1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a2a6:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
*--p=t1;
t1=inv(*Z++);
t2=-*Z++;
t3=-*Z++;
*--p=inv(*Z++);
*--p=t3;
  40a2ab:	66 44 89 9c 24 34 01 	mov    %r11w,0x134(%rsp)
  40a2b2:	00 00 
*--p=t2;
  40a2b4:	66 44 89 94 24 32 01 	mov    %r10w,0x132(%rsp)
  40a2bb:	00 00 
*--p=t1;
  40a2bd:	66 44 89 84 24 30 01 	mov    %r8w,0x130(%rsp)
  40a2c4:	00 00 
** crypt1, and plain2.  It works like this:
**   plain1 >>encrypt>> crypt1 >>decrypt>> plain2.
** So, plain1 and plain2 should match.
** Also, fill up plain1 with sample text.
*/
plain1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a2c6:	48 8b 3d e3 64 20 00 	mov    0x2064e3(%rip),%rdi        # 6107b0 <global_ideastruct+0x10>
*--p=t1;
/*
** Copy and destroy temp copy
*/
for(j=0,p=TT;j<KEYLEN;j++)
{       *DK++=*p;
  40a2cd:	66 0f 6f 84 24 30 01 	movdqa 0x130(%rsp),%xmm0
  40a2d4:	00 00 
  40a2d6:	66 89 84 24 20 01 00 	mov    %ax,0x120(%rsp)
  40a2dd:	00 
  40a2de:	0f b7 84 24 92 01 00 	movzwl 0x192(%rsp),%eax
  40a2e5:	00 
  40a2e6:	0f 29 84 24 c0 00 00 	movaps %xmm0,0xc0(%rsp)
  40a2ed:	00 
  40a2ee:	66 0f 6f 84 24 40 01 	movdqa 0x140(%rsp),%xmm0
  40a2f5:	00 00 
  40a2f7:	66 89 84 24 22 01 00 	mov    %ax,0x122(%rsp)
  40a2fe:	00 
  40a2ff:	0f b7 84 24 94 01 00 	movzwl 0x194(%rsp),%eax
  40a306:	00 
  40a307:	0f 29 84 24 d0 00 00 	movaps %xmm0,0xd0(%rsp)
  40a30e:	00 
  40a30f:	66 0f 6f 84 24 50 01 	movdqa 0x150(%rsp),%xmm0
  40a316:	00 00 
  40a318:	66 89 84 24 24 01 00 	mov    %ax,0x124(%rsp)
  40a31f:	00 
  40a320:	0f b7 84 24 96 01 00 	movzwl 0x196(%rsp),%eax
  40a327:	00 
  40a328:	0f 29 84 24 e0 00 00 	movaps %xmm0,0xe0(%rsp)
  40a32f:	00 
  40a330:	66 0f 6f 84 24 60 01 	movdqa 0x160(%rsp),%xmm0
  40a337:	00 00 
  40a339:	66 89 84 24 26 01 00 	mov    %ax,0x126(%rsp)
  40a340:	00 
  40a341:	0f 29 84 24 f0 00 00 	movaps %xmm0,0xf0(%rsp)
  40a348:	00 
  40a349:	66 0f 6f 84 24 70 01 	movdqa 0x170(%rsp),%xmm0
  40a350:	00 00 
  40a352:	0f 29 84 24 00 01 00 	movaps %xmm0,0x100(%rsp)
  40a359:	00 
  40a35a:	66 0f 6f 84 24 80 01 	movdqa 0x180(%rsp),%xmm0
  40a361:	00 00 
  40a363:	0f 29 84 24 10 01 00 	movaps %xmm0,0x110(%rsp)
  40a36a:	00 
** crypt1, and plain2.  It works like this:
**   plain1 >>encrypt>> crypt1 >>decrypt>> plain2.
** So, plain1 and plain2 should match.
** Also, fill up plain1 with sample text.
*/
plain1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a36b:	e8 c0 19 00 00       	callq  40bd30 <AllocateMemory>
  40a370:	49 89 c4             	mov    %rax,%r12
if(systemerror)
  40a373:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
  40a377:	85 f6                	test   %esi,%esi
  40a379:	0f 85 27 04 00 00    	jne    40a7a6 <DoIDEA+0x8f6>
{
	ReportError(errorcontext,systemerror);
	ErrorExit();
}

crypt1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a37f:	48 8b 3d 2a 64 20 00 	mov    0x20642a(%rip),%rdi        # 6107b0 <global_ideastruct+0x10>
  40a386:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a38b:	e8 a0 19 00 00       	callq  40bd30 <AllocateMemory>
if(systemerror)
  40a390:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
{
	ReportError(errorcontext,systemerror);
	ErrorExit();
}

crypt1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a394:	48 89 c5             	mov    %rax,%rbp
if(systemerror)
  40a397:	85 f6                	test   %esi,%esi
  40a399:	0f 85 e4 03 00 00    	jne    40a783 <DoIDEA+0x8d3>
	ReportError(errorcontext,systemerror);
	FreeMemory((farvoid *)plain1,&systemerror);
	ErrorExit();
}

plain2=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a39f:	48 8b 3d 0a 64 20 00 	mov    0x20640a(%rip),%rdi        # 6107b0 <global_ideastruct+0x10>
  40a3a6:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a3ab:	e8 80 19 00 00       	callq  40bd30 <AllocateMemory>
if(systemerror)
  40a3b0:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
	ReportError(errorcontext,systemerror);
	FreeMemory((farvoid *)plain1,&systemerror);
	ErrorExit();
}

plain2=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
  40a3b4:	49 89 c5             	mov    %rax,%r13
if(systemerror)
  40a3b7:	85 f6                	test   %esi,%esi
  40a3b9:	0f 85 94 03 00 00    	jne    40a753 <DoIDEA+0x8a3>
}
/*
** Note that we build the "plaintext" by simply loading
** the array up with random numbers.
*/
for(i=0;i<locideastruct->arraysize;i++)
  40a3bf:	48 8b 1d ea 63 20 00 	mov    0x2063ea(%rip),%rbx        # 6107b0 <global_ideastruct+0x10>
  40a3c6:	48 85 db             	test   %rbx,%rbx
  40a3c9:	74 21                	je     40a3ec <DoIDEA+0x53c>
  40a3cb:	45 31 ff             	xor    %r15d,%r15d
	plain1[i]=(uchar)(abs_randwc(255) & 0xFF);
  40a3ce:	bf ff 00 00 00       	mov    $0xff,%edi
  40a3d3:	e8 a8 a3 ff ff       	callq  404780 <abs_randwc>
  40a3d8:	43 88 04 3c          	mov    %al,(%r12,%r15,1)
}
/*
** Note that we build the "plaintext" by simply loading
** the array up with random numbers.
*/
for(i=0;i<locideastruct->arraysize;i++)
  40a3dc:	48 8b 1d cd 63 20 00 	mov    0x2063cd(%rip),%rbx        # 6107b0 <global_ideastruct+0x10>
  40a3e3:	49 83 c7 01          	add    $0x1,%r15
  40a3e7:	4c 39 fb             	cmp    %r15,%rbx
  40a3ea:	77 e2                	ja     40a3ce <DoIDEA+0x51e>
	plain1[i]=(uchar)(abs_randwc(255) & 0xFF);

/*
** See if we need to perform self adjustment loop.
*/
if(locideastruct->adjust==0)
  40a3ec:	8b 05 ae 63 20 00    	mov    0x2063ae(%rip),%eax        # 6107a0 <global_ideastruct>
  40a3f2:	85 c0                	test   %eax,%eax
  40a3f4:	0f 85 1e 03 00 00    	jne    40a718 <DoIDEA+0x868>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locideastruct->loops=100L;
  40a3fa:	48 c7 05 b3 63 20 00 	movq   $0x64,0x2063b3(%rip)        # 6107b8 <global_ideastruct+0x18>
  40a401:	64 00 00 00 
}
/*
** Note that we build the "plaintext" by simply loading
** the array up with random numbers.
*/
for(i=0;i<locideastruct->arraysize;i++)
  40a405:	48 c7 44 24 10 64 00 	movq   $0x64,0x10(%rsp)
  40a40c:	00 00 
#endif

/*
** Start the stopwatch.
*/
elapsed=StartStopwatch();
  40a40e:	31 c0                	xor    %eax,%eax
  40a410:	e8 9b 1d 00 00       	callq  40c1b0 <StartStopwatch>

/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
  40a415:	48 83 7c 24 10 00    	cmpq   $0x0,0x10(%rsp)
#endif

/*
** Start the stopwatch.
*/
elapsed=StartStopwatch();
  40a41b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
  40a420:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  40a427:	00 00 
  40a429:	74 67                	je     40a492 <DoIDEA+0x5e2>
  40a42b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a430:	45 31 ff             	xor    %r15d,%r15d
  40a433:	48 85 db             	test   %rbx,%rbx
  40a436:	74 48                	je     40a480 <DoIDEA+0x5d0>
  40a438:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40a43f:	00 
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */
  40a440:	4a 8d 74 3d 00       	lea    0x0(%rbp,%r15,1),%rsi
  40a445:	4b 8d 3c 3c          	lea    (%r12,%r15,1),%rdi
  40a449:	4c 89 f2             	mov    %r14,%rdx
/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a44c:	49 83 c7 08          	add    $0x8,%r15
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */
  40a450:	e8 ab d4 ff ff       	callq  407900 <cipher_idea>
/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a455:	49 39 df             	cmp    %rbx,%r15
  40a458:	72 e6                	jb     40a440 <DoIDEA+0x590>
  40a45a:	45 31 ff             	xor    %r15d,%r15d
  40a45d:	0f 1f 00             	nopl   (%rax)
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */

	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
  40a460:	4b 8d 74 3d 00       	lea    0x0(%r13,%r15,1),%rsi
  40a465:	4a 8d 7c 3d 00       	lea    0x0(%rbp,%r15,1),%rdi
  40a46a:	48 8d 94 24 c0 00 00 	lea    0xc0(%rsp),%rdx
  40a471:	00 
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */

	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a472:	49 83 c7 08          	add    $0x8,%r15
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
  40a476:	e8 85 d4 ff ff       	callq  407900 <cipher_idea>
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */

	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a47b:	49 39 df             	cmp    %rbx,%r15
  40a47e:	72 e0                	jb     40a460 <DoIDEA+0x5b0>
elapsed=StartStopwatch();

/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
  40a480:	48 83 44 24 08 01    	addq   $0x1,0x8(%rsp)
  40a486:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40a48b:	48 39 44 24 10       	cmp    %rax,0x10(%rsp)
  40a490:	75 9e                	jne    40a430 <DoIDEA+0x580>
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
}

#ifdef DEBUG
for(j=0;j<arraysize;j++)
  40a492:	31 c0                	xor    %eax,%eax
  40a494:	45 31 ff             	xor    %r15d,%r15d
  40a497:	48 85 db             	test   %rbx,%rbx
  40a49a:	0f 84 ce 01 00 00    	je     40a66e <DoIDEA+0x7be>
	if(*(plain1+j)!=*(plain2+j)){
  40a4a0:	43 0f b6 4c 3d 00    	movzbl 0x0(%r13,%r15,1),%ecx
  40a4a6:	43 38 0c 3c          	cmp    %cl,(%r12,%r15,1)
  40a4aa:	74 0f                	je     40a4bb <DoIDEA+0x60b>
  40a4ac:	bf 20 df 40 00       	mov    $0x40df20,%edi
  40a4b1:	e8 da 69 ff ff       	callq  400e90 <puts@plt>
		printf("IDEA Error! \n");
                status=1;
  40a4b6:	b8 01 00 00 00       	mov    $0x1,%eax
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
}

#ifdef DEBUG
for(j=0;j<arraysize;j++)
  40a4bb:	49 83 c7 01          	add    $0x1,%r15
  40a4bf:	49 39 df             	cmp    %rbx,%r15
  40a4c2:	75 dc                	jne    40a4a0 <DoIDEA+0x5f0>
	if(*(plain1+j)!=*(plain2+j)){
		printf("IDEA Error! \n");
                status=1;
                }
if (status==0) printf("IDEA: OK\n");
  40a4c4:	85 c0                	test   %eax,%eax
  40a4c6:	0f 84 a2 01 00 00    	je     40a66e <DoIDEA+0x7be>
#endif

/*
** Get elapsed time.
*/
return(StopStopwatch(elapsed));
  40a4cc:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40a4d1:	e8 ea 1c 00 00       	callq  40c1c0 <StopStopwatch>
	** get a number of loops that we can use.
	*/
	for(locideastruct->loops=100L;
	  locideastruct->loops<MAXIDEALOOPS;
	  locideastruct->loops+=10L)
		if(DoIDEAIteration(plain1,crypt1,plain2,
  40a4d6:	48 39 05 e3 61 20 00 	cmp    %rax,0x2061e3(%rip)        # 6106c0 <global_min_ticks>
  40a4dd:	48 8b 05 d4 62 20 00 	mov    0x2062d4(%rip),%rax        # 6107b8 <global_ideastruct+0x18>
  40a4e4:	0f 82 e1 02 00 00    	jb     40a7cb <DoIDEA+0x91b>
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locideastruct->loops=100L;
	  locideastruct->loops<MAXIDEALOOPS;
	  locideastruct->loops+=10L)
  40a4ea:	48 83 c0 0a          	add    $0xa,%rax
  40a4ee:	48 8b 1d bb 62 20 00 	mov    0x2062bb(%rip),%rbx        # 6107b0 <global_ideastruct+0x10>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locideastruct->loops=100L;
  40a4f5:	48 3d 1f a1 07 00    	cmp    $0x7a11f,%rax
	  locideastruct->loops<MAXIDEALOOPS;
	  locideastruct->loops+=10L)
  40a4fb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40a500:	48 89 05 b1 62 20 00 	mov    %rax,0x2062b1(%rip)        # 6107b8 <global_ideastruct+0x18>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locideastruct->loops=100L;
  40a507:	0f 86 01 ff ff ff    	jbe    40a40e <DoIDEA+0x55e>

#ifdef DEBUG
for(j=0;j<arraysize;j++)
	if(*(plain1+j)!=*(plain2+j)){
		printf("IDEA Error! \n");
                status=1;
  40a50d:	66 0f ef db          	pxor   %xmm3,%xmm3
  40a511:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
  40a518:	00 00 
  40a51a:	f2 0f 11 5c 24 20    	movsd  %xmm3,0x20(%rsp)
#endif

/*
** Start the stopwatch.
*/
elapsed=StartStopwatch();
  40a520:	31 c0                	xor    %eax,%eax
  40a522:	e8 89 1c 00 00       	callq  40c1b0 <StartStopwatch>

/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
  40a527:	48 83 7c 24 10 00    	cmpq   $0x0,0x10(%rsp)
#endif

/*
** Start the stopwatch.
*/
elapsed=StartStopwatch();
  40a52d:	48 89 44 24 28       	mov    %rax,0x28(%rsp)

/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
  40a532:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  40a539:	00 00 
  40a53b:	74 65                	je     40a5a2 <DoIDEA+0x6f2>
  40a53d:	0f 1f 00             	nopl   (%rax)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a540:	45 31 ff             	xor    %r15d,%r15d
  40a543:	48 85 db             	test   %rbx,%rbx
  40a546:	74 48                	je     40a590 <DoIDEA+0x6e0>
  40a548:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40a54f:	00 
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */
  40a550:	4a 8d 74 3d 00       	lea    0x0(%rbp,%r15,1),%rsi
  40a555:	4b 8d 3c 3c          	lea    (%r12,%r15,1),%rdi
  40a559:	4c 89 f2             	mov    %r14,%rdx
/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a55c:	49 83 c7 08          	add    $0x8,%r15
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */
  40a560:	e8 9b d3 ff ff       	callq  407900 <cipher_idea>
/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a565:	49 39 df             	cmp    %rbx,%r15
  40a568:	72 e6                	jb     40a550 <DoIDEA+0x6a0>
  40a56a:	45 31 ff             	xor    %r15d,%r15d
  40a56d:	0f 1f 00             	nopl   (%rax)
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */

	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
  40a570:	4b 8d 74 3d 00       	lea    0x0(%r13,%r15,1),%rsi
  40a575:	4a 8d 7c 3d 00       	lea    0x0(%rbp,%r15,1),%rdi
  40a57a:	48 8d 94 24 c0 00 00 	lea    0xc0(%rsp),%rdx
  40a581:	00 
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */

	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a582:	49 83 c7 08          	add    $0x8,%r15
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
  40a586:	e8 75 d3 ff ff       	callq  407900 <cipher_idea>
for(i=0;i<nloops;i++)
{
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */

	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
  40a58b:	49 39 df             	cmp    %rbx,%r15
  40a58e:	72 e0                	jb     40a570 <DoIDEA+0x6c0>
elapsed=StartStopwatch();

/*
** Do everything for nloops.
*/
for(i=0;i<nloops;i++)
  40a590:	48 83 44 24 08 01    	addq   $0x1,0x8(%rsp)
  40a596:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40a59b:	48 3b 44 24 10       	cmp    0x10(%rsp),%rax
  40a5a0:	75 9e                	jne    40a540 <DoIDEA+0x690>
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
}

#ifdef DEBUG
for(j=0;j<arraysize;j++)
  40a5a2:	31 c0                	xor    %eax,%eax
  40a5a4:	45 31 ff             	xor    %r15d,%r15d
  40a5a7:	48 85 db             	test   %rbx,%rbx
  40a5aa:	0f 84 83 00 00 00    	je     40a633 <DoIDEA+0x783>
	if(*(plain1+j)!=*(plain2+j)){
  40a5b0:	43 0f b6 4c 3d 00    	movzbl 0x0(%r13,%r15,1),%ecx
  40a5b6:	43 38 0c 3c          	cmp    %cl,(%r12,%r15,1)
  40a5ba:	74 0f                	je     40a5cb <DoIDEA+0x71b>
  40a5bc:	bf 20 df 40 00       	mov    $0x40df20,%edi
  40a5c1:	e8 ca 68 ff ff       	callq  400e90 <puts@plt>
		printf("IDEA Error! \n");
                status=1;
  40a5c6:	b8 01 00 00 00       	mov    $0x1,%eax
	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
}

#ifdef DEBUG
for(j=0;j<arraysize;j++)
  40a5cb:	49 83 c7 01          	add    $0x1,%r15
  40a5cf:	49 39 df             	cmp    %rbx,%r15
  40a5d2:	75 dc                	jne    40a5b0 <DoIDEA+0x700>
	if(*(plain1+j)!=*(plain2+j)){
		printf("IDEA Error! \n");
                status=1;
                }
if (status==0) printf("IDEA: OK\n");
  40a5d4:	85 c0                	test   %eax,%eax
  40a5d6:	74 5b                	je     40a633 <DoIDEA+0x783>
#endif

/*
** Get elapsed time.
*/
return(StopStopwatch(elapsed));
  40a5d8:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  40a5dd:	e8 de 1b 00 00       	callq  40c1c0 <StopStopwatch>
*/
accumtime=0L;
iterations=(double)0.0;

do {
	accumtime+=DoIDEAIteration(plain1,crypt1,plain2,
  40a5e2:	48 01 44 24 18       	add    %rax,0x18(%rsp)
		locideastruct->arraysize,
		locideastruct->loops,Z,DK);
	iterations+=(double)locideastruct->loops;
  40a5e7:	48 8b 05 ca 61 20 00 	mov    0x2061ca(%rip),%rax        # 6107b8 <global_ideastruct+0x18>
  40a5ee:	48 85 c0             	test   %rax,%rax
  40a5f1:	78 4c                	js     40a63f <DoIDEA+0x78f>
  40a5f3:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40a5f7:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40a5fc:	f2 0f 58 44 24 20    	addsd  0x20(%rsp),%xmm0
} while(TicksToSecs(accumtime)<locideastruct->request_secs);
  40a602:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi

do {
	accumtime+=DoIDEAIteration(plain1,crypt1,plain2,
		locideastruct->arraysize,
		locideastruct->loops,Z,DK);
	iterations+=(double)locideastruct->loops;
  40a607:	f2 0f 11 44 24 20    	movsd  %xmm0,0x20(%rsp)
} while(TicksToSecs(accumtime)<locideastruct->request_secs);
  40a60d:	e8 be 1b 00 00       	callq  40c1d0 <TicksToSecs>
  40a612:	48 3b 05 8f 61 20 00 	cmp    0x20618f(%rip),%rax        # 6107a8 <global_ideastruct+0x8>
  40a619:	73 7d                	jae    40a698 <DoIDEA+0x7e8>
  40a61b:	48 8b 05 96 61 20 00 	mov    0x206196(%rip),%rax        # 6107b8 <global_ideastruct+0x18>
  40a622:	48 8b 1d 87 61 20 00 	mov    0x206187(%rip),%rbx        # 6107b0 <global_ideastruct+0x10>
  40a629:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40a62e:	e9 ed fe ff ff       	jmpq   40a520 <DoIDEA+0x670>
  40a633:	bf 17 df 40 00       	mov    $0x40df17,%edi
  40a638:	e8 53 68 ff ff       	callq  400e90 <puts@plt>
  40a63d:	eb 99                	jmp    40a5d8 <DoIDEA+0x728>

do {
	accumtime+=DoIDEAIteration(plain1,crypt1,plain2,
		locideastruct->arraysize,
		locideastruct->loops,Z,DK);
	iterations+=(double)locideastruct->loops;
  40a63f:	48 89 c2             	mov    %rax,%rdx
  40a642:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40a646:	48 d1 ea             	shr    %rdx
  40a649:	83 e0 01             	and    $0x1,%eax
  40a64c:	48 09 c2             	or     %rax,%rdx
  40a64f:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  40a654:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40a658:	eb a2                	jmp    40a5fc <DoIDEA+0x74c>
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
	t1+=q*t0;
} while(y!=1);
return(low16(1-t1));
  40a65a:	89 d1                	mov    %edx,%ecx
  40a65c:	44 29 c9             	sub    %r9d,%ecx
  40a65f:	e9 0f fb ff ff       	jmpq   40a173 <DoIDEA+0x2c3>
  40a664:	89 d7                	mov    %edx,%edi
  40a666:	44 29 c7             	sub    %r8d,%edi
  40a669:	e9 90 fa ff ff       	jmpq   40a0fe <DoIDEA+0x24e>
  40a66e:	bf 17 df 40 00       	mov    $0x40df17,%edi
  40a673:	e8 18 68 ff ff       	callq  400e90 <puts@plt>
  40a678:	e9 4f fe ff ff       	jmpq   40a4cc <DoIDEA+0x61c>
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a67d:	89 cf                	mov    %ecx,%edi
  40a67f:	e9 7a fa ff ff       	jmpq   40a0fe <DoIDEA+0x24e>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
y=0x10001 % x;
if(y==1)
	return(low16(1-t1));
  40a684:	44 89 e7             	mov    %r12d,%edi
  40a687:	29 c7                	sub    %eax,%edi
  40a689:	e9 70 fa ff ff       	jmpq   40a0fe <DoIDEA+0x24e>
  40a68e:	44 89 e1             	mov    %r12d,%ecx
  40a691:	29 c1                	sub    %eax,%ecx
  40a693:	e9 db fa ff ff       	jmpq   40a173 <DoIDEA+0x2c3>

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)plain1,&systemerror);
  40a698:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a69d:	4c 89 e7             	mov    %r12,%rdi
  40a6a0:	e8 8b 17 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)crypt1,&systemerror);
  40a6a5:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a6aa:	48 89 ef             	mov    %rbp,%rdi
  40a6ad:	e8 7e 17 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)plain2,&systemerror);
  40a6b2:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a6b7:	4c 89 ef             	mov    %r13,%rdi
  40a6ba:	e8 71 17 00 00       	callq  40be30 <FreeMemory>
locideastruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40a6bf:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40a6c4:	e8 27 1b 00 00       	callq  40c1f0 <TicksToFracSecs>
  40a6c9:	f2 0f 10 54 24 20    	movsd  0x20(%rsp),%xmm2

if(locideastruct->adjust==0)
  40a6cf:	8b 15 cb 60 20 00    	mov    0x2060cb(%rip),%edx        # 6107a0 <global_ideastruct>
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)plain1,&systemerror);
FreeMemory((farvoid *)crypt1,&systemerror);
FreeMemory((farvoid *)plain2,&systemerror);
locideastruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40a6d5:	f2 0f 5e d0          	divsd  %xmm0,%xmm2

if(locideastruct->adjust==0)
  40a6d9:	85 d2                	test   %edx,%edx
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)plain1,&systemerror);
FreeMemory((farvoid *)crypt1,&systemerror);
FreeMemory((farvoid *)plain2,&systemerror);
locideastruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40a6db:	f2 0f 11 15 dd 60 20 	movsd  %xmm2,0x2060dd(%rip)        # 6107c0 <global_ideastruct+0x20>
  40a6e2:	00 

if(locideastruct->adjust==0)
  40a6e3:	75 0a                	jne    40a6ef <DoIDEA+0x83f>
	locideastruct->adjust=1;
  40a6e5:	c7 05 b1 60 20 00 01 	movl   $0x1,0x2060b1(%rip)        # 6107a0 <global_ideastruct>
  40a6ec:	00 00 00 

return;

}
  40a6ef:	48 8b 84 24 98 01 00 	mov    0x198(%rsp),%rax
  40a6f6:	00 
  40a6f7:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40a6fe:	00 00 
  40a700:	0f 85 07 01 00 00    	jne    40a80d <DoIDEA+0x95d>
  40a706:	48 81 c4 a8 01 00 00 	add    $0x1a8,%rsp
  40a70d:	5b                   	pop    %rbx
  40a70e:	5d                   	pop    %rbp
  40a70f:	41 5c                	pop    %r12
  40a711:	41 5d                	pop    %r13
  40a713:	41 5e                	pop    %r14
  40a715:	41 5f                	pop    %r15
  40a717:	c3                   	retq   
  40a718:	48 8b 05 99 60 20 00 	mov    0x206099(%rip),%rax        # 6107b8 <global_ideastruct+0x18>
  40a71f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40a724:	e9 e4 fd ff ff       	jmpq   40a50d <DoIDEA+0x65d>
	if(x==1) return(t0);
	q=y/x;
	y=y%x;
	t1+=q*t0;
} while(y!=1);
return(low16(1-t1));
  40a729:	44 29 c6             	sub    %r8d,%esi
  40a72c:	41 89 f0             	mov    %esi,%r8d
  40a72f:	e9 e5 fa ff ff       	jmpq   40a219 <DoIDEA+0x369>
  40a734:	89 d7                	mov    %edx,%edi
  40a736:	44 29 cf             	sub    %r9d,%edi
  40a739:	e9 58 fb ff ff       	jmpq   40a296 <DoIDEA+0x3e6>
  40a73e:	44 29 c6             	sub    %r8d,%esi
  40a741:	41 89 f0             	mov    %esi,%r8d
  40a744:	e9 88 f8 ff ff       	jmpq   409fd1 <DoIDEA+0x121>
  40a749:	89 d7                	mov    %edx,%edi
  40a74b:	44 29 cf             	sub    %r9d,%edi
  40a74e:	e9 f3 f8 ff ff       	jmpq   40a046 <DoIDEA+0x196>
}

plain2=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
if(systemerror)
{
	ReportError(errorcontext,systemerror);
  40a753:	bf 0e df 40 00       	mov    $0x40df0e,%edi
  40a758:	e8 13 1a 00 00       	callq  40c170 <ReportError>
	FreeMemory((farvoid *)plain1,&systemerror);
  40a75d:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a762:	4c 89 e7             	mov    %r12,%rdi
  40a765:	e8 c6 16 00 00       	callq  40be30 <FreeMemory>
	FreeMemory((farvoid *)crypt1,&systemerror);
  40a76a:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a76f:	48 89 ef             	mov    %rbp,%rdi
  40a772:	e8 b9 16 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  40a777:	31 c0                	xor    %eax,%eax
  40a779:	e8 22 1a 00 00       	callq  40c1a0 <ErrorExit>
  40a77e:	e9 3c fc ff ff       	jmpq   40a3bf <DoIDEA+0x50f>
}

crypt1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
if(systemerror)
{
	ReportError(errorcontext,systemerror);
  40a783:	bf 0e df 40 00       	mov    $0x40df0e,%edi
  40a788:	e8 e3 19 00 00       	callq  40c170 <ReportError>
	FreeMemory((farvoid *)plain1,&systemerror);
  40a78d:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a792:	4c 89 e7             	mov    %r12,%rdi
  40a795:	e8 96 16 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  40a79a:	31 c0                	xor    %eax,%eax
  40a79c:	e8 ff 19 00 00       	callq  40c1a0 <ErrorExit>
  40a7a1:	e9 f9 fb ff ff       	jmpq   40a39f <DoIDEA+0x4ef>
** Also, fill up plain1 with sample text.
*/
plain1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
if(systemerror)
{
	ReportError(errorcontext,systemerror);
  40a7a6:	bf 0e df 40 00       	mov    $0x40df0e,%edi
  40a7ab:	e8 c0 19 00 00       	callq  40c170 <ReportError>
	ErrorExit();
  40a7b0:	31 c0                	xor    %eax,%eax
  40a7b2:	e8 e9 19 00 00       	callq  40c1a0 <ErrorExit>
  40a7b7:	e9 c3 fb ff ff       	jmpq   40a37f <DoIDEA+0x4cf>
static u16 inv(u16 x)
{
u16 t0, t1;
u16 q, y;

if(x<=1)
  40a7bc:	41 89 c8             	mov    %ecx,%r8d
  40a7bf:	e9 0d f8 ff ff       	jmpq   409fd1 <DoIDEA+0x121>
  40a7c4:	89 cf                	mov    %ecx,%edi
  40a7c6:	e9 7b f8 ff ff       	jmpq   40a046 <DoIDEA+0x196>
  40a7cb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40a7d0:	48 8b 1d d9 5f 20 00 	mov    0x205fd9(%rip),%rbx        # 6107b0 <global_ideastruct+0x10>
  40a7d7:	e9 31 fd ff ff       	jmpq   40a50d <DoIDEA+0x65d>
  40a7dc:	89 cf                	mov    %ecx,%edi
  40a7de:	e9 b3 fa ff ff       	jmpq   40a296 <DoIDEA+0x3e6>
  40a7e3:	41 89 c8             	mov    %ecx,%r8d
  40a7e6:	e9 2e fa ff ff       	jmpq   40a219 <DoIDEA+0x369>
	return(x);      /* 0 and 1 are self-inverse */
t1=0x10001 / x;
y=0x10001 % x;
if(y==1)
	return(low16(1-t1));
  40a7eb:	29 c7                	sub    %eax,%edi
  40a7ed:	e9 54 f8 ff ff       	jmpq   40a046 <DoIDEA+0x196>
  40a7f2:	29 c7                	sub    %eax,%edi
  40a7f4:	41 89 f8             	mov    %edi,%r8d
  40a7f7:	e9 1d fa ff ff       	jmpq   40a219 <DoIDEA+0x369>
  40a7fc:	29 c7                	sub    %eax,%edi
  40a7fe:	e9 93 fa ff ff       	jmpq   40a296 <DoIDEA+0x3e6>
  40a803:	29 c7                	sub    %eax,%edi
  40a805:	41 89 f8             	mov    %edi,%r8d
  40a808:	e9 c4 f7 ff ff       	jmpq   409fd1 <DoIDEA+0x121>
if(locideastruct->adjust==0)
	locideastruct->adjust=1;

return;

}
  40a80d:	e8 ee 66 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  40a812:	0f 1f 40 00          	nopl   0x0(%rax)
  40a816:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40a81d:	00 00 00 

000000000040a820 <DoHuffman>:
** Huffman test includes a compression AND a decompression.
** Also, the compression cycle includes building the
** Huffman tree.
*/
void DoHuffman(void)
{
  40a820:	41 57                	push   %r15
  40a822:	41 56                	push   %r14
  40a824:	41 55                	push   %r13
  40a826:	41 54                	push   %r12
  40a828:	55                   	push   %rbp
  40a829:	53                   	push   %rbx
  40a82a:	48 83 ec 78          	sub    $0x78,%rsp
** into, and we preallocate space for the huffman tree.
** (We presume that the Huffman tree will grow no larger
** than 512 bytes.  This is actually a super-conservative
** estimate...but, who cares?)
*/
plaintext=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a82e:	48 8b 3d 3b 5f 20 00 	mov    0x205f3b(%rip),%rdi        # 610770 <global_huffstruct+0x10>
  40a835:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
** Huffman test includes a compression AND a decompression.
** Also, the compression cycle includes building the
** Huffman tree.
*/
void DoHuffman(void)
{
  40a83a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40a841:	00 00 
  40a843:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  40a848:	31 c0                	xor    %eax,%eax
** into, and we preallocate space for the huffman tree.
** (We presume that the Huffman tree will grow no larger
** than 512 bytes.  This is actually a super-conservative
** estimate...but, who cares?)
*/
plaintext=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a84a:	e8 e1 14 00 00       	callq  40bd30 <AllocateMemory>
if(systemerror)
  40a84f:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
** into, and we preallocate space for the huffman tree.
** (We presume that the Huffman tree will grow no larger
** than 512 bytes.  This is actually a super-conservative
** estimate...but, who cares?)
*/
plaintext=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a853:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
if(systemerror)
  40a858:	85 f6                	test   %esi,%esi
  40a85a:	0f 85 4f 03 00 00    	jne    40abaf <DoHuffman+0x38f>
{       ReportError(errorcontext,systemerror);
	ErrorExit();
}
comparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a860:	48 8b 3d 09 5f 20 00 	mov    0x205f09(%rip),%rdi        # 610770 <global_huffstruct+0x10>
  40a867:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a86c:	e8 bf 14 00 00       	callq  40bd30 <AllocateMemory>
if(systemerror)
  40a871:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
plaintext=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
	ErrorExit();
}
comparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a875:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
if(systemerror)
  40a87a:	85 f6                	test   %esi,%esi
  40a87c:	0f 85 ba 03 00 00    	jne    40ac3c <DoHuffman+0x41c>
{       ReportError(errorcontext,systemerror);
	FreeMemory(plaintext,&systemerror);
	ErrorExit();
}
decomparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a882:	48 8b 3d e7 5e 20 00 	mov    0x205ee7(%rip),%rdi        # 610770 <global_huffstruct+0x10>
  40a889:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a88e:	e8 9d 14 00 00       	callq  40bd30 <AllocateMemory>
if(systemerror)
  40a893:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
if(systemerror)
{       ReportError(errorcontext,systemerror);
	FreeMemory(plaintext,&systemerror);
	ErrorExit();
}
decomparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
  40a897:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
if(systemerror)
  40a89c:	85 f6                	test   %esi,%esi
  40a89e:	0f 85 64 03 00 00    	jne    40ac08 <DoHuffman+0x3e8>
	FreeMemory(plaintext,&systemerror);
	FreeMemory(comparray,&systemerror);
	ErrorExit();
}

hufftree=(huff_node *)AllocateMemory(sizeof(huff_node) * 512,
  40a8a4:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40a8a9:	bf 00 28 00 00       	mov    $0x2800,%edi
  40a8ae:	e8 7d 14 00 00       	callq  40bd30 <AllocateMemory>
	&systemerror);
if(systemerror)
  40a8b3:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
	FreeMemory(plaintext,&systemerror);
	FreeMemory(comparray,&systemerror);
	ErrorExit();
}

hufftree=(huff_node *)AllocateMemory(sizeof(huff_node) * 512,
  40a8b7:	48 89 05 f2 5d 20 00 	mov    %rax,0x205df2(%rip)        # 6106b0 <hufftree>
	&systemerror);
if(systemerror)
  40a8be:	85 f6                	test   %esi,%esi
  40a8c0:	0f 85 ff 02 00 00    	jne    40abc5 <DoHuffman+0x3a5>
*/
/*
** Reset random number generator so things repeat.
** added by Uwe F. Mayer
*/
randnum((int32)13);
  40a8c6:	bf 0d 00 00 00       	mov    $0xd,%edi
  40a8cb:	48 8d 5c 24 40       	lea    0x40(%rsp),%rbx
			ushort maxlinlen)
{
ulong bytessofar;       /* # of bytes so far */
ulong linelen;          /* Line length */

bytessofar=0L;
  40a8d0:	45 31 ff             	xor    %r15d,%r15d
*/
/*
** Reset random number generator so things repeat.
** added by Uwe F. Mayer
*/
randnum((int32)13);
  40a8d3:	e8 08 9f ff ff       	callq  4047e0 <randnum>
create_text_block(plaintext,lochuffstruct->arraysize-1,(ushort)500);
  40a8d8:	48 8b 05 91 5e 20 00 	mov    0x205e91(%rip),%rax        # 610770 <global_huffstruct+0x10>
  40a8df:	48 83 e8 01          	sub    $0x1,%rax
  40a8e3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40a8e8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  40a8ed:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40a8f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
/*
** Pick a random length for a line and fill the line.
** Make sure the line can fit (haven't exceeded tablen) and also
** make sure you leave room to append a carriage return.
*/
linelen=abs_randwc(maxlinlen-6)+6;
  40a8f8:	bf ee 01 00 00       	mov    $0x1ee,%edi
  40a8fd:	e8 7e 9e ff ff       	callq  404780 <abs_randwc>
  40a902:	8d 68 06             	lea    0x6(%rax),%ebp
if((linelen+bytessofar)>tblen)
  40a905:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40a90a:	4a 8d 44 3d 00       	lea    0x0(%rbp,%r15,1),%rax
  40a90f:	48 39 c6             	cmp    %rax,%rsi
  40a912:	0f 83 f8 01 00 00    	jae    40ab10 <DoHuffman+0x2f0>
	linelen=tblen-bytessofar;
  40a918:	48 89 f5             	mov    %rsi,%rbp
  40a91b:	4c 29 fd             	sub    %r15,%rbp
  40a91e:	49 89 f7             	mov    %rsi,%r15

if(linelen>1)
  40a921:	48 83 fd 01          	cmp    $0x1,%rbp
  40a925:	0f 86 b5 00 00 00    	jbe    40a9e0 <DoHuffman+0x1c0>
{
	create_text_line(tb,linelen);
  40a92b:	4c 8b 6c 24 08       	mov    0x8(%rsp),%r13
long charssofar;        /* # of characters so far */
long tomove;            /* # of characters to move */
char myword[40];        /* Local buffer for words */
farchar *wordptr;       /* Pointer to word from catalog */

charssofar=0;
  40a930:	45 31 e4             	xor    %r12d,%r12d
  40a933:	eb 26                	jmp    40a95b <DoHuffman+0x13b>
  40a935:	0f 1f 00             	nopl   (%rax)
/*
** See how long it is.  If its length+charssofar > nchars, we have
** to trim it.
*/
if((tomove+charssofar)>nchars)
	tomove=nchars-charssofar;
  40a938:	49 89 ee             	mov    %rbp,%r14
  40a93b:	4d 29 e6             	sub    %r12,%r14
  40a93e:	49 89 ec             	mov    %rbp,%r12
/*
** Attach the word to the current line.  Increment counter.
*/
MoveMemory((farvoid *)dt,(farvoid *)myword,(unsigned long)tomove);
  40a941:	4c 89 ef             	mov    %r13,%rdi
  40a944:	4c 89 f2             	mov    %r14,%rdx
  40a947:	48 89 de             	mov    %rbx,%rsi
  40a94a:	e8 a1 15 00 00       	callq  40bef0 <MoveMemory>
charssofar+=tomove;
dt+=tomove;
  40a94f:	4d 01 f5             	add    %r14,%r13

/*
** If we're done, bail out.  Otherwise, go get another word.
*/
} while(charssofar<nchars);
  40a952:	4c 39 e5             	cmp    %r12,%rbp
  40a955:	0f 8e 85 00 00 00    	jle    40a9e0 <DoHuffman+0x1c0>
do {
/*
** Grab a random word from the wordcatalog
*/
/* wordptr=wordcatarray[abs_randwc((long)WORDCATSIZE)];*/
wordptr=wordcatarray[abs_randwc((int32)WORDCATSIZE)];
  40a95b:	bf 32 00 00 00       	mov    $0x32,%edi
  40a960:	e8 1b 9e ff ff       	callq  404780 <abs_randwc>
  40a965:	89 c0                	mov    %eax,%eax
  40a967:	4c 8b 34 c5 00 05 61 	mov    0x610500(,%rax,8),%r14
  40a96e:	00 
MoveMemory((farvoid *)myword,
	(farvoid *)wordptr,
	(unsigned long)strlen(wordptr)+1);
  40a96f:	4c 89 f7             	mov    %r14,%rdi
  40a972:	e8 79 65 ff ff       	callq  400ef0 <strlen@plt>
/*
** Grab a random word from the wordcatalog
*/
/* wordptr=wordcatarray[abs_randwc((long)WORDCATSIZE)];*/
wordptr=wordcatarray[abs_randwc((int32)WORDCATSIZE)];
MoveMemory((farvoid *)myword,
  40a977:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40a97b:	4c 89 f6             	mov    %r14,%rsi
  40a97e:	48 89 df             	mov    %rbx,%rdi
  40a981:	e8 6a 15 00 00       	callq  40bef0 <MoveMemory>
	(unsigned long)strlen(wordptr)+1);

/*
** Append a blank.
*/
tomove=strlen(myword)+1;
  40a986:	48 89 da             	mov    %rbx,%rdx
  40a989:	8b 0a                	mov    (%rdx),%ecx
  40a98b:	48 83 c2 04          	add    $0x4,%rdx
  40a98f:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40a995:	f7 d1                	not    %ecx
  40a997:	21 c8                	and    %ecx,%eax
  40a999:	25 80 80 80 80       	and    $0x80808080,%eax
  40a99e:	74 e9                	je     40a989 <DoHuffman+0x169>
  40a9a0:	89 c1                	mov    %eax,%ecx
  40a9a2:	c1 e9 10             	shr    $0x10,%ecx
  40a9a5:	a9 80 80 00 00       	test   $0x8080,%eax
  40a9aa:	0f 44 c1             	cmove  %ecx,%eax
  40a9ad:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40a9b1:	89 c6                	mov    %eax,%esi
  40a9b3:	48 0f 44 d1          	cmove  %rcx,%rdx
  40a9b7:	40 00 c6             	add    %al,%sil
  40a9ba:	48 83 da 03          	sbb    $0x3,%rdx
  40a9be:	48 29 da             	sub    %rbx,%rdx
  40a9c1:	4c 8d 72 01          	lea    0x1(%rdx),%r14

/*
** See how long it is.  If its length+charssofar > nchars, we have
** to trim it.
*/
if((tomove+charssofar)>nchars)
  40a9c5:	4b 8d 14 26          	lea    (%r14,%r12,1),%rdx

/*
** Append a blank.
*/
tomove=strlen(myword)+1;
myword[tomove-1]=' ';
  40a9c9:	42 c6 44 34 3f 20    	movb   $0x20,0x3f(%rsp,%r14,1)

/*
** See how long it is.  If its length+charssofar > nchars, we have
** to trim it.
*/
if((tomove+charssofar)>nchars)
  40a9cf:	48 39 d5             	cmp    %rdx,%rbp
  40a9d2:	0f 8c 60 ff ff ff    	jl     40a938 <DoHuffman+0x118>
  40a9d8:	49 89 d4             	mov    %rdx,%r12
  40a9db:	e9 61 ff ff ff       	jmpq   40a941 <DoHuffman+0x121>

if(linelen>1)
{
	create_text_line(tb,linelen);
}
tb+=linelen-1;          /* Add the carriage return */
  40a9e0:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  40a9e5:	48 8d 44 2e ff       	lea    -0x1(%rsi,%rbp,1),%rax
*tb++='\n';
  40a9ea:	48 01 ee             	add    %rbp,%rsi

bytessofar+=linelen;

} while(bytessofar<tblen);
  40a9ed:	4c 39 7c 24 10       	cmp    %r15,0x10(%rsp)
if(linelen>1)
{
	create_text_line(tb,linelen);
}
tb+=linelen-1;          /* Add the carriage return */
*tb++='\n';
  40a9f2:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  40a9f7:	c6 00 0a             	movb   $0xa,(%rax)

bytessofar+=linelen;

} while(bytessofar<tblen);
  40a9fa:	0f 87 f8 fe ff ff    	ja     40a8f8 <DoHuffman+0xd8>
** Reset random number generator so things repeat.
** added by Uwe F. Mayer
*/
randnum((int32)13);
create_text_block(plaintext,lochuffstruct->arraysize-1,(ushort)500);
plaintext[lochuffstruct->arraysize-1L]='\0';
  40aa00:	48 8b 05 69 5d 20 00 	mov    0x205d69(%rip),%rax        # 610770 <global_huffstruct+0x10>
  40aa07:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
  40aa0c:	c6 44 03 ff 00       	movb   $0x0,-0x1(%rbx,%rax,1)
plaintextlen=lochuffstruct->arraysize;

/*
** See if we need to perform self adjustment loop.
*/
if(lochuffstruct->adjust==0)
  40aa11:	8b 15 49 5d 20 00    	mov    0x205d49(%rip),%edx        # 610760 <global_huffstruct>
  40aa17:	85 d2                	test   %edx,%edx
  40aa19:	75 5b                	jne    40aa76 <DoHuffman+0x256>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(lochuffstruct->loops=100L;
  40aa1b:	48 c7 05 52 5d 20 00 	movq   $0x64,0x205d52(%rip)        # 610778 <global_huffstruct+0x18>
  40aa22:	64 00 00 00 
  40aa26:	41 b8 64 00 00 00    	mov    $0x64,%r8d
  40aa2c:	eb 1d                	jmp    40aa4b <DoHuffman+0x22b>
  40aa2e:	66 90                	xchg   %ax,%ax
	  lochuffstruct->loops<MAXHUFFLOOPS;
	  lochuffstruct->loops+=10L)
  40aa30:	48 8b 05 41 5d 20 00 	mov    0x205d41(%rip),%rax        # 610778 <global_huffstruct+0x18>
  40aa37:	4c 8d 40 0a          	lea    0xa(%rax),%r8
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(lochuffstruct->loops=100L;
  40aa3b:	49 81 f8 1f a1 07 00 	cmp    $0x7a11f,%r8
	  lochuffstruct->loops<MAXHUFFLOOPS;
	  lochuffstruct->loops+=10L)
  40aa42:	4c 89 05 2f 5d 20 00 	mov    %r8,0x205d2f(%rip)        # 610778 <global_huffstruct+0x18>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(lochuffstruct->loops=100L;
  40aa49:	77 32                	ja     40aa7d <DoHuffman+0x25d>
	  lochuffstruct->loops<MAXHUFFLOOPS;
	  lochuffstruct->loops+=10L)
		if(DoHuffIteration(plaintext,
  40aa4b:	4c 8b 0d 5e 5c 20 00 	mov    0x205c5e(%rip),%r9        # 6106b0 <hufftree>
  40aa52:	48 8b 0d 17 5d 20 00 	mov    0x205d17(%rip),%rcx        # 610770 <global_huffstruct+0x10>
  40aa59:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
  40aa5e:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40aa63:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40aa68:	e8 f3 ac ff ff       	callq  405760 <DoHuffIteration>
  40aa6d:	48 3b 05 4c 5c 20 00 	cmp    0x205c4c(%rip),%rax        # 6106c0 <global_min_ticks>
  40aa74:	76 ba                	jbe    40aa30 <DoHuffman+0x210>
  40aa76:	4c 8b 05 fb 5c 20 00 	mov    0x205cfb(%rip),%r8        # 610778 <global_huffstruct+0x18>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(lochuffstruct->loops=100L;
  40aa7d:	66 0f ef db          	pxor   %xmm3,%xmm3
  40aa81:	31 db                	xor    %ebx,%ebx
  40aa83:	f2 0f 11 5c 24 08    	movsd  %xmm3,0x8(%rsp)
  40aa89:	eb 32                	jmp    40aabd <DoHuffman+0x29d>
  40aa8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		comparray,
		decomparray,
		lochuffstruct->arraysize,
		lochuffstruct->loops,
		hufftree);
	iterations+=(double)lochuffstruct->loops;
  40aa90:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40aa94:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40aa99:	f2 0f 58 44 24 08    	addsd  0x8(%rsp),%xmm0
} while(TicksToSecs(accumtime)<lochuffstruct->request_secs);
  40aa9f:	48 89 df             	mov    %rbx,%rdi
		comparray,
		decomparray,
		lochuffstruct->arraysize,
		lochuffstruct->loops,
		hufftree);
	iterations+=(double)lochuffstruct->loops;
  40aaa2:	f2 0f 11 44 24 08    	movsd  %xmm0,0x8(%rsp)
} while(TicksToSecs(accumtime)<lochuffstruct->request_secs);
  40aaa8:	e8 23 17 00 00       	callq  40c1d0 <TicksToSecs>
  40aaad:	48 3b 05 b4 5c 20 00 	cmp    0x205cb4(%rip),%rax        # 610768 <global_huffstruct+0x8>
  40aab4:	73 6a                	jae    40ab20 <DoHuffman+0x300>
  40aab6:	4c 8b 05 bb 5c 20 00 	mov    0x205cbb(%rip),%r8        # 610778 <global_huffstruct+0x18>
*/
accumtime=0L;
iterations=(double)0.0;

do {
	accumtime+=DoHuffIteration(plaintext,
  40aabd:	4c 8b 0d ec 5b 20 00 	mov    0x205bec(%rip),%r9        # 6106b0 <hufftree>
  40aac4:	48 8b 0d a5 5c 20 00 	mov    0x205ca5(%rip),%rcx        # 610770 <global_huffstruct+0x10>
  40aacb:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
  40aad0:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  40aad5:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40aada:	e8 81 ac ff ff       	callq  405760 <DoHuffIteration>
  40aadf:	48 01 c3             	add    %rax,%rbx
		comparray,
		decomparray,
		lochuffstruct->arraysize,
		lochuffstruct->loops,
		hufftree);
	iterations+=(double)lochuffstruct->loops;
  40aae2:	48 8b 05 8f 5c 20 00 	mov    0x205c8f(%rip),%rax        # 610778 <global_huffstruct+0x18>
  40aae9:	48 85 c0             	test   %rax,%rax
  40aaec:	79 a2                	jns    40aa90 <DoHuffman+0x270>
  40aaee:	48 89 c2             	mov    %rax,%rdx
  40aaf1:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40aaf5:	48 d1 ea             	shr    %rdx
  40aaf8:	83 e0 01             	and    $0x1,%eax
  40aafb:	48 09 c2             	or     %rax,%rdx
  40aafe:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  40ab03:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40ab07:	eb 90                	jmp    40aa99 <DoHuffman+0x279>
  40ab09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
** Pick a random length for a line and fill the line.
** Make sure the line can fit (haven't exceeded tablen) and also
** make sure you leave room to append a carriage return.
*/
linelen=abs_randwc(maxlinlen-6)+6;
if((linelen+bytessofar)>tblen)
  40ab10:	49 89 c7             	mov    %rax,%r15
  40ab13:	e9 09 fe ff ff       	jmpq   40a921 <DoHuffman+0x101>
  40ab18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40ab1f:	00 

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
FreeMemory((farvoid *)plaintext,&systemerror);
  40ab20:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40ab25:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ab2a:	e8 01 13 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)comparray,&systemerror);
  40ab2f:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40ab34:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ab39:	e8 f2 12 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)decomparray,&systemerror);
  40ab3e:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  40ab43:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ab48:	e8 e3 12 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)hufftree,&systemerror);
  40ab4d:	48 8b 3d 5c 5b 20 00 	mov    0x205b5c(%rip),%rdi        # 6106b0 <hufftree>
  40ab54:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ab59:	e8 d2 12 00 00       	callq  40be30 <FreeMemory>
lochuffstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40ab5e:	48 89 df             	mov    %rbx,%rdi
  40ab61:	e8 8a 16 00 00       	callq  40c1f0 <TicksToFracSecs>
  40ab66:	f2 0f 10 54 24 08    	movsd  0x8(%rsp),%xmm2

if(lochuffstruct->adjust==0)
  40ab6c:	8b 05 ee 5b 20 00    	mov    0x205bee(%rip),%eax        # 610760 <global_huffstruct>
*/
FreeMemory((farvoid *)plaintext,&systemerror);
FreeMemory((farvoid *)comparray,&systemerror);
FreeMemory((farvoid *)decomparray,&systemerror);
FreeMemory((farvoid *)hufftree,&systemerror);
lochuffstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40ab72:	f2 0f 5e d0          	divsd  %xmm0,%xmm2

if(lochuffstruct->adjust==0)
  40ab76:	85 c0                	test   %eax,%eax
*/
FreeMemory((farvoid *)plaintext,&systemerror);
FreeMemory((farvoid *)comparray,&systemerror);
FreeMemory((farvoid *)decomparray,&systemerror);
FreeMemory((farvoid *)hufftree,&systemerror);
lochuffstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40ab78:	f2 0f 11 15 00 5c 20 	movsd  %xmm2,0x205c00(%rip)        # 610780 <global_huffstruct+0x20>
  40ab7f:	00 

if(lochuffstruct->adjust==0)
  40ab80:	75 0a                	jne    40ab8c <DoHuffman+0x36c>
	lochuffstruct->adjust=1;
  40ab82:	c7 05 d4 5b 20 00 01 	movl   $0x1,0x205bd4(%rip)        # 610760 <global_huffstruct>
  40ab89:	00 00 00 

}
  40ab8c:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
  40ab91:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40ab98:	00 00 
  40ab9a:	0f 85 c1 00 00 00    	jne    40ac61 <DoHuffman+0x441>
  40aba0:	48 83 c4 78          	add    $0x78,%rsp
  40aba4:	5b                   	pop    %rbx
  40aba5:	5d                   	pop    %rbp
  40aba6:	41 5c                	pop    %r12
  40aba8:	41 5d                	pop    %r13
  40abaa:	41 5e                	pop    %r14
  40abac:	41 5f                	pop    %r15
  40abae:	c3                   	retq   
** than 512 bytes.  This is actually a super-conservative
** estimate...but, who cares?)
*/
plaintext=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  40abaf:	bf 2d df 40 00       	mov    $0x40df2d,%edi
  40abb4:	e8 b7 15 00 00       	callq  40c170 <ReportError>
	ErrorExit();
  40abb9:	31 c0                	xor    %eax,%eax
  40abbb:	e8 e0 15 00 00       	callq  40c1a0 <ErrorExit>
  40abc0:	e9 9b fc ff ff       	jmpq   40a860 <DoHuffman+0x40>
}

hufftree=(huff_node *)AllocateMemory(sizeof(huff_node) * 512,
	&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  40abc5:	bf 2d df 40 00       	mov    $0x40df2d,%edi
  40abca:	e8 a1 15 00 00       	callq  40c170 <ReportError>
	FreeMemory(plaintext,&systemerror);
  40abcf:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40abd4:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40abd9:	e8 52 12 00 00       	callq  40be30 <FreeMemory>
	FreeMemory(comparray,&systemerror);
  40abde:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40abe3:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40abe8:	e8 43 12 00 00       	callq  40be30 <FreeMemory>
	FreeMemory(decomparray,&systemerror);
  40abed:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  40abf2:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40abf7:	e8 34 12 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  40abfc:	31 c0                	xor    %eax,%eax
  40abfe:	e8 9d 15 00 00       	callq  40c1a0 <ErrorExit>
  40ac03:	e9 be fc ff ff       	jmpq   40a8c6 <DoHuffman+0xa6>
	FreeMemory(plaintext,&systemerror);
	ErrorExit();
}
decomparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  40ac08:	bf 2d df 40 00       	mov    $0x40df2d,%edi
  40ac0d:	e8 5e 15 00 00       	callq  40c170 <ReportError>
	FreeMemory(plaintext,&systemerror);
  40ac12:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40ac17:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ac1c:	e8 0f 12 00 00       	callq  40be30 <FreeMemory>
	FreeMemory(comparray,&systemerror);
  40ac21:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40ac26:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ac2b:	e8 00 12 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  40ac30:	31 c0                	xor    %eax,%eax
  40ac32:	e8 69 15 00 00       	callq  40c1a0 <ErrorExit>
  40ac37:	e9 68 fc ff ff       	jmpq   40a8a4 <DoHuffman+0x84>
{       ReportError(errorcontext,systemerror);
	ErrorExit();
}
comparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
if(systemerror)
{       ReportError(errorcontext,systemerror);
  40ac3c:	bf 2d df 40 00       	mov    $0x40df2d,%edi
  40ac41:	e8 2a 15 00 00       	callq  40c170 <ReportError>
	FreeMemory(plaintext,&systemerror);
  40ac46:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  40ac4b:	48 8d 74 24 3c       	lea    0x3c(%rsp),%rsi
  40ac50:	e8 db 11 00 00       	callq  40be30 <FreeMemory>
	ErrorExit();
  40ac55:	31 c0                	xor    %eax,%eax
  40ac57:	e8 44 15 00 00       	callq  40c1a0 <ErrorExit>
  40ac5c:	e9 21 fc ff ff       	jmpq   40a882 <DoHuffman+0x62>
lochuffstruct->iterspersec=iterations / TicksToFracSecs(accumtime);

if(lochuffstruct->adjust==0)
	lochuffstruct->adjust=1;

}
  40ac61:	e8 9a 62 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  40ac66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40ac6d:	00 00 00 

000000000040ac70 <DoNNET>:
** requires an input file.  That file is "NNET.DAT" and
** should be on the local directory (from which the
** benchmark program in launched).
*/
void DoNNET(void)
{
  40ac70:	41 57                	push   %r15
  40ac72:	41 56                	push   %r14
**  The NNET algorithm uses the random number generator
**  to initialize the net.  Results are sensitive to
**  the initial neural net state.
*/
/* randnum(3L); */
randnum((int32)3);
  40ac74:	bf 03 00 00 00       	mov    $0x3,%edi
** requires an input file.  That file is "NNET.DAT" and
** should be on the local directory (from which the
** benchmark program in launched).
*/
void DoNNET(void)
{
  40ac79:	41 55                	push   %r13
  40ac7b:	41 54                	push   %r12
  40ac7d:	55                   	push   %rbp
  40ac7e:	53                   	push   %rbx
  40ac7f:	48 83 ec 58          	sub    $0x58,%rsp
  40ac83:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40ac8a:	00 00 
  40ac8c:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
  40ac91:	31 c0                	xor    %eax,%eax
**  The NNET algorithm uses the random number generator
**  to initialize the net.  Results are sensitive to
**  the initial neural net state.
*/
/* randnum(3L); */
randnum((int32)3);
  40ac93:	e8 48 9b ff ff       	callq  4047e0 <randnum>
int vals_read;
int val1,val2,val3,val4,val5,val6,val7,val8;

/* printf("\n Opening and retrieving data from file."); */

infile = fopen(inpath, "r");
  40ac98:	48 8b 3d f1 59 20 00 	mov    0x2059f1(%rip),%rdi        # 610690 <inpath>
  40ac9f:	be 05 e0 40 00       	mov    $0x40e005,%esi
  40aca4:	e8 97 63 ff ff       	callq  401040 <fopen@plt>
if (infile == NULL)
  40aca9:	48 85 c0             	test   %rax,%rax
  40acac:	0f 84 39 04 00 00    	je     40b0eb <DoNNET+0x47b>
{
	printf("\n CPU:NNET--error in opening file!");
	return -1 ;
}
vals_read =fscanf(infile,"%d  %d  %d",&xinsize,&yinsize,&youtsize);
  40acb2:	4c 8d 44 24 24       	lea    0x24(%rsp),%r8
  40acb7:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  40acbc:	48 8d 54 24 1c       	lea    0x1c(%rsp),%rdx
  40acc1:	48 89 c7             	mov    %rax,%rdi
  40acc4:	48 89 c5             	mov    %rax,%rbp
  40acc7:	be 41 df 40 00       	mov    $0x40df41,%esi
  40accc:	31 c0                	xor    %eax,%eax
  40acce:	e8 ad 61 ff ff       	callq  400e80 <__isoc99_fscanf@plt>
if (vals_read != 3)
  40acd3:	83 f8 03             	cmp    $0x3,%eax
  40acd6:	0f 85 df 03 00 00    	jne    40b0bb <DoNNET+0x44b>
{
	printf("\n CPU:NNET -- Should read 3 items in line one; did read %d",vals_read);
	return -1;
}
vals_read=fscanf(infile,"%d",&numpats);
  40acdc:	31 c0                	xor    %eax,%eax
  40acde:	ba 10 14 61 00       	mov    $0x611410,%edx
  40ace3:	be 49 df 40 00       	mov    $0x40df49,%esi
  40ace8:	48 89 ef             	mov    %rbp,%rdi
  40aceb:	e8 90 61 ff ff       	callq  400e80 <__isoc99_fscanf@plt>
if (vals_read !=1)
  40acf0:	83 f8 01             	cmp    $0x1,%eax
  40acf3:	0f 85 da 03 00 00    	jne    40b0d3 <DoNNET+0x463>
{
	printf("\n CPU:NNET -- Should read 1 item in line 2; did read %d",vals_read);
	return -1;
}
if (numpats > MAXPATS)
  40acf9:	8b 05 11 67 20 00    	mov    0x206711(%rip),%eax        # 611410 <numpats>
  40acff:	83 f8 0a             	cmp    $0xa,%eax
  40ad02:	0f 8f 10 02 00 00    	jg     40af18 <DoNNET+0x2a8>
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
  40ad08:	85 c0                	test   %eax,%eax
  40ad0a:	0f 8e 9e 03 00 00    	jle    40b0ae <DoNNET+0x43e>
  40ad10:	4c 8d 6c 24 38       	lea    0x38(%rsp),%r13
  40ad15:	48 c7 44 24 08 40 1d 	movq   $0x611d40,0x8(%rsp)
  40ad1c:	61 00 
  40ad1e:	bb d8 20 61 00       	mov    $0x6120d8,%ebx
{
	element = 0;
	for (row = 0; row<yinsize; row++)
  40ad23:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  40ad2a:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
  40ad2e:	45 31 ff             	xor    %r15d,%r15d
  40ad31:	85 c9                	test   %ecx,%ecx
  40ad33:	0f 8e 47 02 00 00    	jle    40af80 <DoNNET+0x310>
			printf ("\n CPU:NNET -- failure in reading input!");
			return -1;
		}
		element=row*xinsize;

		in_pats[patt][element] = (double) val1; element++;
  40ad39:	48 63 04 24          	movslq (%rsp),%rax
  40ad3d:	4c 8d 24 80          	lea    (%rax,%rax,4),%r12
  40ad41:	4e 8d 34 e5 00 00 00 	lea    0x0(,%r12,8),%r14
  40ad48:	00 
  40ad49:	e9 a7 00 00 00       	jmpq   40adf5 <DoNNET+0x185>
  40ad4e:	66 90                	xchg   %ax,%ax
		if (vals_read != 5)
		{
			printf ("\n CPU:NNET -- failure in reading input!");
			return -1;
		}
		element=row*xinsize;
  40ad50:	8b 44 24 1c          	mov    0x1c(%rsp),%eax

		in_pats[patt][element] = (double) val1; element++;
  40ad54:	4c 89 f2             	mov    %r14,%rdx
  40ad57:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40ad5b:	4c 29 e2             	sub    %r12,%rdx
		if (vals_read != 5)
		{
			printf ("\n CPU:NNET -- failure in reading input!");
			return -1;
		}
		element=row*xinsize;
  40ad5e:	41 0f af c7          	imul   %r15d,%eax
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
{
	element = 0;
	for (row = 0; row<yinsize; row++)
  40ad62:	41 83 c7 01          	add    $0x1,%r15d
			printf ("\n CPU:NNET -- failure in reading input!");
			return -1;
		}
		element=row*xinsize;

		in_pats[patt][element] = (double) val1; element++;
  40ad66:	f2 0f 2a 44 24 28    	cvtsi2sdl 0x28(%rsp),%xmm0
  40ad6c:	48 63 c8             	movslq %eax,%rcx
  40ad6f:	48 01 d1             	add    %rdx,%rcx
  40ad72:	f2 0f 11 04 cd c0 1f 	movsd  %xmm0,0x611fc0(,%rcx,8)
  40ad79:	61 00 
		in_pats[patt][element] = (double) val2; element++;
  40ad7b:	8d 48 01             	lea    0x1(%rax),%ecx
  40ad7e:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40ad82:	48 63 c9             	movslq %ecx,%rcx
  40ad85:	48 01 d1             	add    %rdx,%rcx
  40ad88:	f2 0f 2a 44 24 2c    	cvtsi2sdl 0x2c(%rsp),%xmm0
  40ad8e:	f2 0f 11 04 cd c0 1f 	movsd  %xmm0,0x611fc0(,%rcx,8)
  40ad95:	61 00 
		in_pats[patt][element] = (double) val3; element++;
  40ad97:	8d 48 02             	lea    0x2(%rax),%ecx
  40ad9a:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40ad9e:	48 63 c9             	movslq %ecx,%rcx
  40ada1:	48 01 d1             	add    %rdx,%rcx
  40ada4:	f2 0f 2a 44 24 30    	cvtsi2sdl 0x30(%rsp),%xmm0
  40adaa:	f2 0f 11 04 cd c0 1f 	movsd  %xmm0,0x611fc0(,%rcx,8)
  40adb1:	61 00 
		in_pats[patt][element] = (double) val4; element++;
  40adb3:	8d 48 03             	lea    0x3(%rax),%ecx
  40adb6:	66 0f ef c0          	pxor   %xmm0,%xmm0
		in_pats[patt][element] = (double) val5; element++;
  40adba:	83 c0 04             	add    $0x4,%eax
		element=row*xinsize;

		in_pats[patt][element] = (double) val1; element++;
		in_pats[patt][element] = (double) val2; element++;
		in_pats[patt][element] = (double) val3; element++;
		in_pats[patt][element] = (double) val4; element++;
  40adbd:	48 63 c9             	movslq %ecx,%rcx
		in_pats[patt][element] = (double) val5; element++;
  40adc0:	48 98                	cltq   
		element=row*xinsize;

		in_pats[patt][element] = (double) val1; element++;
		in_pats[patt][element] = (double) val2; element++;
		in_pats[patt][element] = (double) val3; element++;
		in_pats[patt][element] = (double) val4; element++;
  40adc2:	48 01 d1             	add    %rdx,%rcx
		in_pats[patt][element] = (double) val5; element++;
  40adc5:	48 01 d0             	add    %rdx,%rax
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
{
	element = 0;
	for (row = 0; row<yinsize; row++)
  40adc8:	44 3b 7c 24 20       	cmp    0x20(%rsp),%r15d
		element=row*xinsize;

		in_pats[patt][element] = (double) val1; element++;
		in_pats[patt][element] = (double) val2; element++;
		in_pats[patt][element] = (double) val3; element++;
		in_pats[patt][element] = (double) val4; element++;
  40adcd:	f2 0f 2a 44 24 34    	cvtsi2sdl 0x34(%rsp),%xmm0
  40add3:	f2 0f 11 04 cd c0 1f 	movsd  %xmm0,0x611fc0(,%rcx,8)
  40adda:	61 00 
		in_pats[patt][element] = (double) val5; element++;
  40addc:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40ade0:	f2 0f 2a 44 24 38    	cvtsi2sdl 0x38(%rsp),%xmm0
  40ade6:	f2 0f 11 04 c5 c0 1f 	movsd  %xmm0,0x611fc0(,%rax,8)
  40aded:	61 00 
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
{
	element = 0;
	for (row = 0; row<yinsize; row++)
  40adef:	0f 8d 8b 01 00 00    	jge    40af80 <DoNNET+0x310>
	{
		vals_read = fscanf(infile,"%d  %d  %d  %d  %d",
  40adf5:	48 83 ec 08          	sub    $0x8,%rsp
  40adf9:	be 39 df 40 00       	mov    $0x40df39,%esi
  40adfe:	48 89 ef             	mov    %rbp,%rdi
  40ae01:	41 55                	push   %r13
  40ae03:	31 c0                	xor    %eax,%eax
  40ae05:	4c 8d 4c 24 44       	lea    0x44(%rsp),%r9
  40ae0a:	4c 8d 44 24 40       	lea    0x40(%rsp),%r8
  40ae0f:	48 8d 4c 24 3c       	lea    0x3c(%rsp),%rcx
  40ae14:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
  40ae19:	e8 62 60 ff ff       	callq  400e80 <__isoc99_fscanf@plt>
			&val1, &val2, &val3, &val4, &val5);
		if (vals_read != 5)
  40ae1e:	83 f8 05             	cmp    $0x5,%eax
  40ae21:	5e                   	pop    %rsi
  40ae22:	5f                   	pop    %rdi
  40ae23:	0f 84 27 ff ff ff    	je     40ad50 <DoNNET+0xe0>
  40ae29:	be 40 e2 40 00       	mov    $0x40e240,%esi
  40ae2e:	bf 01 00 00 00       	mov    $0x1,%edi
  40ae33:	31 c0                	xor    %eax,%eax
  40ae35:	e8 d6 61 ff ff       	callq  401010 <__printf_chk@plt>
** Read in the input and output patterns.  We'll do this
** only once here at the beginning.  These values don't
** change once loaded.
*/
if(read_data_file()!=0)
   ErrorExit();
  40ae3a:	31 c0                	xor    %eax,%eax
  40ae3c:	e8 5f 13 00 00       	callq  40c1a0 <ErrorExit>


/*
** See if we need to perform self adjustment loop.
*/
if(locnnetstruct->adjust==0)
  40ae41:	8b 15 79 5e 20 00    	mov    0x205e79(%rip),%edx        # 610cc0 <global_nnetstruct>
  40ae47:	85 d2                	test   %edx,%edx
  40ae49:	75 4e                	jne    40ae99 <DoNNET+0x229>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locnnetstruct->loops=1L;
  40ae4b:	48 c7 05 7a 5e 20 00 	movq   $0x1,0x205e7a(%rip)        # 610cd0 <global_nnetstruct+0x10>
  40ae52:	01 00 00 00 
  40ae56:	eb 22                	jmp    40ae7a <DoNNET+0x20a>
  40ae58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40ae5f:	00 
	  locnnetstruct->loops<MAXNNETLOOPS;
	  locnnetstruct->loops++)
  40ae60:	48 8b 05 69 5e 20 00 	mov    0x205e69(%rip),%rax        # 610cd0 <global_nnetstruct+0x10>
  40ae67:	48 83 c0 01          	add    $0x1,%rax
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locnnetstruct->loops=1L;
  40ae6b:	48 3d 1f a1 07 00    	cmp    $0x7a11f,%rax
	  locnnetstruct->loops<MAXNNETLOOPS;
	  locnnetstruct->loops++)
  40ae71:	48 89 05 58 5e 20 00 	mov    %rax,0x205e58(%rip)        # 610cd0 <global_nnetstruct+0x10>
	/*
	** Do self-adjustment.  This involves initializing the
	** # of loops and increasing the loop count until we
	** get a number of loops that we can use.
	*/
	for(locnnetstruct->loops=1L;
  40ae78:	77 1f                	ja     40ae99 <DoNNET+0x229>
	  locnnetstruct->loops<MAXNNETLOOPS;
	  locnnetstruct->loops++)
	  {     /*randnum(3L); */
		randnum((int32)3);
  40ae7a:	bf 03 00 00 00       	mov    $0x3,%edi
  40ae7f:	e8 5c 99 ff ff       	callq  4047e0 <randnum>
		if(DoNNetIteration(locnnetstruct->loops)
  40ae84:	48 8b 3d 45 5e 20 00 	mov    0x205e45(%rip),%rdi        # 610cd0 <global_nnetstruct+0x10>
  40ae8b:	e8 10 ad ff ff       	callq  405ba0 <DoNNetIteration>
  40ae90:	48 3b 05 29 58 20 00 	cmp    0x205829(%rip),%rax        # 6106c0 <global_min_ticks>
  40ae97:	76 c7                	jbe    40ae60 <DoNNET+0x1f0>
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
{
	element = 0;
	for (row = 0; row<yinsize; row++)
  40ae99:	66 0f ef ff          	pxor   %xmm7,%xmm7
  40ae9d:	31 db                	xor    %ebx,%ebx
  40ae9f:	f2 0f 11 3c 24       	movsd  %xmm7,(%rsp)
  40aea4:	eb 2e                	jmp    40aed4 <DoNNET+0x264>
  40aea6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40aead:	00 00 00 

do {
	/* randnum(3L); */    /* Gotta do this for Neural Net */
	randnum((int32)3);    /* Gotta do this for Neural Net */
	accumtime+=DoNNetIteration(locnnetstruct->loops);
	iterations+=(double)locnnetstruct->loops;
  40aeb0:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40aeb4:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40aeb9:	f2 0f 58 04 24       	addsd  (%rsp),%xmm0
} while(TicksToSecs(accumtime)<locnnetstruct->request_secs);
  40aebe:	48 89 df             	mov    %rbx,%rdi

do {
	/* randnum(3L); */    /* Gotta do this for Neural Net */
	randnum((int32)3);    /* Gotta do this for Neural Net */
	accumtime+=DoNNetIteration(locnnetstruct->loops);
	iterations+=(double)locnnetstruct->loops;
  40aec1:	f2 0f 11 04 24       	movsd  %xmm0,(%rsp)
} while(TicksToSecs(accumtime)<locnnetstruct->request_secs);
  40aec6:	e8 05 13 00 00       	callq  40c1d0 <TicksToSecs>
  40aecb:	48 3b 05 f6 5d 20 00 	cmp    0x205df6(%rip),%rax        # 610cc8 <global_nnetstruct+0x8>
  40aed2:	73 5c                	jae    40af30 <DoNNET+0x2c0>
accumtime=0L;
iterations=(double)0.0;

do {
	/* randnum(3L); */    /* Gotta do this for Neural Net */
	randnum((int32)3);    /* Gotta do this for Neural Net */
  40aed4:	bf 03 00 00 00       	mov    $0x3,%edi
  40aed9:	e8 02 99 ff ff       	callq  4047e0 <randnum>
	accumtime+=DoNNetIteration(locnnetstruct->loops);
  40aede:	48 8b 3d eb 5d 20 00 	mov    0x205deb(%rip),%rdi        # 610cd0 <global_nnetstruct+0x10>
  40aee5:	e8 b6 ac ff ff       	callq  405ba0 <DoNNetIteration>
  40aeea:	48 01 c3             	add    %rax,%rbx
	iterations+=(double)locnnetstruct->loops;
  40aeed:	48 8b 05 dc 5d 20 00 	mov    0x205ddc(%rip),%rax        # 610cd0 <global_nnetstruct+0x10>
  40aef4:	48 85 c0             	test   %rax,%rax
  40aef7:	79 b7                	jns    40aeb0 <DoNNET+0x240>
  40aef9:	48 89 c2             	mov    %rax,%rdx
  40aefc:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40af00:	48 d1 ea             	shr    %rdx
  40af03:	83 e0 01             	and    $0x1,%eax
  40af06:	48 09 c2             	or     %rax,%rdx
  40af09:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  40af0e:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40af12:	eb a5                	jmp    40aeb9 <DoNNET+0x249>
  40af14:	0f 1f 40 00          	nopl   0x0(%rax)
{
	printf("\n CPU:NNET -- Should read 1 item in line 2; did read %d",vals_read);
	return -1;
}
if (numpats > MAXPATS)
	numpats = MAXPATS;
  40af18:	c7 05 ee 64 20 00 0a 	movl   $0xa,0x2064ee(%rip)        # 611410 <numpats>
  40af1f:	00 00 00 
  40af22:	e9 e9 fd ff ff       	jmpq   40ad10 <DoNNET+0xa0>
  40af27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40af2e:	00 00 

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
locnnetstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40af30:	48 89 df             	mov    %rbx,%rdi
  40af33:	e8 b8 12 00 00       	callq  40c1f0 <TicksToFracSecs>
  40af38:	f2 0f 10 34 24       	movsd  (%rsp),%xmm6

if(locnnetstruct->adjust==0)
  40af3d:	8b 05 7d 5d 20 00    	mov    0x205d7d(%rip),%eax        # 610cc0 <global_nnetstruct>

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
locnnetstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40af43:	f2 0f 5e f0          	divsd  %xmm0,%xmm6

if(locnnetstruct->adjust==0)
  40af47:	85 c0                	test   %eax,%eax

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
locnnetstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40af49:	f2 0f 11 35 87 5d 20 	movsd  %xmm6,0x205d87(%rip)        # 610cd8 <global_nnetstruct+0x18>
  40af50:	00 

if(locnnetstruct->adjust==0)
  40af51:	75 0a                	jne    40af5d <DoNNET+0x2ed>
	locnnetstruct->adjust=1;
  40af53:	c7 05 63 5d 20 00 01 	movl   $0x1,0x205d63(%rip)        # 610cc0 <global_nnetstruct>
  40af5a:	00 00 00 


return;
}
  40af5d:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
  40af62:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40af69:	00 00 
  40af6b:	0f 85 90 01 00 00    	jne    40b101 <DoNNET+0x491>
  40af71:	48 83 c4 58          	add    $0x58,%rsp
  40af75:	5b                   	pop    %rbx
  40af76:	5d                   	pop    %rbp
  40af77:	41 5c                	pop    %r12
  40af79:	41 5d                	pop    %r13
  40af7b:	41 5e                	pop    %r14
  40af7d:	41 5f                	pop    %r15
  40af7f:	c3                   	retq   
  40af80:	48 8d 83 e8 fe ff ff 	lea    -0x118(%rbx),%rax
  40af87:	f2 0f 10 0d 61 33 00 	movsd  0x3361(%rip),%xmm1        # 40e2f0 <jtable.3055+0x1560>
  40af8e:	00 
  40af8f:	eb 1c                	jmp    40afad <DoNNET+0x33d>
  40af91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		in_pats[patt][element] = (double) val5; element++;
	}
	for (i=0;i<IN_SIZE; i++)
	{
		if (in_pats[patt][i] >= 0.9)
			in_pats[patt][i] = 0.9;
  40af98:	f2 0f 10 15 50 33 00 	movsd  0x3350(%rip),%xmm2        # 40e2f0 <jtable.3055+0x1560>
  40af9f:	00 
  40afa0:	f2 0f 11 10          	movsd  %xmm2,(%rax)
  40afa4:	48 83 c0 08          	add    $0x8,%rax
		in_pats[patt][element] = (double) val2; element++;
		in_pats[patt][element] = (double) val3; element++;
		in_pats[patt][element] = (double) val4; element++;
		in_pats[patt][element] = (double) val5; element++;
	}
	for (i=0;i<IN_SIZE; i++)
  40afa8:	48 39 c3             	cmp    %rax,%rbx
  40afab:	74 25                	je     40afd2 <DoNNET+0x362>
	{
		if (in_pats[patt][i] >= 0.9)
  40afad:	f2 0f 10 00          	movsd  (%rax),%xmm0
  40afb1:	66 0f 2e c1          	ucomisd %xmm1,%xmm0
  40afb5:	73 e1                	jae    40af98 <DoNNET+0x328>
			in_pats[patt][i] = 0.9;
		if (in_pats[patt][i] <= 0.1)
  40afb7:	f2 0f 10 1d f9 32 00 	movsd  0x32f9(%rip),%xmm3        # 40e2b8 <jtable.3055+0x1528>
  40afbe:	00 
  40afbf:	66 0f 2e d8          	ucomisd %xmm0,%xmm3
  40afc3:	72 df                	jb     40afa4 <DoNNET+0x334>
			in_pats[patt][i] = 0.1;
  40afc5:	f2 0f 11 18          	movsd  %xmm3,(%rax)
  40afc9:	48 83 c0 08          	add    $0x8,%rax
		in_pats[patt][element] = (double) val2; element++;
		in_pats[patt][element] = (double) val3; element++;
		in_pats[patt][element] = (double) val4; element++;
		in_pats[patt][element] = (double) val5; element++;
	}
	for (i=0;i<IN_SIZE; i++)
  40afcd:	48 39 c3             	cmp    %rax,%rbx
  40afd0:	75 db                	jne    40afad <DoNNET+0x33d>
			in_pats[patt][i] = 0.9;
		if (in_pats[patt][i] <= 0.1)
			in_pats[patt][i] = 0.1;
	}
	element = 0;
	vals_read = fscanf(infile,"%d  %d  %d  %d  %d  %d  %d  %d",
  40afd2:	48 8d 44 24 44       	lea    0x44(%rsp),%rax
  40afd7:	be 68 e2 40 00       	mov    $0x40e268,%esi
  40afdc:	48 89 ef             	mov    %rbp,%rdi
  40afdf:	48 81 c3 18 01 00 00 	add    $0x118,%rbx
  40afe6:	50                   	push   %rax
  40afe7:	48 8d 44 24 48       	lea    0x48(%rsp),%rax
  40afec:	50                   	push   %rax
  40afed:	48 8d 44 24 4c       	lea    0x4c(%rsp),%rax
  40aff2:	50                   	push   %rax
  40aff3:	41 55                	push   %r13
  40aff5:	31 c0                	xor    %eax,%eax
  40aff7:	4c 8d 4c 24 54       	lea    0x54(%rsp),%r9
  40affc:	4c 8d 44 24 50       	lea    0x50(%rsp),%r8
  40b001:	48 8d 4c 24 4c       	lea    0x4c(%rsp),%rcx
  40b006:	48 8d 54 24 48       	lea    0x48(%rsp),%rdx
  40b00b:	e8 70 5e ff ff       	callq  400e80 <__isoc99_fscanf@plt>
		&val1, &val2, &val3, &val4, &val5, &val6, &val7, &val8);

	out_pats[patt][element] = (double) val1; element++;
  40b010:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  40b015:	66 0f ef c0          	pxor   %xmm0,%xmm0
	return -1;
}
if (numpats > MAXPATS)
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
  40b019:	83 44 24 20 01       	addl   $0x1,0x20(%rsp)
  40b01e:	8b 74 24 20          	mov    0x20(%rsp),%esi
	}
	element = 0;
	vals_read = fscanf(infile,"%d  %d  %d  %d  %d  %d  %d  %d",
		&val1, &val2, &val3, &val4, &val5, &val6, &val7, &val8);

	out_pats[patt][element] = (double) val1; element++;
  40b022:	f2 0f 2a 44 24 48    	cvtsi2sdl 0x48(%rsp),%xmm0
  40b028:	f2 0f 11 00          	movsd  %xmm0,(%rax)
	out_pats[patt][element] = (double) val2; element++;
  40b02c:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b030:	48 83 c0 40          	add    $0x40,%rax
  40b034:	f2 0f 2a 44 24 4c    	cvtsi2sdl 0x4c(%rsp),%xmm0
  40b03a:	f2 0f 11 40 c8       	movsd  %xmm0,-0x38(%rax)
	out_pats[patt][element] = (double) val3; element++;
  40b03f:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b043:	f2 0f 2a 44 24 50    	cvtsi2sdl 0x50(%rsp),%xmm0
  40b049:	f2 0f 11 40 d0       	movsd  %xmm0,-0x30(%rax)
	out_pats[patt][element] = (double) val4; element++;
  40b04e:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b052:	f2 0f 2a 44 24 54    	cvtsi2sdl 0x54(%rsp),%xmm0
  40b058:	f2 0f 11 40 d8       	movsd  %xmm0,-0x28(%rax)
	out_pats[patt][element] = (double) val5; element++;
  40b05d:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b061:	f2 0f 2a 44 24 58    	cvtsi2sdl 0x58(%rsp),%xmm0
  40b067:	f2 0f 11 40 e0       	movsd  %xmm0,-0x20(%rax)
	out_pats[patt][element] = (double) val6; element++;
  40b06c:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b070:	f2 0f 2a 44 24 5c    	cvtsi2sdl 0x5c(%rsp),%xmm0
  40b076:	f2 0f 11 40 e8       	movsd  %xmm0,-0x18(%rax)
	out_pats[patt][element] = (double) val7; element++;
  40b07b:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b07f:	f2 0f 2a 44 24 60    	cvtsi2sdl 0x60(%rsp),%xmm0
  40b085:	f2 0f 11 40 f0       	movsd  %xmm0,-0x10(%rax)
	out_pats[patt][element] = (double) val8; element++;
  40b08a:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b08e:	f2 0f 2a 44 24 64    	cvtsi2sdl 0x64(%rsp),%xmm0
  40b094:	f2 0f 11 40 f8       	movsd  %xmm0,-0x8(%rax)
  40b099:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	return -1;
}
if (numpats > MAXPATS)
	numpats = MAXPATS;

for (patt=0; patt<numpats; patt++)
  40b09e:	48 83 c4 20          	add    $0x20,%rsp
  40b0a2:	3b 35 68 63 20 00    	cmp    0x206368(%rip),%esi        # 611410 <numpats>
  40b0a8:	0f 8c 7c fc ff ff    	jl     40ad2a <DoNNET+0xba>
	out_pats[patt][element] = (double) val8; element++;
}

/* printf("\n Closing the input file now. "); */

fclose(infile);
  40b0ae:	48 89 ef             	mov    %rbp,%rdi
  40b0b1:	e8 2a 5e ff ff       	callq  400ee0 <fclose@plt>
  40b0b6:	e9 86 fd ff ff       	jmpq   40ae41 <DoNNET+0x1d1>
  40b0bb:	89 c2                	mov    %eax,%edx
  40b0bd:	be c8 e1 40 00       	mov    $0x40e1c8,%esi
  40b0c2:	bf 01 00 00 00       	mov    $0x1,%edi
  40b0c7:	31 c0                	xor    %eax,%eax
  40b0c9:	e8 42 5f ff ff       	callq  401010 <__printf_chk@plt>
  40b0ce:	e9 67 fd ff ff       	jmpq   40ae3a <DoNNET+0x1ca>
  40b0d3:	89 c2                	mov    %eax,%edx
  40b0d5:	be 08 e2 40 00       	mov    $0x40e208,%esi
  40b0da:	bf 01 00 00 00       	mov    $0x1,%edi
  40b0df:	31 c0                	xor    %eax,%eax
  40b0e1:	e8 2a 5f ff ff       	callq  401010 <__printf_chk@plt>
  40b0e6:	e9 4f fd ff ff       	jmpq   40ae3a <DoNNET+0x1ca>
  40b0eb:	be a0 e1 40 00       	mov    $0x40e1a0,%esi
  40b0f0:	bf 01 00 00 00       	mov    $0x1,%edi
  40b0f5:	31 c0                	xor    %eax,%eax
  40b0f7:	e8 14 5f ff ff       	callq  401010 <__printf_chk@plt>
  40b0fc:	e9 39 fd ff ff       	jmpq   40ae3a <DoNNET+0x1ca>
if(locnnetstruct->adjust==0)
	locnnetstruct->adjust=1;


return;
}
  40b101:	e8 fa 5d ff ff       	callq  400f00 <__stack_chk_fail@plt>
  40b106:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b10d:	00 00 00 

000000000040b110 <DoLU>:
** DoLU **
**********
** Perform the LU decomposition benchmark.
*/
void DoLU(void)
{
  40b110:	41 57                	push   %r15
  40b112:	41 56                	push   %r14
** Our first step is to build a "solvable" problem.  This
** will become the "seed" set that all others will be
** derived from. (I.E., we'll simply copy these arrays
** into the others.
*/
a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
  40b114:	bf c8 3e 01 00       	mov    $0x13ec8,%edi
** DoLU **
**********
** Perform the LU decomposition benchmark.
*/
void DoLU(void)
{
  40b119:	41 55                	push   %r13
  40b11b:	41 54                	push   %r12
/*
** Build an identity matrix.
** We'll also use this as a chance to load the solution
** vector.
*/
for(i=0;i<n;i++)
  40b11d:	45 31 ed             	xor    %r13d,%r13d
** DoLU **
**********
** Perform the LU decomposition benchmark.
*/
void DoLU(void)
{
  40b120:	55                   	push   %rbp
  40b121:	53                   	push   %rbx
  40b122:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
** Our first step is to build a "solvable" problem.  This
** will become the "seed" set that all others will be
** derived from. (I.E., we'll simply copy these arrays
** into the others.
*/
a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
  40b129:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b130:	00 
** DoLU **
**********
** Perform the LU decomposition benchmark.
*/
void DoLU(void)
{
  40b131:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40b138:	00 00 
  40b13a:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
  40b141:	00 
  40b142:	31 c0                	xor    %eax,%eax
** Our first step is to build a "solvable" problem.  This
** will become the "seed" set that all others will be
** derived from. (I.E., we'll simply copy these arrays
** into the others.
*/
a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
  40b144:	e8 e7 0b 00 00       	callq  40bd30 <AllocateMemory>
		&systemerror);
b=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYROWS,
  40b149:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b150:	00 
  40b151:	bf 28 03 00 00       	mov    $0x328,%edi
** Our first step is to build a "solvable" problem.  This
** will become the "seed" set that all others will be
** derived from. (I.E., we'll simply copy these arrays
** into the others.
*/
a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
  40b156:	48 89 c5             	mov    %rax,%rbp

/*
** Reset random number generator
*/
/* randnum(13L); */
randnum((int32)13);
  40b159:	49 89 ee             	mov    %rbp,%r14
** derived from. (I.E., we'll simply copy these arrays
** into the others.
*/
a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
		&systemerror);
b=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYROWS,
  40b15c:	e8 cf 0b 00 00       	callq  40bd30 <AllocateMemory>
/*
** We need to allocate a temp vector that is used by the LU
** algorithm.  This removes the allocation routine from the
** timing.
*/
LUtempvv=(fardouble *)AllocateMemory(sizeof(double)*LUARRAYROWS,
  40b161:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b168:	00 
  40b169:	bf 28 03 00 00       	mov    $0x328,%edi
** derived from. (I.E., we'll simply copy these arrays
** into the others.
*/
a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
		&systemerror);
b=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYROWS,
  40b16e:	49 89 c4             	mov    %rax,%r12
/*
** We need to allocate a temp vector that is used by the LU
** algorithm.  This removes the allocation routine from the
** timing.
*/
LUtempvv=(fardouble *)AllocateMemory(sizeof(double)*LUARRAYROWS,
  40b171:	e8 ba 0b 00 00       	callq  40bd30 <AllocateMemory>

/*
** Reset random number generator
*/
/* randnum(13L); */
randnum((int32)13);
  40b176:	bf 0d 00 00 00       	mov    $0xd,%edi
/*
** We need to allocate a temp vector that is used by the LU
** algorithm.  This removes the allocation routine from the
** timing.
*/
LUtempvv=(fardouble *)AllocateMemory(sizeof(double)*LUARRAYROWS,
  40b17b:	48 89 05 9e 6b 20 00 	mov    %rax,0x206b9e(%rip)        # 611d20 <LUtempvv>

/*
** Reset random number generator
*/
/* randnum(13L); */
randnum((int32)13);
  40b182:	e8 59 96 ff ff       	callq  4047e0 <randnum>
** We'll also use this as a chance to load the solution
** vector.
*/
for(i=0;i<n;i++)
{       /* b[i]=(double)(abs_randwc(100L)+1L); */
	b[i]=(double)(abs_randwc((int32)100)+(int32)1);
  40b187:	bf 64 00 00 00       	mov    $0x64,%edi
	for(j=0;j<n;j++)
  40b18c:	31 db                	xor    %ebx,%ebx
** We'll also use this as a chance to load the solution
** vector.
*/
for(i=0;i<n;i++)
{       /* b[i]=(double)(abs_randwc(100L)+1L); */
	b[i]=(double)(abs_randwc((int32)100)+(int32)1);
  40b18e:	e8 ed 95 ff ff       	callq  404780 <abs_randwc>
  40b193:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b197:	83 c0 01             	add    $0x1,%eax
  40b19a:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40b19f:	f2 43 0f 11 04 ec    	movsd  %xmm0,(%r12,%r13,8)
  40b1a5:	0f 1f 00             	nopl   (%rax)
	for(j=0;j<n;j++)
		if(i==j)
  40b1a8:	4c 39 eb             	cmp    %r13,%rbx
  40b1ab:	0f 84 01 0a 00 00    	je     40bbb2 <DoLU+0xaa2>
		        /* a[i][j]=(double)(abs_randwc(1000L)+1L); */
			a[i][j]=(double)(abs_randwc((int32)1000)+(int32)1);
		else
			a[i][j]=(double)0.0;
  40b1b1:	49 c7 04 de 00 00 00 	movq   $0x0,(%r14,%rbx,8)
  40b1b8:	00 
** vector.
*/
for(i=0;i<n;i++)
{       /* b[i]=(double)(abs_randwc(100L)+1L); */
	b[i]=(double)(abs_randwc((int32)100)+(int32)1);
	for(j=0;j<n;j++)
  40b1b9:	48 83 c3 01          	add    $0x1,%rbx
  40b1bd:	48 83 fb 65          	cmp    $0x65,%rbx
  40b1c1:	75 e5                	jne    40b1a8 <DoLU+0x98>
/*
** Build an identity matrix.
** We'll also use this as a chance to load the solution
** vector.
*/
for(i=0;i<n;i++)
  40b1c3:	49 83 c5 01          	add    $0x1,%r13
  40b1c7:	49 81 c6 28 03 00 00 	add    $0x328,%r14
  40b1ce:	49 83 fd 65          	cmp    $0x65,%r13
  40b1d2:	75 b3                	jne    40b187 <DoLU+0x77>
  40b1d4:	4c 8d b5 f0 41 01 00 	lea    0x141f0(%rbp),%r14
  40b1db:	bf 4c df 40 00       	mov    $0x40df4c,%edi
  40b1e0:	48 89 eb             	mov    %rbp,%rbx
  40b1e3:	4d 89 e5             	mov    %r12,%r13
  40b1e6:	e8 a5 5c ff ff       	callq  400e90 <puts@plt>
  40b1eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
/*
	for(j=0;j<n;j++)
		printf("%6.2f ",a[i][j]);
*/
	printf("%.0f/%.0f=%.2f\t",b[i],a[i][i],b[i]/a[i][i]);
  40b1f0:	f2 41 0f 10 45 00    	movsd  0x0(%r13),%xmm0
  40b1f6:	be 55 df 40 00       	mov    $0x40df55,%esi
  40b1fb:	f2 0f 10 0b          	movsd  (%rbx),%xmm1
  40b1ff:	bf 01 00 00 00       	mov    $0x1,%edi
  40b204:	66 0f 28 d0          	movapd %xmm0,%xmm2
  40b208:	b8 03 00 00 00       	mov    $0x3,%eax
  40b20d:	48 81 c3 30 03 00 00 	add    $0x330,%rbx
  40b214:	49 83 c5 08          	add    $0x8,%r13
  40b218:	f2 0f 5e d1          	divsd  %xmm1,%xmm2
  40b21c:	e8 ef 5d ff ff       	callq  401010 <__printf_chk@plt>
			a[i][j]=(double)0.0;
}

#ifdef DEBUG
printf("Problem:\n");
for(i=0;i<n;i++)
  40b221:	49 39 de             	cmp    %rbx,%r14
  40b224:	75 ca                	jne    40b1f0 <DoLU+0xe0>
  40b226:	41 bd 28 03 00 00    	mov    $0x328,%r13d
	** first.  Note that we also occasionally multiply
	** by minus 1 so that we get a subtraction operation.
	*/
        /* k=abs_randwc((long)n); */
        /* k1=abs_randwc((long)n); */
	k=abs_randwc((int32)n);
  40b22c:	bf 65 00 00 00       	mov    $0x65,%edi
  40b231:	e8 4a 95 ff ff       	callq  404780 <abs_randwc>
	k1=abs_randwc((int32)n);
  40b236:	bf 65 00 00 00       	mov    $0x65,%edi
	** first.  Note that we also occasionally multiply
	** by minus 1 so that we get a subtraction operation.
	*/
        /* k=abs_randwc((long)n); */
        /* k1=abs_randwc((long)n); */
	k=abs_randwc((int32)n);
  40b23b:	89 c3                	mov    %eax,%ebx
	k1=abs_randwc((int32)n);
  40b23d:	e8 3e 95 ff ff       	callq  404780 <abs_randwc>
  40b242:	41 89 c1             	mov    %eax,%r9d
	if(k!=k1)
  40b245:	4c 39 cb             	cmp    %r9,%rbx
  40b248:	0f 84 00 01 00 00    	je     40b34e <DoLU+0x23e>
	{
		if(k<k1) rcon=(double)1.0;
			else rcon=(double)-1.0;
  40b24e:	f2 0f 10 0d a2 30 00 	movsd  0x30a2(%rip),%xmm1        # 40e2f8 <jtable.3055+0x1568>
  40b255:	00 
        /* k1=abs_randwc((long)n); */
	k=abs_randwc((int32)n);
	k1=abs_randwc((int32)n);
	if(k!=k1)
	{
		if(k<k1) rcon=(double)1.0;
  40b256:	7d 08                	jge    40b260 <DoLU+0x150>
  40b258:	f2 0f 10 0d 10 2b 00 	movsd  0x2b10(%rip),%xmm1        # 40dd70 <jtable.3055+0xfe0>
  40b25f:	00 
  40b260:	48 69 d3 28 03 00 00 	imul   $0x328,%rbx,%rdx
  40b267:	49 69 c1 28 03 00 00 	imul   $0x328,%r9,%rax
  40b26e:	48 8d 72 10          	lea    0x10(%rdx),%rsi
  40b272:	48 8d 4c 15 00       	lea    0x0(%rbp,%rdx,1),%rcx
  40b277:	48 8d 7c 05 00       	lea    0x0(%rbp,%rax,1),%rdi
  40b27c:	48 39 c6             	cmp    %rax,%rsi
  40b27f:	7e 0d                	jle    40b28e <DoLU+0x17e>
  40b281:	48 83 c0 10          	add    $0x10,%rax
  40b285:	48 39 d0             	cmp    %rdx,%rax
  40b288:	0f 8f df 07 00 00    	jg     40ba6d <DoLU+0x95d>
  40b28e:	48 89 c8             	mov    %rcx,%rax
  40b291:	48 c1 e0 3c          	shl    $0x3c,%rax
  40b295:	48 c1 e8 3f          	shr    $0x3f,%rax
  40b299:	48 85 c0             	test   %rax,%rax
  40b29c:	0f 84 bd 07 00 00    	je     40ba5f <DoLU+0x94f>
			else rcon=(double)-1.0;
		for(j=0;j<n;j++)
			a[k][j]+=a[k1][j]*rcon;;
  40b2a2:	f2 0f 10 07          	movsd  (%rdi),%xmm0
  40b2a6:	41 ba 64 00 00 00    	mov    $0x64,%r10d
	k1=abs_randwc((int32)n);
	if(k!=k1)
	{
		if(k<k1) rcon=(double)1.0;
			else rcon=(double)-1.0;
		for(j=0;j<n;j++)
  40b2ac:	41 bb 01 00 00 00    	mov    $0x1,%r11d
			a[k][j]+=a[k1][j]*rcon;;
  40b2b2:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  40b2b6:	f2 0f 58 01          	addsd  (%rcx),%xmm0
  40b2ba:	f2 0f 11 01          	movsd  %xmm0,(%rcx)
  40b2be:	48 8d 14 9b          	lea    (%rbx,%rbx,4),%rdx
  40b2c2:	66 0f 28 d1          	movapd %xmm1,%xmm2
  40b2c6:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
  40b2ca:	66 0f 14 d2          	unpcklpd %xmm2,%xmm2
  40b2ce:	48 8d 14 93          	lea    (%rbx,%rdx,4),%rdx
  40b2d2:	48 01 c2             	add    %rax,%rdx
  40b2d5:	48 8d 74 d5 00       	lea    0x0(%rbp,%rdx,8),%rsi
  40b2da:	4b 8d 14 89          	lea    (%r9,%r9,4),%rdx
  40b2de:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
  40b2e2:	49 8d 14 91          	lea    (%r9,%rdx,4),%rdx
  40b2e6:	48 01 d0             	add    %rdx,%rax
	k1=abs_randwc((int32)n);
	if(k!=k1)
	{
		if(k<k1) rcon=(double)1.0;
			else rcon=(double)-1.0;
		for(j=0;j<n;j++)
  40b2e9:	31 d2                	xor    %edx,%edx
  40b2eb:	4c 8d 44 c5 00       	lea    0x0(%rbp,%rax,8),%r8
  40b2f0:	31 c0                	xor    %eax,%eax
  40b2f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			a[k][j]+=a[k1][j]*rcon;;
  40b2f8:	66 41 0f 10 04 00    	movupd (%r8,%rax,1),%xmm0
  40b2fe:	48 83 c2 01          	add    $0x1,%rdx
  40b302:	66 0f 59 c2          	mulpd  %xmm2,%xmm0
  40b306:	66 0f 58 04 06       	addpd  (%rsi,%rax,1),%xmm0
  40b30b:	0f 29 04 06          	movaps %xmm0,(%rsi,%rax,1)
  40b30f:	48 83 c0 10          	add    $0x10,%rax
  40b313:	48 83 fa 31          	cmp    $0x31,%rdx
  40b317:	76 df                	jbe    40b2f8 <DoLU+0x1e8>
  40b319:	49 83 fa 64          	cmp    $0x64,%r10
  40b31d:	49 8d 43 64          	lea    0x64(%r11),%rax
  40b321:	74 15                	je     40b338 <DoLU+0x228>
  40b323:	f2 0f 10 04 c7       	movsd  (%rdi,%rax,8),%xmm0
  40b328:	48 8d 14 c1          	lea    (%rcx,%rax,8),%rdx
  40b32c:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  40b330:	f2 0f 58 02          	addsd  (%rdx),%xmm0
  40b334:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
		b[k]+=b[k1]*rcon;
  40b338:	f2 43 0f 59 0c cc    	mulsd  (%r12,%r9,8),%xmm1
  40b33e:	49 8d 04 dc          	lea    (%r12,%rbx,8),%rax
  40b342:	f2 0f 10 00          	movsd  (%rax),%xmm0
  40b346:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  40b34a:	f2 0f 11 00          	movsd  %xmm0,(%rax)
/*
** Scramble.  Do this 8n times.  See comment above for
** a description of the scrambling process.
*/

for(i=0;i<8*n;i++)
  40b34e:	49 83 ed 01          	sub    $0x1,%r13
  40b352:	0f 85 d4 fe ff ff    	jne    40b22c <DoLU+0x11c>
/*
** Now that we have a problem built, see if we need to do
** auto-adjust.  If so, repeatedly call the DoLUIteration routine,
** increasing the number of solutions per iteration as you go.
*/
if(loclustruct->adjust==0)
  40b358:	8b 15 c2 53 20 00    	mov    0x2053c2(%rip),%edx        # 610720 <global_lustruct>
  40b35e:	85 d2                	test   %edx,%edx
  40b360:	0f 85 6d 08 00 00    	jne    40bbd3 <DoLU+0xac3>
  40b366:	48 89 e8             	mov    %rbp,%rax
{
	loclustruct->numarrays=0;
  40b369:	48 c7 05 bc 53 20 00 	movq   $0x0,0x2053bc(%rip)        # 610730 <global_lustruct+0x10>
  40b370:	00 00 00 00 
  40b374:	48 c7 44 24 68 50 06 	movq   $0x650,0x68(%rsp)
  40b37b:	00 00 
  40b37d:	48 c1 e0 3c          	shl    $0x3c,%rax
  40b381:	48 c7 44 24 08 01 00 	movq   $0x1,0x8(%rsp)
  40b388:	00 00 
  40b38a:	48 c7 44 24 40 90 7d 	movq   $0x27d90,0x40(%rsp)
  40b391:	02 00 
  40b393:	48 c1 e8 3f          	shr    $0x3f,%rax
  40b397:	48 89 c3             	mov    %rax,%rbx
  40b39a:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
  40b39f:	b8 d9 27 00 00       	mov    $0x27d9,%eax
  40b3a4:	48 89 c7             	mov    %rax,%rdi
  40b3a7:	48 89 d8             	mov    %rbx,%rax
  40b3aa:	48 c1 e0 03          	shl    $0x3,%rax
  40b3ae:	48 29 df             	sub    %rbx,%rdi
  40b3b1:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  40b3b6:	4c 8d 74 05 00       	lea    0x0(%rbp,%rax,1),%r14
  40b3bb:	4c 89 e0             	mov    %r12,%rax
  40b3be:	48 c1 e0 3c          	shl    $0x3c,%rax
  40b3c2:	48 89 7c 24 58       	mov    %rdi,0x58(%rsp)
  40b3c7:	48 c1 e8 3f          	shr    $0x3f,%rax
  40b3cb:	48 89 c3             	mov    %rax,%rbx
  40b3ce:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40b3d3:	b8 65 00 00 00       	mov    $0x65,%eax
  40b3d8:	48 89 c7             	mov    %rax,%rdi
  40b3db:	48 89 d8             	mov    %rbx,%rax
  40b3de:	48 c1 e0 03          	shl    $0x3,%rax
  40b3e2:	48 29 df             	sub    %rbx,%rdi
  40b3e5:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  40b3ea:	4d 8d 2c 04          	lea    (%r12,%rax,1),%r13
  40b3ee:	48 8d 84 24 a4 00 00 	lea    0xa4(%rsp),%rax
  40b3f5:	00 
  40b3f6:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  40b3fb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40b400:	48 8d 45 10          	lea    0x10(%rbp),%rax
  40b404:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40b409:	49 8d 44 24 10       	lea    0x10(%r12),%rax
  40b40e:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
	for(i=1;i<=MAXLUARRAYS;i++)
	{
		abase=(fardouble *)AllocateMemory(sizeof(double) *
  40b413:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
  40b418:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b41f:	00 
  40b420:	e8 0b 09 00 00       	callq  40bd30 <AllocateMemory>
			LUARRAYCOLS*LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
  40b425:	8b b4 24 a0 00 00 00 	mov    0xa0(%rsp),%esi
if(loclustruct->adjust==0)
{
	loclustruct->numarrays=0;
	for(i=1;i<=MAXLUARRAYS;i++)
	{
		abase=(fardouble *)AllocateMemory(sizeof(double) *
  40b42c:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
			LUARRAYCOLS*LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
  40b431:	85 f6                	test   %esi,%esi
  40b433:	0f 85 e6 05 00 00    	jne    40ba1f <DoLU+0x90f>
		{       ReportError(errorcontext,systemerror);
			LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
			ErrorExit();
		}
		bbase=(fardouble *)AllocateMemory(sizeof(double) *
  40b439:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
  40b43e:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b445:	00 
  40b446:	e8 e5 08 00 00       	callq  40bd30 <AllocateMemory>
			LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
  40b44b:	8b b4 24 a0 00 00 00 	mov    0xa0(%rsp),%esi
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
			LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
			ErrorExit();
		}
		bbase=(fardouble *)AllocateMemory(sizeof(double) *
  40b452:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
			LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
  40b457:	85 f6                	test   %esi,%esi
  40b459:	0f 85 6b 05 00 00    	jne    40b9ca <DoLU+0x8ba>
  40b45f:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  40b464:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
** auto-adjust.  If so, repeatedly call the DoLUIteration routine,
** increasing the number of solutions per iteration as you go.
*/
if(loclustruct->adjust==0)
{
	loclustruct->numarrays=0;
  40b469:	45 31 c9             	xor    %r9d,%r9d

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b46c:	48 8b 5c 24 78       	mov    0x78(%rsp),%rbx
** auto-adjust.  If so, repeatedly call the DoLUIteration routine,
** increasing the number of solutions per iteration as you go.
*/
if(loclustruct->adjust==0)
{
	loclustruct->numarrays=0;
  40b471:	31 ff                	xor    %edi,%edi

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b473:	45 31 d2             	xor    %r10d,%r10d
  40b476:	49 89 c0             	mov    %rax,%r8
** auto-adjust.  If so, repeatedly call the DoLUIteration routine,
** increasing the number of solutions per iteration as you go.
*/
if(loclustruct->adjust==0)
{
	loclustruct->numarrays=0;
  40b479:	4c 89 de             	mov    %r11,%rsi
  40b47c:	48 89 c1             	mov    %rax,%rcx

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b47f:	4c 89 5c 24 70       	mov    %r11,0x70(%rsp)
  40b484:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
  40b48b:	00 
  40b48c:	0f 1f 40 00          	nopl   0x0(%rax)
  40b490:	48 8d 41 10          	lea    0x10(%rcx),%rax
  40b494:	48 39 c5             	cmp    %rax,%rbp
  40b497:	73 0b                	jae    40b4a4 <DoLU+0x394>
  40b499:	48 39 4c 24 28       	cmp    %rcx,0x28(%rsp)
  40b49e:	0f 87 dd 04 00 00    	ja     40b981 <DoLU+0x871>
  40b4a4:	48 85 db             	test   %rbx,%rbx
  40b4a7:	74 09                	je     40b4b2 <DoLU+0x3a2>
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
  40b4a9:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
  40b4ae:	f2 0f 11 01          	movsd  %xmm0,(%rcx)
  40b4b2:	48 8b 44 24 60       	mov    0x60(%rsp),%rax

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b4b7:	31 d2                	xor    %edx,%edx
  40b4b9:	4c 8d 3c 38          	lea    (%rax,%rdi,1),%r15
  40b4bd:	31 c0                	xor    %eax,%eax
  40b4bf:	4d 01 c7             	add    %r8,%r15
  40b4c2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
  40b4c8:	66 41 0f 28 04 06    	movapd (%r14,%rax,1),%xmm0
  40b4ce:	48 83 c2 01          	add    $0x1,%rdx
  40b4d2:	41 0f 11 04 07       	movups %xmm0,(%r15,%rax,1)
  40b4d7:	48 83 c0 10          	add    $0x10,%rax
  40b4db:	48 81 fa eb 13 00 00 	cmp    $0x13eb,%rdx
  40b4e2:	76 e4                	jbe    40b4c8 <DoLU+0x3b8>
  40b4e4:	48 81 7c 24 58 d8 27 	cmpq   $0x27d8,0x58(%rsp)
  40b4eb:	00 00 
  40b4ed:	74 12                	je     40b501 <DoLU+0x3f1>
  40b4ef:	f2 0f 10 85 c0 3e 01 	movsd  0x13ec0(%rbp),%xmm0
  40b4f6:	00 
  40b4f7:	f2 41 0f 11 84 38 c0 	movsd  %xmm0,0x13ec0(%r8,%rdi,1)
  40b4fe:	3e 01 00 
  40b501:	48 8d 46 10          	lea    0x10(%rsi),%rax
  40b505:	49 39 c4             	cmp    %rax,%r12
  40b508:	73 0b                	jae    40b515 <DoLU+0x405>
  40b50a:	48 39 74 24 30       	cmp    %rsi,0x30(%rsp)
  40b50f:	0f 87 8f 04 00 00    	ja     40b9a4 <DoLU+0x894>
  40b515:	48 83 7c 24 18 00    	cmpq   $0x0,0x18(%rsp)
  40b51b:	74 0a                	je     40b527 <DoLU+0x417>
	for(i=0;i<LUARRAYROWS;i++)
		*(locbbase+i)=*(b+i);
  40b51d:	f2 41 0f 10 04 24    	movsd  (%r12),%xmm0
  40b523:	f2 0f 11 06          	movsd  %xmm0,(%rsi)
  40b527:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
  40b52c:	31 d2                	xor    %edx,%edx
  40b52e:	4e 8d 3c 08          	lea    (%rax,%r9,1),%r15
  40b532:	31 c0                	xor    %eax,%eax
  40b534:	4d 01 df             	add    %r11,%r15
  40b537:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40b53e:	00 00 
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
	for(i=0;i<LUARRAYROWS;i++)
		*(locbbase+i)=*(b+i);
  40b540:	66 41 0f 28 44 05 00 	movapd 0x0(%r13,%rax,1),%xmm0
  40b547:	48 83 c2 01          	add    $0x1,%rdx
  40b54b:	41 0f 11 04 07       	movups %xmm0,(%r15,%rax,1)
  40b550:	48 83 c0 10          	add    $0x10,%rax
  40b554:	48 83 fa 31          	cmp    $0x31,%rdx
  40b558:	76 e6                	jbe    40b540 <DoLU+0x430>
  40b55a:	48 83 7c 24 48 64    	cmpq   $0x64,0x48(%rsp)
  40b560:	74 14                	je     40b576 <DoLU+0x466>
  40b562:	f2 41 0f 10 84 24 20 	movsd  0x320(%r12),%xmm0
  40b569:	03 00 00 
  40b56c:	f2 43 0f 11 84 0b 20 	movsd  %xmm0,0x320(%r11,%r9,1)
  40b573:	03 00 00 

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b576:	49 83 c2 01          	add    $0x1,%r10
  40b57a:	48 81 c7 c8 3e 01 00 	add    $0x13ec8,%rdi
  40b581:	48 81 c1 c8 3e 01 00 	add    $0x13ec8,%rcx
  40b588:	48 81 c6 28 03 00 00 	add    $0x328,%rsi
  40b58f:	49 81 c1 28 03 00 00 	add    $0x328,%r9
  40b596:	4c 3b 54 24 08       	cmp    0x8(%rsp),%r10
  40b59b:	0f 82 ef fe ff ff    	jb     40b490 <DoLU+0x380>
  40b5a1:	4c 8b 84 24 80 00 00 	mov    0x80(%rsp),%r8
  40b5a8:	00 
}

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
  40b5a9:	31 c0                	xor    %eax,%eax
for(i=0;i<numarrays;i++)
  40b5ab:	31 db                	xor    %ebx,%ebx
  40b5ad:	4c 8b 7c 24 70       	mov    0x70(%rsp),%r15
  40b5b2:	4c 89 84 24 90 00 00 	mov    %r8,0x90(%rsp)
  40b5b9:	00 
}

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
  40b5ba:	e8 f1 0b 00 00       	callq  40c1b0 <StartStopwatch>
for(i=0;i<numarrays;i++)
  40b5bf:	4c 8b 84 24 90 00 00 	mov    0x90(%rsp),%r8
  40b5c6:	00 
  40b5c7:	48 89 ac 24 80 00 00 	mov    %rbp,0x80(%rsp)
  40b5ce:	00 
  40b5cf:	48 89 dd             	mov    %rbx,%rbp
  40b5d2:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  40b5d7:	4c 89 a4 24 88 00 00 	mov    %r12,0x88(%rsp)
  40b5de:	00 
}

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
  40b5df:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
for(i=0;i<numarrays;i++)
  40b5e4:	4d 89 c4             	mov    %r8,%r12
  40b5e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40b5ee:	00 00 
{       locabase=abase+i*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+i*LUARRAYROWS;
	ptra.ptrs.p=locabase;
	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
  40b5f0:	4c 89 fe             	mov    %r15,%rsi
  40b5f3:	4c 89 e7             	mov    %r12,%rdi

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
for(i=0;i<numarrays;i++)
  40b5f6:	48 83 c5 01          	add    $0x1,%rbp
{       locabase=abase+i*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+i*LUARRAYROWS;
	ptra.ptrs.p=locabase;
	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
  40b5fa:	e8 91 d1 ff ff       	callq  408790 <lusolve.constprop.6>
  40b5ff:	49 81 c4 c8 3e 01 00 	add    $0x13ec8,%r12
  40b606:	49 81 c7 28 03 00 00 	add    $0x328,%r15

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
for(i=0;i<numarrays;i++)
  40b60d:	48 39 dd             	cmp    %rbx,%rbp
  40b610:	72 de                	jb     40b5f0 <DoLU+0x4e0>
	locbbase=bbase+i*LUARRAYROWS;
	ptra.ptrs.p=locabase;
	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
}

return(StopStopwatch(elapsed));
  40b612:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
  40b617:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
  40b61e:	00 
  40b61f:	4c 8b a4 24 88 00 00 	mov    0x88(%rsp),%r12
  40b626:	00 
  40b627:	e8 94 0b 00 00       	callq  40c1c0 <StopStopwatch>
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
			LUFreeMem(a,b,abase,(fardouble *)NULL);
			ErrorExit();
		}
		if(DoLUIteration(a,b,abase,bbase,i)>global_min_ticks)
  40b62c:	48 39 05 8d 50 20 00 	cmp    %rax,0x20508d(%rip)        # 6106c0 <global_min_ticks>
  40b633:	0f 82 63 05 00 00    	jb     40bb9c <DoLU+0xa8c>
			break;
		}
		/*
		** Not enough arrays...free them all and try again
		*/
		FreeMemory((farvoid *)abase,&systemerror);
  40b639:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  40b63e:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b645:	00 
  40b646:	e8 e5 07 00 00       	callq  40be30 <FreeMemory>
		FreeMemory((farvoid *)bbase,&systemerror);
  40b64b:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
  40b650:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40b657:	00 
  40b658:	e8 d3 07 00 00       	callq  40be30 <FreeMemory>
  40b65d:	48 81 44 24 40 c8 3e 	addq   $0x13ec8,0x40(%rsp)
  40b664:	01 00 
  40b666:	48 83 44 24 08 01    	addq   $0x1,0x8(%rsp)
  40b66c:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40b671:	48 81 44 24 68 28 03 	addq   $0x328,0x68(%rsp)
  40b678:	00 00 
** increasing the number of solutions per iteration as you go.
*/
if(loclustruct->adjust==0)
{
	loclustruct->numarrays=0;
	for(i=1;i<=MAXLUARRAYS;i++)
  40b67a:	48 3d 10 e2 a6 30    	cmp    $0x30a6e210,%rax
  40b680:	0f 85 8d fd ff ff    	jne    40b413 <DoLU+0x303>
  40b686:	48 8b 05 a3 50 20 00 	mov    0x2050a3(%rip),%rax        # 610730 <global_lustruct+0x10>
  40b68d:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
		FreeMemory((farvoid *)bbase,&systemerror);
	}
	/*
	** Were we able to do it?
	*/
	if(loclustruct->numarrays==0)
  40b692:	48 85 c0             	test   %rax,%rax
  40b695:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40b69a:	0f 84 da 05 00 00    	je     40bc7a <DoLU+0xb6a>
  40b6a0:	48 89 e8             	mov    %rbp,%rax
}
/*
** All's well if we get here.  Do the test.
*/
accumtime=0L;
iterations=(double)0.0;
  40b6a3:	66 0f ef e4          	pxor   %xmm4,%xmm4
  40b6a7:	48 c1 e0 3c          	shl    $0x3c,%rax
	}
}
/*
** All's well if we get here.  Do the test.
*/
accumtime=0L;
  40b6ab:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  40b6b2:	00 00 
  40b6b4:	48 c1 e8 3f          	shr    $0x3f,%rax
  40b6b8:	48 89 c7             	mov    %rax,%rdi
  40b6bb:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  40b6c0:	b8 d9 27 00 00       	mov    $0x27d9,%eax
  40b6c5:	48 89 c1             	mov    %rax,%rcx
  40b6c8:	48 89 f8             	mov    %rdi,%rax
iterations=(double)0.0;
  40b6cb:	f2 0f 11 64 24 40    	movsd  %xmm4,0x40(%rsp)
  40b6d1:	48 c1 e0 03          	shl    $0x3,%rax
  40b6d5:	48 29 f9             	sub    %rdi,%rcx
  40b6d8:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  40b6dd:	4c 8d 74 05 00       	lea    0x0(%rbp,%rax,1),%r14
  40b6e2:	4c 89 e0             	mov    %r12,%rax
  40b6e5:	48 c1 e0 3c          	shl    $0x3c,%rax
  40b6e9:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
  40b6ee:	48 c1 e8 3f          	shr    $0x3f,%rax
  40b6f2:	48 89 c7             	mov    %rax,%rdi
  40b6f5:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  40b6fa:	b8 65 00 00 00       	mov    $0x65,%eax
  40b6ff:	48 89 c1             	mov    %rax,%rcx
  40b702:	48 89 f8             	mov    %rdi,%rax
  40b705:	48 c1 e0 03          	shl    $0x3,%rax
  40b709:	48 29 f9             	sub    %rdi,%rcx
  40b70c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  40b711:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
  40b716:	4d 8d 2c 04          	lea    (%r12,%rax,1),%r13
  40b71a:	49 8d 44 24 10       	lea    0x10(%r12),%rax
  40b71f:	48 89 4c 24 50       	mov    %rcx,0x50(%rsp)
  40b724:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40b729:	48 8d 45 10          	lea    0x10(%rbp),%rax

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b72d:	48 85 ff             	test   %rdi,%rdi
  40b730:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  40b735:	0f 84 35 02 00 00    	je     40b970 <DoLU+0x860>
  40b73b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40b740:	4c 8b 4c 24 70       	mov    0x70(%rsp),%r9
  40b745:	48 89 de             	mov    %rbx,%rsi
  40b748:	4c 69 ff c8 3e 01 00 	imul   $0x13ec8,%rdi,%r15
  40b74f:	45 31 d2             	xor    %r10d,%r10d
  40b752:	31 ff                	xor    %edi,%edi
  40b754:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  40b759:	48 89 c1             	mov    %rax,%rcx
  40b75c:	49 89 c0             	mov    %rax,%r8
  40b75f:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
  40b764:	0f 1f 40 00          	nopl   0x0(%rax)
  40b768:	48 8d 44 3b 10       	lea    0x10(%rbx,%rdi,1),%rax
  40b76d:	48 39 c5             	cmp    %rax,%rbp
  40b770:	73 0b                	jae    40b77d <DoLU+0x66d>
  40b772:	48 39 74 24 30       	cmp    %rsi,0x30(%rsp)
  40b777:	0f 87 35 03 00 00    	ja     40bab2 <DoLU+0x9a2>
  40b77d:	48 83 7c 24 28 00    	cmpq   $0x0,0x28(%rsp)
  40b783:	74 09                	je     40b78e <DoLU+0x67e>
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
  40b785:	f2 0f 10 45 00       	movsd  0x0(%rbp),%xmm0
  40b78a:	f2 0f 11 06          	movsd  %xmm0,(%rsi)
  40b78e:	48 8b 44 24 60       	mov    0x60(%rsp),%rax

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b793:	31 d2                	xor    %edx,%edx
  40b795:	4c 8d 1c 38          	lea    (%rax,%rdi,1),%r11
  40b799:	31 c0                	xor    %eax,%eax
  40b79b:	49 01 db             	add    %rbx,%r11
  40b79e:	66 90                	xchg   %ax,%ax
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
  40b7a0:	66 41 0f 28 04 06    	movapd (%r14,%rax,1),%xmm0
  40b7a6:	48 83 c2 01          	add    $0x1,%rdx
  40b7aa:	41 0f 11 04 03       	movups %xmm0,(%r11,%rax,1)
  40b7af:	48 83 c0 10          	add    $0x10,%rax
  40b7b3:	48 81 fa eb 13 00 00 	cmp    $0x13eb,%rdx
  40b7ba:	76 e4                	jbe    40b7a0 <DoLU+0x690>
  40b7bc:	48 81 7c 24 58 d8 27 	cmpq   $0x27d8,0x58(%rsp)
  40b7c3:	00 00 
  40b7c5:	74 11                	je     40b7d8 <DoLU+0x6c8>
  40b7c7:	f2 0f 10 85 c0 3e 01 	movsd  0x13ec0(%rbp),%xmm0
  40b7ce:	00 
  40b7cf:	f2 0f 11 84 3b c0 3e 	movsd  %xmm0,0x13ec0(%rbx,%rdi,1)
  40b7d6:	01 00 
  40b7d8:	48 39 4c 24 18       	cmp    %rcx,0x18(%rsp)
  40b7dd:	76 0d                	jbe    40b7ec <DoLU+0x6dc>
  40b7df:	48 8d 41 10          	lea    0x10(%rcx),%rax
  40b7e3:	49 39 c4             	cmp    %rax,%r12
  40b7e6:	0f 82 a6 02 00 00    	jb     40ba92 <DoLU+0x982>
  40b7ec:	4d 85 c9             	test   %r9,%r9
  40b7ef:	74 0a                	je     40b7fb <DoLU+0x6eb>
	for(i=0;i<LUARRAYROWS;i++)
		*(locbbase+i)=*(b+i);
  40b7f1:	f2 41 0f 10 04 24    	movsd  (%r12),%xmm0
  40b7f7:	f2 0f 11 01          	movsd  %xmm0,(%rcx)
  40b7fb:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
  40b800:	31 d2                	xor    %edx,%edx
  40b802:	4e 8d 1c 10          	lea    (%rax,%r10,1),%r11
  40b806:	31 c0                	xor    %eax,%eax
  40b808:	4d 01 c3             	add    %r8,%r11
  40b80b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
	for(i=0;i<LUARRAYROWS;i++)
		*(locbbase+i)=*(b+i);
  40b810:	66 41 0f 28 44 05 00 	movapd 0x0(%r13,%rax,1),%xmm0
  40b817:	48 83 c2 01          	add    $0x1,%rdx
  40b81b:	41 0f 11 04 03       	movups %xmm0,(%r11,%rax,1)
  40b820:	48 83 c0 10          	add    $0x10,%rax
  40b824:	48 83 fa 31          	cmp    $0x31,%rdx
  40b828:	76 e6                	jbe    40b810 <DoLU+0x700>
  40b82a:	48 83 7c 24 50 64    	cmpq   $0x64,0x50(%rsp)
  40b830:	74 14                	je     40b846 <DoLU+0x736>
  40b832:	f2 41 0f 10 84 24 20 	movsd  0x320(%r12),%xmm0
  40b839:	03 00 00 
  40b83c:	f2 43 0f 11 84 10 20 	movsd  %xmm0,0x320(%r8,%r10,1)
  40b843:	03 00 00 
  40b846:	48 81 c7 c8 3e 01 00 	add    $0x13ec8,%rdi
  40b84d:	48 81 c6 c8 3e 01 00 	add    $0x13ec8,%rsi
  40b854:	48 81 c1 28 03 00 00 	add    $0x328,%rcx
  40b85b:	49 81 c2 28 03 00 00 	add    $0x328,%r10

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b862:	49 39 ff             	cmp    %rdi,%r15
  40b865:	0f 85 fd fe ff ff    	jne    40b768 <DoLU+0x658>
  40b86b:	4c 8b 44 24 68       	mov    0x68(%rsp),%r8
  40b870:	4c 8b 4c 24 78       	mov    0x78(%rsp),%r9
}

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
  40b875:	31 c0                	xor    %eax,%eax
  40b877:	45 31 ff             	xor    %r15d,%r15d
  40b87a:	4c 89 8c 24 98 00 00 	mov    %r9,0x98(%rsp)
  40b881:	00 
  40b882:	4c 89 84 24 90 00 00 	mov    %r8,0x90(%rsp)
  40b889:	00 
  40b88a:	e8 21 09 00 00       	callq  40c1b0 <StartStopwatch>
  40b88f:	4c 8b 84 24 90 00 00 	mov    0x90(%rsp),%r8
  40b896:	00 
  40b897:	4c 8b 8c 24 98 00 00 	mov    0x98(%rsp),%r9
  40b89e:	00 
  40b89f:	48 89 5c 24 78       	mov    %rbx,0x78(%rsp)
  40b8a4:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  40b8a9:	48 89 ac 24 80 00 00 	mov    %rbp,0x80(%rsp)
  40b8b0:	00 
  40b8b1:	4c 89 a4 24 88 00 00 	mov    %r12,0x88(%rsp)
  40b8b8:	00 
  40b8b9:	4c 89 fd             	mov    %r15,%rbp
  40b8bc:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  40b8c1:	4d 89 f7             	mov    %r14,%r15
  40b8c4:	4d 89 c4             	mov    %r8,%r12
  40b8c7:	4d 89 ee             	mov    %r13,%r14
  40b8ca:	4d 89 cd             	mov    %r9,%r13
  40b8cd:	0f 1f 00             	nopl   (%rax)
for(i=0;i<numarrays;i++)
{       locabase=abase+i*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+i*LUARRAYROWS;
	ptra.ptrs.p=locabase;
	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
  40b8d0:	4c 89 ee             	mov    %r13,%rsi
  40b8d3:	4c 89 e7             	mov    %r12,%rdi

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
for(i=0;i<numarrays;i++)
  40b8d6:	48 83 c5 01          	add    $0x1,%rbp
{       locabase=abase+i*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+i*LUARRAYROWS;
	ptra.ptrs.p=locabase;
	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
  40b8da:	e8 b1 ce ff ff       	callq  408790 <lusolve.constprop.6>
  40b8df:	49 81 c4 c8 3e 01 00 	add    $0x13ec8,%r12
  40b8e6:	49 81 c5 28 03 00 00 	add    $0x328,%r13

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
for(i=0;i<numarrays;i++)
  40b8ed:	48 39 dd             	cmp    %rbx,%rbp
  40b8f0:	75 de                	jne    40b8d0 <DoLU+0x7c0>
  40b8f2:	48 8b 5c 24 78       	mov    0x78(%rsp),%rbx
  40b8f7:	48 8b ac 24 80 00 00 	mov    0x80(%rsp),%rbp
  40b8fe:	00 
  40b8ff:	4d 89 f5             	mov    %r14,%r13
  40b902:	4c 8b a4 24 88 00 00 	mov    0x88(%rsp),%r12
  40b909:	00 
  40b90a:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
  40b90f:	4d 89 fe             	mov    %r15,%r14
	locbbase=bbase+i*LUARRAYROWS;
	ptra.ptrs.p=locabase;
	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
}

return(StopStopwatch(elapsed));
  40b912:	e8 a9 08 00 00       	callq  40c1c0 <StopStopwatch>
*/
accumtime=0L;
iterations=(double)0.0;

do {
	accumtime+=DoLUIteration(a,b,abase,bbase,
  40b917:	48 01 44 24 38       	add    %rax,0x38(%rsp)
		loclustruct->numarrays);
	iterations+=(double)loclustruct->numarrays;
  40b91c:	48 8b 05 0d 4e 20 00 	mov    0x204e0d(%rip),%rax        # 610730 <global_lustruct+0x10>
  40b923:	48 85 c0             	test   %rax,%rax
  40b926:	0f 88 a8 01 00 00    	js     40bad4 <DoLU+0x9c4>
  40b92c:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40b930:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40b935:	f2 0f 58 44 24 40    	addsd  0x40(%rsp),%xmm0
} while(TicksToSecs(accumtime)<loclustruct->request_secs);
  40b93b:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
iterations=(double)0.0;

do {
	accumtime+=DoLUIteration(a,b,abase,bbase,
		loclustruct->numarrays);
	iterations+=(double)loclustruct->numarrays;
  40b940:	f2 0f 11 44 24 40    	movsd  %xmm0,0x40(%rsp)
} while(TicksToSecs(accumtime)<loclustruct->request_secs);
  40b946:	e8 85 08 00 00       	callq  40c1d0 <TicksToSecs>
  40b94b:	48 3b 05 d6 4d 20 00 	cmp    0x204dd6(%rip),%rax        # 610728 <global_lustruct+0x8>
  40b952:	0f 83 9a 01 00 00    	jae    40baf2 <DoLU+0x9e2>
  40b958:	48 8b 05 d1 4d 20 00 	mov    0x204dd1(%rip),%rax        # 610730 <global_lustruct+0x10>
  40b95f:	48 89 c7             	mov    %rax,%rdi
  40b962:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

/*
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
  40b967:	48 85 ff             	test   %rdi,%rdi
  40b96a:	0f 85 cb fd ff ff    	jne    40b73b <DoLU+0x62b>
}

/*
** Do test...begin timing.
*/
elapsed=StartStopwatch();
  40b970:	31 c0                	xor    %eax,%eax
  40b972:	e8 39 08 00 00       	callq  40c1b0 <StartStopwatch>
  40b977:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  40b97c:	48 89 c7             	mov    %rax,%rdi
  40b97f:	eb 91                	jmp    40b912 <DoLU+0x802>
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
  40b981:	31 c0                	xor    %eax,%eax
  40b983:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
  40b988:	f2 0f 10 44 c5 00    	movsd  0x0(%rbp,%rax,8),%xmm0
  40b98e:	f2 0f 11 04 c1       	movsd  %xmm0,(%rcx,%rax,8)
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
  40b993:	48 83 c0 01          	add    $0x1,%rax
  40b997:	48 3d d9 27 00 00    	cmp    $0x27d9,%rax
  40b99d:	75 e9                	jne    40b988 <DoLU+0x878>
  40b99f:	e9 5d fb ff ff       	jmpq   40b501 <DoLU+0x3f1>
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
  40b9a4:	31 c0                	xor    %eax,%eax
  40b9a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40b9ad:	00 00 00 
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
	for(i=0;i<LUARRAYROWS;i++)
		*(locbbase+i)=*(b+i);
  40b9b0:	f2 41 0f 10 04 c4    	movsd  (%r12,%rax,8),%xmm0
  40b9b6:	f2 0f 11 04 c6       	movsd  %xmm0,(%rsi,%rax,8)
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
	for(i=0;i<LUARRAYROWS;i++)
  40b9bb:	48 83 c0 01          	add    $0x1,%rax
  40b9bf:	48 83 f8 65          	cmp    $0x65,%rax
  40b9c3:	75 eb                	jne    40b9b0 <DoLU+0x8a0>
  40b9c5:	e9 ac fb ff ff       	jmpq   40b576 <DoLU+0x466>
			ErrorExit();
		}
		bbase=(fardouble *)AllocateMemory(sizeof(double) *
			LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
  40b9ca:	bf 65 df 40 00       	mov    $0x40df65,%edi
  40b9cf:	e8 9c 07 00 00       	callq  40c170 <ReportError>
static void LUFreeMem(fardouble *a, fardouble *b,
			fardouble *abase,fardouble *bbase)
{
int systemerror;

FreeMemory((farvoid *)a,&systemerror);
  40b9d4:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
  40b9d9:	48 89 ef             	mov    %rbp,%rdi
  40b9dc:	48 89 de             	mov    %rbx,%rsi
  40b9df:	e8 4c 04 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)b,&systemerror);
  40b9e4:	48 89 de             	mov    %rbx,%rsi
  40b9e7:	4c 89 e7             	mov    %r12,%rdi
  40b9ea:	e8 41 04 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)LUtempvv,&systemerror);
  40b9ef:	48 8b 3d 2a 63 20 00 	mov    0x20632a(%rip),%rdi        # 611d20 <LUtempvv>
  40b9f6:	48 89 de             	mov    %rbx,%rsi
  40b9f9:	e8 32 04 00 00       	callq  40be30 <FreeMemory>

if(abase!=(fardouble *)NULL) FreeMemory((farvoid *)abase,&systemerror);
  40b9fe:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  40ba03:	48 85 c0             	test   %rax,%rax
  40ba06:	74 0b                	je     40ba13 <DoLU+0x903>
  40ba08:	48 89 de             	mov    %rbx,%rsi
  40ba0b:	48 89 c7             	mov    %rax,%rdi
  40ba0e:	e8 1d 04 00 00       	callq  40be30 <FreeMemory>
		bbase=(fardouble *)AllocateMemory(sizeof(double) *
			LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
			LUFreeMem(a,b,abase,(fardouble *)NULL);
			ErrorExit();
  40ba13:	31 c0                	xor    %eax,%eax
  40ba15:	e8 86 07 00 00       	callq  40c1a0 <ErrorExit>
  40ba1a:	e9 40 fa ff ff       	jmpq   40b45f <DoLU+0x34f>
	for(i=1;i<=MAXLUARRAYS;i++)
	{
		abase=(fardouble *)AllocateMemory(sizeof(double) *
			LUARRAYCOLS*LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
  40ba1f:	bf 65 df 40 00       	mov    $0x40df65,%edi
  40ba24:	e8 47 07 00 00       	callq  40c170 <ReportError>
static void LUFreeMem(fardouble *a, fardouble *b,
			fardouble *abase,fardouble *bbase)
{
int systemerror;

FreeMemory((farvoid *)a,&systemerror);
  40ba29:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
  40ba2e:	48 89 ef             	mov    %rbp,%rdi
  40ba31:	48 89 de             	mov    %rbx,%rsi
  40ba34:	e8 f7 03 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)b,&systemerror);
  40ba39:	48 89 de             	mov    %rbx,%rsi
  40ba3c:	4c 89 e7             	mov    %r12,%rdi
  40ba3f:	e8 ec 03 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)LUtempvv,&systemerror);
  40ba44:	48 8b 3d d5 62 20 00 	mov    0x2062d5(%rip),%rdi        # 611d20 <LUtempvv>
  40ba4b:	48 89 de             	mov    %rbx,%rsi
  40ba4e:	e8 dd 03 00 00       	callq  40be30 <FreeMemory>
		abase=(fardouble *)AllocateMemory(sizeof(double) *
			LUARRAYCOLS*LUARRAYROWS*(i+1),&systemerror);
		if(systemerror)
		{       ReportError(errorcontext,systemerror);
			LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
			ErrorExit();
  40ba53:	31 c0                	xor    %eax,%eax
  40ba55:	e8 46 07 00 00       	callq  40c1a0 <ErrorExit>
  40ba5a:	e9 da f9 ff ff       	jmpq   40b439 <DoLU+0x329>
	k1=abs_randwc((int32)n);
	if(k!=k1)
	{
		if(k<k1) rcon=(double)1.0;
			else rcon=(double)-1.0;
		for(j=0;j<n;j++)
  40ba5f:	41 ba 65 00 00 00    	mov    $0x65,%r10d
  40ba65:	45 31 db             	xor    %r11d,%r11d
  40ba68:	e9 51 f8 ff ff       	jmpq   40b2be <DoLU+0x1ae>
  40ba6d:	31 c0                	xor    %eax,%eax
  40ba6f:	90                   	nop
			a[k][j]+=a[k1][j]*rcon;;
  40ba70:	f2 0f 10 04 c7       	movsd  (%rdi,%rax,8),%xmm0
  40ba75:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  40ba79:	f2 0f 58 04 c1       	addsd  (%rcx,%rax,8),%xmm0
  40ba7e:	f2 0f 11 04 c1       	movsd  %xmm0,(%rcx,%rax,8)
	k1=abs_randwc((int32)n);
	if(k!=k1)
	{
		if(k<k1) rcon=(double)1.0;
			else rcon=(double)-1.0;
		for(j=0;j<n;j++)
  40ba83:	48 83 c0 01          	add    $0x1,%rax
  40ba87:	48 83 f8 65          	cmp    $0x65,%rax
  40ba8b:	75 e3                	jne    40ba70 <DoLU+0x960>
  40ba8d:	e9 a6 f8 ff ff       	jmpq   40b338 <DoLU+0x228>
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
  40ba92:	31 c0                	xor    %eax,%eax
  40ba94:	0f 1f 40 00          	nopl   0x0(%rax)
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
	for(i=0;i<LUARRAYROWS;i++)
		*(locbbase+i)=*(b+i);
  40ba98:	f2 41 0f 10 04 c4    	movsd  (%r12,%rax,8),%xmm0
  40ba9e:	f2 0f 11 04 c1       	movsd  %xmm0,(%rcx,%rax,8)
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
	for(i=0;i<LUARRAYROWS;i++)
  40baa3:	48 83 c0 01          	add    $0x1,%rax
  40baa7:	48 83 f8 65          	cmp    $0x65,%rax
  40baab:	75 eb                	jne    40ba98 <DoLU+0x988>
  40baad:	e9 94 fd ff ff       	jmpq   40b846 <DoLU+0x736>
** Move the seed arrays (a & b) into the destination
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
  40bab2:	31 c0                	xor    %eax,%eax
  40bab4:	0f 1f 40 00          	nopl   0x0(%rax)
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
		*(locabase+i)=*(a+i);
  40bab8:	f2 0f 10 44 c5 00    	movsd  0x0(%rbp,%rax,8),%xmm0
  40babe:	f2 0f 11 04 c6       	movsd  %xmm0,(%rsi,%rax,8)
** arrays;
*/
for(j=0;j<numarrays;j++)
{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
	locbbase=bbase+j*LUARRAYROWS;
	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
  40bac3:	48 83 c0 01          	add    $0x1,%rax
  40bac7:	48 3d d9 27 00 00    	cmp    $0x27d9,%rax
  40bacd:	75 e9                	jne    40bab8 <DoLU+0x9a8>
  40bacf:	e9 04 fd ff ff       	jmpq   40b7d8 <DoLU+0x6c8>
iterations=(double)0.0;

do {
	accumtime+=DoLUIteration(a,b,abase,bbase,
		loclustruct->numarrays);
	iterations+=(double)loclustruct->numarrays;
  40bad4:	48 89 c2             	mov    %rax,%rdx
  40bad7:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40badb:	48 d1 ea             	shr    %rdx
  40bade:	83 e0 01             	and    $0x1,%eax
  40bae1:	48 09 c2             	or     %rax,%rdx
  40bae4:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  40bae9:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40baed:	e9 43 fe ff ff       	jmpq   40b935 <DoLU+0x825>

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
loclustruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40baf2:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  40baf7:	e8 f4 06 00 00       	callq  40c1f0 <TicksToFracSecs>
  40bafc:	f2 0f 10 5c 24 40    	movsd  0x40(%rsp),%xmm3

if(loclustruct->adjust==0)
  40bb02:	8b 05 18 4c 20 00    	mov    0x204c18(%rip),%eax        # 610720 <global_lustruct>

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
loclustruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40bb08:	f2 0f 5e d8          	divsd  %xmm0,%xmm3

if(loclustruct->adjust==0)
  40bb0c:	85 c0                	test   %eax,%eax

/*
** Clean up, calculate results, and go home.  Be sure to
** show that we don't have to rerun adjustment code.
*/
loclustruct->iterspersec=iterations / TicksToFracSecs(accumtime);
  40bb0e:	f2 0f 11 1d 22 4c 20 	movsd  %xmm3,0x204c22(%rip)        # 610738 <global_lustruct+0x18>
  40bb15:	00 

if(loclustruct->adjust==0)
  40bb16:	75 0a                	jne    40bb22 <DoLU+0xa12>
	loclustruct->adjust=1;
  40bb18:	c7 05 fe 4b 20 00 01 	movl   $0x1,0x204bfe(%rip)        # 610720 <global_lustruct>
  40bb1f:	00 00 00 
static void LUFreeMem(fardouble *a, fardouble *b,
			fardouble *abase,fardouble *bbase)
{
int systemerror;

FreeMemory((farvoid *)a,&systemerror);
  40bb22:	4c 8b 7c 24 10       	mov    0x10(%rsp),%r15
  40bb27:	48 89 ef             	mov    %rbp,%rdi
  40bb2a:	4c 89 fe             	mov    %r15,%rsi
  40bb2d:	e8 fe 02 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)b,&systemerror);
  40bb32:	4c 89 fe             	mov    %r15,%rsi
  40bb35:	4c 89 e7             	mov    %r12,%rdi
  40bb38:	e8 f3 02 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)LUtempvv,&systemerror);
  40bb3d:	48 8b 3d dc 61 20 00 	mov    0x2061dc(%rip),%rdi        # 611d20 <LUtempvv>
  40bb44:	4c 89 fe             	mov    %r15,%rsi
  40bb47:	e8 e4 02 00 00       	callq  40be30 <FreeMemory>

if(abase!=(fardouble *)NULL) FreeMemory((farvoid *)abase,&systemerror);
  40bb4c:	48 85 db             	test   %rbx,%rbx
  40bb4f:	74 0b                	je     40bb5c <DoLU+0xa4c>
  40bb51:	4c 89 fe             	mov    %r15,%rsi
  40bb54:	48 89 df             	mov    %rbx,%rdi
  40bb57:	e8 d4 02 00 00       	callq  40be30 <FreeMemory>
if(bbase!=(fardouble *)NULL) FreeMemory((farvoid *)bbase,&systemerror);
  40bb5c:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40bb61:	48 85 c0             	test   %rax,%rax
  40bb64:	74 0d                	je     40bb73 <DoLU+0xa63>
  40bb66:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40bb6b:	48 89 c7             	mov    %rax,%rdi
  40bb6e:	e8 bd 02 00 00       	callq  40be30 <FreeMemory>
if(loclustruct->adjust==0)
	loclustruct->adjust=1;

LUFreeMem(a,b,abase,bbase);
return;
}
  40bb73:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
  40bb7a:	00 
  40bb7b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40bb82:	00 00 
  40bb84:	0f 85 54 01 00 00    	jne    40bcde <DoLU+0xbce>
  40bb8a:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
  40bb91:	5b                   	pop    %rbx
  40bb92:	5d                   	pop    %rbp
  40bb93:	41 5c                	pop    %r12
  40bb95:	41 5d                	pop    %r13
  40bb97:	41 5e                	pop    %r14
  40bb99:	41 5f                	pop    %r15
  40bb9b:	c3                   	retq   
		{       ReportError(errorcontext,systemerror);
			LUFreeMem(a,b,abase,(fardouble *)NULL);
			ErrorExit();
		}
		if(DoLUIteration(a,b,abase,bbase,i)>global_min_ticks)
		{       loclustruct->numarrays=i;
  40bb9c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40bba1:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
  40bba6:	48 89 05 83 4b 20 00 	mov    %rax,0x204b83(%rip)        # 610730 <global_lustruct+0x10>
  40bbad:	e9 ee fa ff ff       	jmpq   40b6a0 <DoLU+0x590>
{       /* b[i]=(double)(abs_randwc(100L)+1L); */
	b[i]=(double)(abs_randwc((int32)100)+(int32)1);
	for(j=0;j<n;j++)
		if(i==j)
		        /* a[i][j]=(double)(abs_randwc(1000L)+1L); */
			a[i][j]=(double)(abs_randwc((int32)1000)+(int32)1);
  40bbb2:	bf e8 03 00 00       	mov    $0x3e8,%edi
  40bbb7:	e8 c4 8b ff ff       	callq  404780 <abs_randwc>
  40bbbc:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40bbc0:	83 c0 01             	add    $0x1,%eax
  40bbc3:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40bbc8:	f2 41 0f 11 04 de    	movsd  %xmm0,(%r14,%rbx,8)
  40bbce:	e9 e6 f5 ff ff       	jmpq   40b1b9 <DoLU+0xa9>
else
{       /*
	** Don't need to adjust -- just allocate the proper
	** number of arrays and proceed.
	*/
	abase=(fardouble *)AllocateMemory(sizeof(double) *
  40bbd3:	48 69 3d 52 4b 20 00 	imul   $0x13ec8,0x204b52(%rip),%rdi        # 610730 <global_lustruct+0x10>
  40bbda:	c8 3e 01 00 
  40bbde:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40bbe5:	00 
  40bbe6:	e8 45 01 00 00       	callq  40bd30 <AllocateMemory>
		LUARRAYCOLS*LUARRAYROWS*loclustruct->numarrays,
		&systemerror);
	if(systemerror)
  40bbeb:	8b b4 24 a0 00 00 00 	mov    0xa0(%rsp),%esi
else
{       /*
	** Don't need to adjust -- just allocate the proper
	** number of arrays and proceed.
	*/
	abase=(fardouble *)AllocateMemory(sizeof(double) *
  40bbf2:	48 89 c3             	mov    %rax,%rbx
  40bbf5:	48 8d 84 24 a4 00 00 	lea    0xa4(%rsp),%rax
  40bbfc:	00 
  40bbfd:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		LUARRAYCOLS*LUARRAYROWS*loclustruct->numarrays,
		&systemerror);
	if(systemerror)
  40bc02:	85 f6                	test   %esi,%esi
  40bc04:	74 3b                	je     40bc41 <DoLU+0xb31>
	{       ReportError(errorcontext,systemerror);
  40bc06:	bf 65 df 40 00       	mov    $0x40df65,%edi
  40bc0b:	e8 60 05 00 00       	callq  40c170 <ReportError>
static void LUFreeMem(fardouble *a, fardouble *b,
			fardouble *abase,fardouble *bbase)
{
int systemerror;

FreeMemory((farvoid *)a,&systemerror);
  40bc10:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40bc15:	48 89 ef             	mov    %rbp,%rdi
  40bc18:	4c 89 f6             	mov    %r14,%rsi
  40bc1b:	e8 10 02 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)b,&systemerror);
  40bc20:	4c 89 f6             	mov    %r14,%rsi
  40bc23:	4c 89 e7             	mov    %r12,%rdi
  40bc26:	e8 05 02 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)LUtempvv,&systemerror);
  40bc2b:	48 8b 3d ee 60 20 00 	mov    0x2060ee(%rip),%rdi        # 611d20 <LUtempvv>
  40bc32:	4c 89 f6             	mov    %r14,%rsi
  40bc35:	e8 f6 01 00 00       	callq  40be30 <FreeMemory>
		LUARRAYCOLS*LUARRAYROWS*loclustruct->numarrays,
		&systemerror);
	if(systemerror)
	{       ReportError(errorcontext,systemerror);
		LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
		ErrorExit();
  40bc3a:	31 c0                	xor    %eax,%eax
  40bc3c:	e8 5f 05 00 00       	callq  40c1a0 <ErrorExit>
	}
	bbase=(fardouble *)AllocateMemory(sizeof(double) *
  40bc41:	48 69 3d e4 4a 20 00 	imul   $0x328,0x204ae4(%rip),%rdi        # 610730 <global_lustruct+0x10>
  40bc48:	28 03 00 00 
  40bc4c:	48 8d b4 24 a0 00 00 	lea    0xa0(%rsp),%rsi
  40bc53:	00 
  40bc54:	e8 d7 00 00 00       	callq  40bd30 <AllocateMemory>
		LUARRAYROWS*loclustruct->numarrays,&systemerror);
	if(systemerror)
  40bc59:	8b b4 24 a0 00 00 00 	mov    0xa0(%rsp),%esi
	if(systemerror)
	{       ReportError(errorcontext,systemerror);
		LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
		ErrorExit();
	}
	bbase=(fardouble *)AllocateMemory(sizeof(double) *
  40bc60:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
		LUARRAYROWS*loclustruct->numarrays,&systemerror);
	if(systemerror)
  40bc65:	85 f6                	test   %esi,%esi
  40bc67:	75 7a                	jne    40bce3 <DoLU+0xbd3>
  40bc69:	48 8b 05 c0 4a 20 00 	mov    0x204ac0(%rip),%rax        # 610730 <global_lustruct+0x10>
  40bc70:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40bc75:	e9 26 fa ff ff       	jmpq   40b6a0 <DoLU+0x590>
  40bc7a:	bf 6c df 40 00       	mov    $0x40df6c,%edi
  40bc7f:	e8 0c 52 ff ff       	callq  400e90 <puts@plt>
static void LUFreeMem(fardouble *a, fardouble *b,
			fardouble *abase,fardouble *bbase)
{
int systemerror;

FreeMemory((farvoid *)a,&systemerror);
  40bc84:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40bc89:	48 89 ef             	mov    %rbp,%rdi
  40bc8c:	4c 89 f6             	mov    %r14,%rsi
  40bc8f:	e8 9c 01 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)b,&systemerror);
  40bc94:	4c 89 f6             	mov    %r14,%rsi
  40bc97:	4c 89 e7             	mov    %r12,%rdi
  40bc9a:	e8 91 01 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)LUtempvv,&systemerror);
  40bc9f:	48 8b 3d 7a 60 20 00 	mov    0x20607a(%rip),%rdi        # 611d20 <LUtempvv>
  40bca6:	4c 89 f6             	mov    %r14,%rsi
  40bca9:	e8 82 01 00 00       	callq  40be30 <FreeMemory>

if(abase!=(fardouble *)NULL) FreeMemory((farvoid *)abase,&systemerror);
  40bcae:	48 85 db             	test   %rbx,%rbx
  40bcb1:	74 0b                	je     40bcbe <DoLU+0xbae>
  40bcb3:	4c 89 f6             	mov    %r14,%rsi
  40bcb6:	48 89 df             	mov    %rbx,%rdi
  40bcb9:	e8 72 01 00 00       	callq  40be30 <FreeMemory>
if(bbase!=(fardouble *)NULL) FreeMemory((farvoid *)bbase,&systemerror);
  40bcbe:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  40bcc3:	48 85 c0             	test   %rax,%rax
  40bcc6:	74 0d                	je     40bcd5 <DoLU+0xbc5>
  40bcc8:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40bccd:	48 89 c7             	mov    %rax,%rdi
  40bcd0:	e8 5b 01 00 00       	callq  40be30 <FreeMemory>
		LUARRAYROWS*loclustruct->numarrays,&systemerror);
	if(systemerror)
	{
		ReportError(errorcontext,systemerror);
		LUFreeMem(a,b,abase,(fardouble *)NULL);
		ErrorExit();
  40bcd5:	31 c0                	xor    %eax,%eax
  40bcd7:	e8 c4 04 00 00       	callq  40c1a0 <ErrorExit>
  40bcdc:	eb 8b                	jmp    40bc69 <DoLU+0xb59>
if(loclustruct->adjust==0)
	loclustruct->adjust=1;

LUFreeMem(a,b,abase,bbase);
return;
}
  40bcde:	e8 1d 52 ff ff       	callq  400f00 <__stack_chk_fail@plt>
	}
	bbase=(fardouble *)AllocateMemory(sizeof(double) *
		LUARRAYROWS*loclustruct->numarrays,&systemerror);
	if(systemerror)
	{
		ReportError(errorcontext,systemerror);
  40bce3:	bf 65 df 40 00       	mov    $0x40df65,%edi
  40bce8:	e8 83 04 00 00       	callq  40c170 <ReportError>
static void LUFreeMem(fardouble *a, fardouble *b,
			fardouble *abase,fardouble *bbase)
{
int systemerror;

FreeMemory((farvoid *)a,&systemerror);
  40bced:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40bcf2:	48 89 ef             	mov    %rbp,%rdi
  40bcf5:	4c 89 f6             	mov    %r14,%rsi
  40bcf8:	e8 33 01 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)b,&systemerror);
  40bcfd:	4c 89 f6             	mov    %r14,%rsi
  40bd00:	4c 89 e7             	mov    %r12,%rdi
  40bd03:	e8 28 01 00 00       	callq  40be30 <FreeMemory>
FreeMemory((farvoid *)LUtempvv,&systemerror);
  40bd08:	48 8b 3d 11 60 20 00 	mov    0x206011(%rip),%rdi        # 611d20 <LUtempvv>
  40bd0f:	4c 89 f6             	mov    %r14,%rsi
  40bd12:	e8 19 01 00 00       	callq  40be30 <FreeMemory>

if(abase!=(fardouble *)NULL) FreeMemory((farvoid *)abase,&systemerror);
  40bd17:	48 85 db             	test   %rbx,%rbx
  40bd1a:	74 b9                	je     40bcd5 <DoLU+0xbc5>
  40bd1c:	4c 89 f6             	mov    %r14,%rsi
  40bd1f:	48 89 df             	mov    %rbx,%rdi
  40bd22:	e8 09 01 00 00       	callq  40be30 <FreeMemory>
  40bd27:	eb ac                	jmp    40bcd5 <DoLU+0xbc5>
  40bd29:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040bd30 <AllocateMemory>:
*/
farvoid *returnval;             /* Return value */
ulong true_addr;		/* True address */
ulong adj_addr;			/* Adjusted address */

returnval=(farvoid *)malloc((size_t)(nbytes+2L*(long)global_align));
  40bd30:	48 63 05 ad 4f 20 00 	movslq 0x204fad(%rip),%rax        # 610ce4 <global_align>
** Currently, mem_array[][] is only used if you use malloc;
**  it is not used for the 16-bit DOS and MAC versions.
*/
farvoid *AllocateMemory(unsigned long nbytes,   /* # of bytes to alloc */
		int *errorcode)                 /* Returned error code */
{
  40bd37:	53                   	push   %rbx
  40bd38:	48 89 f3             	mov    %rsi,%rbx
*/
farvoid *returnval;             /* Return value */
ulong true_addr;		/* True address */
ulong adj_addr;			/* Adjusted address */

returnval=(farvoid *)malloc((size_t)(nbytes+2L*(long)global_align));
  40bd3b:	48 8d 3c 47          	lea    (%rdi,%rax,2),%rdi
  40bd3f:	e8 9c 52 ff ff       	callq  400fe0 <malloc@plt>
  40bd44:	48 85 c0             	test   %rax,%rax
  40bd47:	49 89 c1             	mov    %rax,%r9
  40bd4a:	0f 94 c0             	sete   %al
  40bd4d:	0f b6 c0             	movzbl %al,%eax
  40bd50:	89 03                	mov    %eax,(%rbx)

/*
** Check for alignment
*/
adj_addr=true_addr=(ulong)returnval;
if(global_align==0)
  40bd52:	44 8b 05 8b 4f 20 00 	mov    0x204f8b(%rip),%r8d        # 610ce4 <global_align>
  40bd59:	45 85 c0             	test   %r8d,%r8d
  40bd5c:	75 22                	jne    40bd80 <AllocateMemory+0x50>
** -1 if not enough room
*/
int AddMemArray(ulong true_addr,
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
  40bd5e:	8b 05 7c 4f 20 00    	mov    0x204f7c(%rip),%eax        # 610ce0 <mem_array_ents>
  40bd64:	83 f8 13             	cmp    $0x13,%eax
  40bd67:	0f 8e 9b 00 00 00    	jle    40be08 <AllocateMemory+0xd8>
*/
adj_addr=true_addr=(ulong)returnval;
if(global_align==0)
{	
	if(AddMemArray(true_addr, adj_addr))
		*errorcode=ERROR_MEMARRAY_FULL;
  40bd6d:	c7 03 02 00 00 00    	movl   $0x2,(%rbx)
*/
farvoid *returnval;             /* Return value */
ulong true_addr;		/* True address */
ulong adj_addr;			/* Adjusted address */

returnval=(farvoid *)malloc((size_t)(nbytes+2L*(long)global_align));
  40bd73:	4c 89 c8             	mov    %r9,%rax
if(AddMemArray(true_addr,adj_addr))
	*errorcode=ERROR_MEMARRAY_FULL;
return(returnval);
#endif

}
  40bd76:	5b                   	pop    %rbx
  40bd77:	c3                   	retq   
  40bd78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40bd7f:	00 
	if(AddMemArray(true_addr, adj_addr))
		*errorcode=ERROR_MEMARRAY_FULL;
	return(returnval);
}

if(global_align==1)
  40bd80:	41 83 f8 01          	cmp    $0x1,%r8d
{	
        if(true_addr%2==0) adj_addr++;
  40bd84:	49 8d 49 01          	lea    0x1(%r9),%rcx
	if(AddMemArray(true_addr, adj_addr))
		*errorcode=ERROR_MEMARRAY_FULL;
	return(returnval);
}

if(global_align==1)
  40bd88:	74 3f                	je     40bdc9 <AllocateMemory+0x99>
{	
        if(true_addr%2==0) adj_addr++;
}
else
{	
	while(adj_addr%global_align!=0) ++adj_addr;
  40bd8a:	31 d2                	xor    %edx,%edx
  40bd8c:	49 63 f8             	movslq %r8d,%rdi
  40bd8f:	4c 89 c8             	mov    %r9,%rax
  40bd92:	48 f7 f7             	div    %rdi
  40bd95:	4c 89 c9             	mov    %r9,%rcx
  40bd98:	48 85 d2             	test   %rdx,%rdx
  40bd9b:	74 14                	je     40bdb1 <AllocateMemory+0x81>
  40bd9d:	0f 1f 00             	nopl   (%rax)
  40bda0:	48 83 c1 01          	add    $0x1,%rcx
  40bda4:	31 d2                	xor    %edx,%edx
  40bda6:	48 89 c8             	mov    %rcx,%rax
  40bda9:	48 f7 f7             	div    %rdi
  40bdac:	48 85 d2             	test   %rdx,%rdx
  40bdaf:	75 ef                	jne    40bda0 <AllocateMemory+0x70>
	if(adj_addr%(global_align*2)==0) adj_addr+=global_align;
  40bdb1:	45 01 c0             	add    %r8d,%r8d
  40bdb4:	48 89 c8             	mov    %rcx,%rax
  40bdb7:	31 d2                	xor    %edx,%edx
  40bdb9:	4d 63 c0             	movslq %r8d,%r8
  40bdbc:	48 01 cf             	add    %rcx,%rdi
  40bdbf:	49 f7 f0             	div    %r8
  40bdc2:	48 85 d2             	test   %rdx,%rdx
  40bdc5:	48 0f 44 cf          	cmove  %rdi,%rcx
** -1 if not enough room
*/
int AddMemArray(ulong true_addr,
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
  40bdc9:	8b 05 11 4f 20 00    	mov    0x204f11(%rip),%eax        # 610ce0 <mem_array_ents>
  40bdcf:	83 f8 13             	cmp    $0x13,%eax
  40bdd2:	7e 0c                	jle    40bde0 <AllocateMemory+0xb0>
	while(adj_addr%global_align!=0) ++adj_addr;
	if(adj_addr%(global_align*2)==0) adj_addr+=global_align;
}
returnval=(void *)adj_addr;
if(AddMemArray(true_addr,adj_addr))
	*errorcode=ERROR_MEMARRAY_FULL;
  40bdd4:	c7 03 02 00 00 00    	movl   $0x2,(%rbx)
return(returnval);
  40bdda:	48 89 c8             	mov    %rcx,%rax
#endif

}
  40bddd:	5b                   	pop    %rbx
  40bdde:	c3                   	retq   
  40bddf:	90                   	nop
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
  40bde0:	48 63 d0             	movslq %eax,%rdx
mem_array[1][mem_array_ents]=adj_addr;
mem_array_ents++;
  40bde3:	83 c0 01             	add    $0x1,%eax
  40bde6:	89 05 f4 4e 20 00    	mov    %eax,0x204ef4(%rip)        # 610ce0 <mem_array_ents>
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
  40bdec:	4c 89 0c d5 80 0d 61 	mov    %r9,0x610d80(,%rdx,8)
  40bdf3:	00 
	if(adj_addr%(global_align*2)==0) adj_addr+=global_align;
}
returnval=(void *)adj_addr;
if(AddMemArray(true_addr,adj_addr))
	*errorcode=ERROR_MEMARRAY_FULL;
return(returnval);
  40bdf4:	48 89 c8             	mov    %rcx,%rax
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
mem_array[1][mem_array_ents]=adj_addr;
  40bdf7:	48 89 0c d5 20 0e 61 	mov    %rcx,0x610e20(,%rdx,8)
  40bdfe:	00 
if(AddMemArray(true_addr,adj_addr))
	*errorcode=ERROR_MEMARRAY_FULL;
return(returnval);
#endif

}
  40bdff:	5b                   	pop    %rbx
  40be00:	c3                   	retq   
  40be01:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
  40be08:	48 63 d0             	movslq %eax,%rdx
mem_array[1][mem_array_ents]=adj_addr;
mem_array_ents++;
  40be0b:	83 c0 01             	add    $0x1,%eax
  40be0e:	89 05 cc 4e 20 00    	mov    %eax,0x204ecc(%rip)        # 610ce0 <mem_array_ents>
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
  40be14:	4c 89 0c d5 80 0d 61 	mov    %r9,0x610d80(,%rdx,8)
  40be1b:	00 
*/
farvoid *returnval;             /* Return value */
ulong true_addr;		/* True address */
ulong adj_addr;			/* Adjusted address */

returnval=(farvoid *)malloc((size_t)(nbytes+2L*(long)global_align));
  40be1c:	4c 89 c8             	mov    %r9,%rax
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
mem_array[1][mem_array_ents]=adj_addr;
  40be1f:	4c 89 0c d5 20 0e 61 	mov    %r9,0x610e20(,%rdx,8)
  40be26:	00 
if(AddMemArray(true_addr,adj_addr))
	*errorcode=ERROR_MEMARRAY_FULL;
return(returnval);
#endif

}
  40be27:	5b                   	pop    %rbx
  40be28:	c3                   	retq   
  40be29:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000040be30 <FreeMemory>:
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40be30:	44 8b 05 a9 4e 20 00 	mov    0x204ea9(%rip),%r8d        # 610ce0 <mem_array_ents>
** block passed in is freed.  Should an error occur,
** that error is returned in errorcode.
*/
void FreeMemory(farvoid *mempointer,    /* Pointer to memory block */
		int *errorcode)
{
  40be37:	53                   	push   %rbx
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40be38:	45 85 c0             	test   %r8d,%r8d
  40be3b:	7e 2f                	jle    40be6c <FreeMemory+0x3c>
	if(mem_array[1][i]==adj_addr)
  40be3d:	31 d2                	xor    %edx,%edx
  40be3f:	48 3b 3d da 4f 20 00 	cmp    0x204fda(%rip),%rdi        # 610e20 <mem_array+0xa0>
  40be46:	b9 28 0e 61 00       	mov    $0x610e28,%ecx
  40be4b:	75 17                	jne    40be64 <FreeMemory+0x34>
  40be4d:	e9 89 00 00 00       	jmpq   40bedb <FreeMemory+0xab>
  40be52:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40be58:	48 83 c1 08          	add    $0x8,%rcx
  40be5c:	48 3b 79 f8          	cmp    -0x8(%rcx),%rdi
  40be60:	74 16                	je     40be78 <FreeMemory+0x48>
  40be62:	89 c2                	mov    %eax,%edx
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40be64:	8d 42 01             	lea    0x1(%rdx),%eax
  40be67:	44 39 c0             	cmp    %r8d,%eax
  40be6a:	75 ec                	jne    40be58 <FreeMemory+0x28>
ulong adj_addr, true_addr;

/* Locate item in memory array */
adj_addr=(ulong)mempointer;
if(RemoveMemArray(adj_addr, &true_addr))
{	*errorcode=ERROR_MEMARRAY_NFOUND;
  40be6c:	c7 06 03 00 00 00    	movl   $0x3,(%rsi)
mempointer=(void *)true_addr;
free(mempointer);
*errorcode=0;
return;
#endif
}
  40be72:	5b                   	pop    %rbx
  40be73:	c3                   	retq   
  40be74:	0f 1f 40 00          	nopl   0x0(%rax)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
  40be78:	83 c2 02             	add    $0x2,%edx
	{       /* Found it..bubble stuff down */
		*true_addr=mem_array[0][i];
  40be7b:	48 98                	cltq   
		j=i;
		while(j+1<mem_array_ents)
  40be7d:	44 39 c2             	cmp    %r8d,%edx

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
	{       /* Found it..bubble stuff down */
		*true_addr=mem_array[0][i];
  40be80:	48 8b 3c c5 80 0d 61 	mov    0x610d80(,%rax,8),%rdi
  40be87:	00 
		j=i;
		while(j+1<mem_array_ents)
  40be88:	7c 08                	jl     40be92 <FreeMemory+0x62>
  40be8a:	eb 34                	jmp    40bec0 <FreeMemory+0x90>
  40be8c:	0f 1f 40 00          	nopl   0x0(%rax)
  40be90:	89 ca                	mov    %ecx,%edx
		{       mem_array[0][j]=mem_array[0][j+1];
  40be92:	48 63 ca             	movslq %edx,%rcx
  40be95:	4c 8b 0c cd 80 0d 61 	mov    0x610d80(,%rcx,8),%r9
  40be9c:	00 
  40be9d:	4c 89 0c c5 80 0d 61 	mov    %r9,0x610d80(,%rax,8)
  40bea4:	00 
			mem_array[1][j]=mem_array[1][j+1];
  40bea5:	48 8b 0c cd 20 0e 61 	mov    0x610e20(,%rcx,8),%rcx
  40beac:	00 
  40bead:	48 89 0c c5 20 0e 61 	mov    %rcx,0x610e20(,%rax,8)
  40beb4:	00 
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
	{       /* Found it..bubble stuff down */
		*true_addr=mem_array[0][i];
		j=i;
		while(j+1<mem_array_ents)
  40beb5:	8d 4a 01             	lea    0x1(%rdx),%ecx
  40beb8:	48 63 c2             	movslq %edx,%rax
  40bebb:	44 39 c1             	cmp    %r8d,%ecx
  40bebe:	75 d0                	jne    40be90 <FreeMemory+0x60>
  40bec0:	48 89 f3             	mov    %rsi,%rbx
		{       mem_array[0][j]=mem_array[0][j+1];
			mem_array[1][j]=mem_array[1][j+1];
			j++;
		}
		mem_array_ents--;
  40bec3:	41 83 e8 01          	sub    $0x1,%r8d
  40bec7:	44 89 05 12 4e 20 00 	mov    %r8d,0x204e12(%rip)        # 610ce0 <mem_array_ents>
if(RemoveMemArray(adj_addr, &true_addr))
{	*errorcode=ERROR_MEMARRAY_NFOUND;
	return;
}
mempointer=(void *)true_addr;
free(mempointer);
  40bece:	e8 5d 4f ff ff       	callq  400e30 <free@plt>
*errorcode=0;
  40bed3:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
return;
#endif
}
  40bed9:	5b                   	pop    %rbx
  40beda:	c3                   	retq   
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
  40bedb:	ba 01 00 00 00       	mov    $0x1,%edx
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40bee0:	31 c0                	xor    %eax,%eax
  40bee2:	eb 97                	jmp    40be7b <FreeMemory+0x4b>
  40bee4:	66 90                	xchg   %ax,%ax
  40bee6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40beed:	00 00 00 

000000000040bef0 <MoveMemory>:
}

__fortify_function void *
__NTH (memmove (void *__dest, const void *__src, size_t __len))
{
  return __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
  40bef0:	e9 2b 51 ff ff       	jmpq   401020 <memmove@plt>
  40bef5:	90                   	nop
  40bef6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40befd:	00 00 00 

000000000040bf00 <InitMemArray>:
** setting mem_array_ents to zero, indicating that there
** isn't anything in the memory array.
*/
void InitMemArray(void)
{
mem_array_ents=0;
  40bf00:	c7 05 d6 4d 20 00 00 	movl   $0x0,0x204dd6(%rip)        # 610ce0 <mem_array_ents>
  40bf07:	00 00 00 
  40bf0a:	c3                   	retq   
  40bf0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040bf10 <AddMemArray>:
** -1 if not enough room
*/
int AddMemArray(ulong true_addr,
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
  40bf10:	8b 05 ca 4d 20 00    	mov    0x204dca(%rip),%eax        # 610ce0 <mem_array_ents>
  40bf16:	83 f8 13             	cmp    $0x13,%eax
  40bf19:	7f 25                	jg     40bf40 <AddMemArray+0x30>
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
  40bf1b:	48 63 d0             	movslq %eax,%rdx
mem_array[1][mem_array_ents]=adj_addr;
mem_array_ents++;
  40bf1e:	83 c0 01             	add    $0x1,%eax
  40bf21:	89 05 b9 4d 20 00    	mov    %eax,0x204db9(%rip)        # 610ce0 <mem_array_ents>
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
  40bf27:	48 89 3c d5 80 0d 61 	mov    %rdi,0x610d80(,%rdx,8)
  40bf2e:	00 
mem_array[1][mem_array_ents]=adj_addr;
mem_array_ents++;
return(0);
  40bf2f:	31 c0                	xor    %eax,%eax
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);

mem_array[0][mem_array_ents]=true_addr;
mem_array[1][mem_array_ents]=adj_addr;
  40bf31:	48 89 34 d5 20 0e 61 	mov    %rsi,0x610e20(,%rdx,8)
  40bf38:	00 
mem_array_ents++;
return(0);
  40bf39:	c3                   	retq   
  40bf3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
*/
int AddMemArray(ulong true_addr,
		ulong adj_addr)
{
if(mem_array_ents>=MEM_ARRAY_SIZE)
	return(-1);
  40bf40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

mem_array[0][mem_array_ents]=true_addr;
mem_array[1][mem_array_ents]=adj_addr;
mem_array_ents++;
return(0);
}
  40bf45:	c3                   	retq   
  40bf46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40bf4d:	00 00 00 

000000000040bf50 <RemoveMemArray>:
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40bf50:	44 8b 05 89 4d 20 00 	mov    0x204d89(%rip),%r8d        # 610ce0 <mem_array_ents>
		mem_array_ents--;
		return(0);      /* Return if found */
	}

/* If we made it here...something's wrong...show error */
return(-1);
  40bf57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40bf5c:	45 85 c0             	test   %r8d,%r8d
  40bf5f:	7e 30                	jle    40bf91 <RemoveMemArray+0x41>
	if(mem_array[1][i]==adj_addr)
  40bf61:	31 d2                	xor    %edx,%edx
  40bf63:	48 3b 3d b6 4e 20 00 	cmp    0x204eb6(%rip),%rdi        # 610e20 <mem_array+0xa0>
  40bf6a:	b9 28 0e 61 00       	mov    $0x610e28,%ecx
  40bf6f:	75 13                	jne    40bf84 <RemoveMemArray+0x34>
  40bf71:	eb 79                	jmp    40bfec <RemoveMemArray+0x9c>
  40bf73:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40bf78:	48 83 c1 08          	add    $0x8,%rcx
  40bf7c:	48 39 79 f8          	cmp    %rdi,-0x8(%rcx)
  40bf80:	74 16                	je     40bf98 <RemoveMemArray+0x48>
  40bf82:	89 c2                	mov    %eax,%edx
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40bf84:	8d 42 01             	lea    0x1(%rdx),%eax
  40bf87:	44 39 c0             	cmp    %r8d,%eax
  40bf8a:	75 ec                	jne    40bf78 <RemoveMemArray+0x28>
		mem_array_ents--;
		return(0);      /* Return if found */
	}

/* If we made it here...something's wrong...show error */
return(-1);
  40bf8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  40bf91:	f3 c3                	repz retq 
  40bf93:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
  40bf98:	83 c2 02             	add    $0x2,%edx
	{       /* Found it..bubble stuff down */
		*true_addr=mem_array[0][i];
  40bf9b:	48 98                	cltq   
		j=i;
		while(j+1<mem_array_ents)
  40bf9d:	44 39 c2             	cmp    %r8d,%edx

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
	{       /* Found it..bubble stuff down */
		*true_addr=mem_array[0][i];
  40bfa0:	48 8b 0c c5 80 0d 61 	mov    0x610d80(,%rax,8),%rcx
  40bfa7:	00 
  40bfa8:	48 89 0e             	mov    %rcx,(%rsi)
		j=i;
		while(j+1<mem_array_ents)
  40bfab:	7d 31                	jge    40bfde <RemoveMemArray+0x8e>
  40bfad:	0f 1f 00             	nopl   (%rax)
		{       mem_array[0][j]=mem_array[0][j+1];
  40bfb0:	48 63 ca             	movslq %edx,%rcx
  40bfb3:	48 8b 34 cd 80 0d 61 	mov    0x610d80(,%rcx,8),%rsi
  40bfba:	00 
  40bfbb:	48 89 34 c5 80 0d 61 	mov    %rsi,0x610d80(,%rax,8)
  40bfc2:	00 
			mem_array[1][j]=mem_array[1][j+1];
  40bfc3:	48 8b 0c cd 20 0e 61 	mov    0x610e20(,%rcx,8),%rcx
  40bfca:	00 
  40bfcb:	48 89 0c c5 20 0e 61 	mov    %rcx,0x610e20(,%rax,8)
  40bfd2:	00 
  40bfd3:	48 63 c2             	movslq %edx,%rax
  40bfd6:	83 c2 01             	add    $0x1,%edx
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
	{       /* Found it..bubble stuff down */
		*true_addr=mem_array[0][i];
		j=i;
		while(j+1<mem_array_ents)
  40bfd9:	44 39 c2             	cmp    %r8d,%edx
  40bfdc:	75 d2                	jne    40bfb0 <RemoveMemArray+0x60>
		{       mem_array[0][j]=mem_array[0][j+1];
			mem_array[1][j]=mem_array[1][j+1];
			j++;
		}
		mem_array_ents--;
  40bfde:	41 83 e8 01          	sub    $0x1,%r8d
		return(0);      /* Return if found */
  40bfe2:	31 c0                	xor    %eax,%eax
		while(j+1<mem_array_ents)
		{       mem_array[0][j]=mem_array[0][j+1];
			mem_array[1][j]=mem_array[1][j+1];
			j++;
		}
		mem_array_ents--;
  40bfe4:	44 89 05 f5 4c 20 00 	mov    %r8d,0x204cf5(%rip)        # 610ce0 <mem_array_ents>
		return(0);      /* Return if found */
  40bfeb:	c3                   	retq   
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
	if(mem_array[1][i]==adj_addr)
  40bfec:	ba 01 00 00 00       	mov    $0x1,%edx
int RemoveMemArray(ulong adj_addr,ulong *true_addr)
{
int i,j;

/* Locate the item in the array. */
for(i=0;i<mem_array_ents;i++)
  40bff1:	31 c0                	xor    %eax,%eax
  40bff3:	eb a6                	jmp    40bf9b <RemoveMemArray+0x4b>
  40bff5:	90                   	nop
  40bff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40bffd:	00 00 00 

000000000040c000 <CreateFile>:
** Note that the routine does not OPEN the file.
** If the file exists, it is truncated to length 0.
*/
void CreateFile(char *filename,
		int *errorcode)
{
  40c000:	53                   	push   %rbx
  40c001:	48 89 f3             	mov    %rsi,%rbx
#endif

#ifdef LINUX
FILE *fhandle;            /* File handle used internally */

fhandle=fopen(filename,"w");
  40c004:	be 9e e0 40 00       	mov    $0x40e09e,%esi
  40c009:	e8 32 50 ff ff       	callq  401040 <fopen@plt>

if(fhandle==NULL)
	*errorcode=ERROR_FILECREATE;
  40c00e:	48 83 f8 01          	cmp    $0x1,%rax

/*
** Since all we're doing here is creating the file,
** go ahead and close it.
*/
fclose(fhandle);
  40c012:	48 89 c7             	mov    %rax,%rdi
FILE *fhandle;            /* File handle used internally */

fhandle=fopen(filename,"w");

if(fhandle==NULL)
	*errorcode=ERROR_FILECREATE;
  40c015:	19 d2                	sbb    %edx,%edx
  40c017:	83 e2 0a             	and    $0xa,%edx
  40c01a:	89 13                	mov    %edx,(%rbx)
*/
fclose(fhandle);

return;
#endif
}
  40c01c:	5b                   	pop    %rbx

/*
** Since all we're doing here is creating the file,
** go ahead and close it.
*/
fclose(fhandle);
  40c01d:	e9 be 4e ff ff       	jmpq   400ee0 <fclose@plt>
  40c022:	0f 1f 40 00          	nopl   0x0(%rax)
  40c026:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c02d:	00 00 00 

000000000040c030 <bmOpenFile>:

#ifdef LINUX

FILE *bmOpenFile(char *fname,       /* File name */
	    int *errorcode)         /* Error code returned */
{
  40c030:	53                   	push   %rbx
  40c031:	48 89 f3             	mov    %rsi,%rbx

FILE *fhandle;            /* Returned file handle */

fhandle=fopen(fname,"w+");
  40c034:	be 30 e3 40 00       	mov    $0x40e330,%esi
  40c039:	e8 02 50 ff ff       	callq  401040 <fopen@plt>

if(fhandle==NULL)
	*errorcode=ERROR_FILEOPEN;
  40c03e:	48 83 f8 01          	cmp    $0x1,%rax
  40c042:	19 d2                	sbb    %edx,%edx
  40c044:	83 e2 0d             	and    $0xd,%edx
  40c047:	89 13                	mov    %edx,(%rbx)
else
	*errorcode=0;

return(fhandle);
}
  40c049:	5b                   	pop    %rbx
  40c04a:	c3                   	retq   
  40c04b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040c050 <CloseFile>:
}
#endif
#ifdef LINUX
void CloseFile(FILE *fhandle,             /* File handle */
		int *errorcode)         /* Returned error code */
{
  40c050:	53                   	push   %rbx
  40c051:	48 89 f3             	mov    %rsi,%rbx
fclose(fhandle);
  40c054:	e8 87 4e ff ff       	callq  400ee0 <fclose@plt>
*errorcode=0;
  40c059:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
return;
}
  40c05f:	5b                   	pop    %rbx
  40c060:	c3                   	retq   
  40c061:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  40c066:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c06d:	00 00 00 

000000000040c070 <readfile>:
void readfile(FILE *fhandle,            /* File handle */
	unsigned long offset,           /* Offset into file */
	unsigned long nbytes,           /* # of bytes to read */
	void *buffer,                   /* Buffer to read into */
	int *errorcode)                 /* Returned error code */
{
  40c070:	41 55                	push   %r13
  40c072:	41 54                	push   %r12
  40c074:	49 89 cd             	mov    %rcx,%r13
  40c077:	55                   	push   %rbp
  40c078:	53                   	push   %rbx
  40c079:	48 89 d3             	mov    %rdx,%rbx
*errorcode=0;

/*
** Seek to the proper offset.
*/
newoffset=fseek(fhandle,(long)offset,SEEK_SET);
  40c07c:	31 d2                	xor    %edx,%edx
void readfile(FILE *fhandle,            /* File handle */
	unsigned long offset,           /* Offset into file */
	unsigned long nbytes,           /* # of bytes to read */
	void *buffer,                   /* Buffer to read into */
	int *errorcode)                 /* Returned error code */
{
  40c07e:	49 89 fc             	mov    %rdi,%r12
  40c081:	4c 89 c5             	mov    %r8,%rbp
  40c084:	48 83 ec 08          	sub    $0x8,%rsp
size_t readcode;                        /* Actual return code from read */

/*
** Presume success.
*/
*errorcode=0;
  40c088:	41 c7 00 00 00 00 00 	movl   $0x0,(%r8)

/*
** Seek to the proper offset.
*/
newoffset=fseek(fhandle,(long)offset,SEEK_SET);
  40c08f:	e8 5c 4f ff ff       	callq  400ff0 <fseek@plt>
if(newoffset==-1L)
  40c094:	83 f8 ff             	cmp    $0xffffffff,%eax
  40c097:	74 37                	je     40c0d0 <readfile+0x60>
}

/*
** Do the read.
*/
nelems=(size_t)(nbytes & 0xFFFF);
  40c099:	0f b7 db             	movzwl %bx,%ebx
	return __fread_chk (__ptr, __bos0 (__ptr), __size, __n, __stream);

      if (__size * __n > __bos0 (__ptr))
	return __fread_chk_warn (__ptr, __bos0 (__ptr), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
  40c09c:	4c 89 e1             	mov    %r12,%rcx
  40c09f:	be 01 00 00 00       	mov    $0x1,%esi
  40c0a4:	48 89 da             	mov    %rbx,%rdx
  40c0a7:	4c 89 ef             	mov    %r13,%rdi
  40c0aa:	e8 f1 4d ff ff       	callq  400ea0 <fread@plt>
readcode=fread(buffer,(size_t)1,nelems,fhandle);
if(readcode!=nelems)
  40c0af:	48 39 c3             	cmp    %rax,%rbx
  40c0b2:	74 07                	je     40c0bb <readfile+0x4b>
	*errorcode=ERROR_FILEREAD;
  40c0b4:	c7 45 00 0b 00 00 00 	movl   $0xb,0x0(%rbp)

return;
}
  40c0bb:	48 83 c4 08          	add    $0x8,%rsp
  40c0bf:	5b                   	pop    %rbx
  40c0c0:	5d                   	pop    %rbp
  40c0c1:	41 5c                	pop    %r12
  40c0c3:	41 5d                	pop    %r13
  40c0c5:	c3                   	retq   
  40c0c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c0cd:	00 00 00 
/*
** Seek to the proper offset.
*/
newoffset=fseek(fhandle,(long)offset,SEEK_SET);
if(newoffset==-1L)
{       *errorcode=ERROR_FILESEEK;
  40c0d0:	c7 45 00 0e 00 00 00 	movl   $0xe,0x0(%rbp)
readcode=fread(buffer,(size_t)1,nelems,fhandle);
if(readcode!=nelems)
	*errorcode=ERROR_FILEREAD;

return;
}
  40c0d7:	48 83 c4 08          	add    $0x8,%rsp
  40c0db:	5b                   	pop    %rbx
  40c0dc:	5d                   	pop    %rbp
  40c0dd:	41 5c                	pop    %r12
  40c0df:	41 5d                	pop    %r13
  40c0e1:	c3                   	retq   
  40c0e2:	0f 1f 40 00          	nopl   0x0(%rax)
  40c0e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c0ed:	00 00 00 

000000000040c0f0 <writefile>:
void writefile(FILE *fhandle,           /* File handle */
	unsigned long offset,           /* Offset into file */
	unsigned long nbytes,           /* # of bytes to read */
	void *buffer,                   /* Buffer to read into */
	int *errorcode)                 /* Returned error code */
{
  40c0f0:	41 55                	push   %r13
  40c0f2:	41 54                	push   %r12
  40c0f4:	49 89 cd             	mov    %rcx,%r13
  40c0f7:	55                   	push   %rbp
  40c0f8:	53                   	push   %rbx
  40c0f9:	48 89 d3             	mov    %rdx,%rbx
*errorcode=0;

/*
** Seek to the proper offset.
*/
newoffset=fseek(fhandle,(long)offset,SEEK_SET);
  40c0fc:	31 d2                	xor    %edx,%edx
void writefile(FILE *fhandle,           /* File handle */
	unsigned long offset,           /* Offset into file */
	unsigned long nbytes,           /* # of bytes to read */
	void *buffer,                   /* Buffer to read into */
	int *errorcode)                 /* Returned error code */
{
  40c0fe:	48 89 fd             	mov    %rdi,%rbp
  40c101:	4d 89 c4             	mov    %r8,%r12
  40c104:	48 83 ec 08          	sub    $0x8,%rsp
size_t writecode;                       /* Actual return code from write */

/*
** Presume success.
*/
*errorcode=0;
  40c108:	41 c7 00 00 00 00 00 	movl   $0x0,(%r8)

/*
** Seek to the proper offset.
*/
newoffset=fseek(fhandle,(long)offset,SEEK_SET);
  40c10f:	e8 dc 4e ff ff       	callq  400ff0 <fseek@plt>
if(newoffset==-1L)
  40c114:	83 f8 ff             	cmp    $0xffffffff,%eax
  40c117:	74 3f                	je     40c158 <writefile+0x68>
}

/*
** Do the write.
*/
nelems=(size_t)(nbytes & 0xFFFF);
  40c119:	0f b7 db             	movzwl %bx,%ebx
writecode=fwrite(buffer,(size_t)1,nelems,fhandle);
  40c11c:	48 89 e9             	mov    %rbp,%rcx
  40c11f:	be 01 00 00 00       	mov    $0x1,%esi
  40c124:	48 89 da             	mov    %rbx,%rdx
  40c127:	4c 89 ef             	mov    %r13,%rdi
  40c12a:	e8 41 4f ff ff       	callq  401070 <fwrite@plt>
if(writecode==nelems)
  40c12f:	48 39 c3             	cmp    %rax,%rbx
  40c132:	74 0c                	je     40c140 <writefile+0x50>
	*errorcode=ERROR_FILEWRITE;

return;
}
  40c134:	48 83 c4 08          	add    $0x8,%rsp
  40c138:	5b                   	pop    %rbx
  40c139:	5d                   	pop    %rbp
  40c13a:	41 5c                	pop    %r12
  40c13c:	41 5d                	pop    %r13
  40c13e:	c3                   	retq   
  40c13f:	90                   	nop
** Do the write.
*/
nelems=(size_t)(nbytes & 0xFFFF);
writecode=fwrite(buffer,(size_t)1,nelems,fhandle);
if(writecode==nelems)
	*errorcode=ERROR_FILEWRITE;
  40c140:	41 c7 04 24 0c 00 00 	movl   $0xc,(%r12)
  40c147:	00 

return;
}
  40c148:	48 83 c4 08          	add    $0x8,%rsp
  40c14c:	5b                   	pop    %rbx
  40c14d:	5d                   	pop    %rbp
  40c14e:	41 5c                	pop    %r12
  40c150:	41 5d                	pop    %r13
  40c152:	c3                   	retq   
  40c153:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
/*
** Seek to the proper offset.
*/
newoffset=fseek(fhandle,(long)offset,SEEK_SET);
if(newoffset==-1L)
{       *errorcode=ERROR_FILESEEK;
  40c158:	41 c7 04 24 0e 00 00 	movl   $0xe,(%r12)
  40c15f:	00 
writecode=fwrite(buffer,(size_t)1,nelems,fhandle);
if(writecode==nelems)
	*errorcode=ERROR_FILEWRITE;

return;
}
  40c160:	48 83 c4 08          	add    $0x8,%rsp
  40c164:	5b                   	pop    %rbx
  40c165:	5d                   	pop    %rbp
  40c166:	41 5c                	pop    %r12
  40c168:	41 5d                	pop    %r13
  40c16a:	c3                   	retq   
  40c16b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040c170 <ReportError>:
** ReportError
** Report error message condition.
*/
void ReportError(char *errorcontext,    /* Error context string */
		int errorcode)          /* Error code number */
{
  40c170:	53                   	push   %rbx
  40c171:	48 89 fa             	mov    %rdi,%rdx
  40c174:	89 f3                	mov    %esi,%ebx
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c176:	bf 01 00 00 00       	mov    $0x1,%edi
  40c17b:	be 33 e3 40 00       	mov    $0x40e333,%esi
  40c180:	31 c0                	xor    %eax,%eax
  40c182:	e8 89 4e ff ff       	callq  401010 <__printf_chk@plt>
  40c187:	89 da                	mov    %ebx,%edx
  40c189:	be 50 e3 40 00       	mov    $0x40e350,%esi
  40c18e:	bf 01 00 00 00       	mov    $0x1,%edi
** Display code
*/
printf("Code: %d",errorcode);

return;
}
  40c193:	5b                   	pop    %rbx
  40c194:	31 c0                	xor    %eax,%eax
  40c196:	e9 75 4e ff ff       	jmpq   401010 <__printf_chk@plt>
  40c19b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000040c1a0 <ErrorExit>:
/****************************
** ErrorExit
** Peforms an exit from an error condition.
*/
void ErrorExit()
{
  40c1a0:	48 83 ec 08          	sub    $0x8,%rsp
#endif

/*
** FOR NOW...SIMPLE EXIT
*/
exit(1);
  40c1a4:	bf 01 00 00 00       	mov    $0x1,%edi
  40c1a9:	e8 b2 4e ff ff       	callq  401060 <exit@plt>
  40c1ae:	66 90                	xchg   %ax,%ax

000000000040c1b0 <StartStopwatch>:
** Win 3.x timer returns a DWORD, which we coax into a long.
*/
_Call16(lpfn,"p",&win31tinfo);
return((unsigned long)win31tinfo.dwmsSinceStart);
#else
return((unsigned long)clock());
  40c1b0:	e9 1b 4d ff ff       	jmpq   400ed0 <clock@plt>
  40c1b5:	90                   	nop
  40c1b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c1bd:	00 00 00 

000000000040c1c0 <StopStopwatch>:
** StopStopwatch
** Stops the software stopwatch.  Expects as an input argument
** the stopwatch start time.
*/
unsigned long StopStopwatch(unsigned long startticks)
{
  40c1c0:	53                   	push   %rbx
  40c1c1:	48 89 fb             	mov    %rdi,%rbx
#else
#ifdef WIN31TIMER
_Call16(lpfn,"p",&win31tinfo);
return((unsigned long)win31tinfo.dwmsSinceStart-startticks);
#else
return((unsigned long)clock()-startticks);
  40c1c4:	e8 07 4d ff ff       	callq  400ed0 <clock@plt>
  40c1c9:	48 29 d8             	sub    %rbx,%rax
#endif
#endif
}
  40c1cc:	5b                   	pop    %rbx
  40c1cd:	c3                   	retq   
  40c1ce:	66 90                	xchg   %ax,%ax

000000000040c1d0 <TicksToSecs>:
return((unsigned long)(tickamount/1000000));
#endif

#ifdef CLOCKWCPS
/* Everybody else */
return((unsigned long)(tickamount/CLOCKS_PER_SEC));
  40c1d0:	48 89 f8             	mov    %rdi,%rax
  40c1d3:	48 ba db 34 b6 d7 82 	movabs $0x431bde82d7b634db,%rdx
  40c1da:	de 1b 43 
  40c1dd:	48 f7 e2             	mul    %rdx
  40c1e0:	48 89 d0             	mov    %rdx,%rax
  40c1e3:	48 c1 e8 12          	shr    $0x12,%rax
#ifdef WIN31TIMER
/* Each tick is 840 nanoseconds */
return((unsigned long)(tickamount/1000L));
#endif

}
  40c1e7:	c3                   	retq   
  40c1e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40c1ef:	00 

000000000040c1f0 <TicksToFracSecs>:
return((double)tickamount/(double)1000000);
#endif

#ifdef CLOCKWCPS
/* Everybody else */
return((double)tickamount/(double)CLOCKS_PER_SEC);
  40c1f0:	48 85 ff             	test   %rdi,%rdi
  40c1f3:	78 1b                	js     40c210 <TicksToFracSecs+0x20>
  40c1f5:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40c1f9:	f2 48 0f 2a c7       	cvtsi2sd %rdi,%xmm0
  40c1fe:	f2 0f 5e 05 5a 21 00 	divsd  0x215a(%rip),%xmm0        # 40e360 <jtable.3055+0x15d0>
  40c205:	00 

#ifdef WIN31TIMER
/* Using 840 nanosecond ticks */
return((double)tickamount/(double)1000);
#endif
}
  40c206:	c3                   	retq   
  40c207:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c20e:	00 00 
return((double)tickamount/(double)1000000);
#endif

#ifdef CLOCKWCPS
/* Everybody else */
return((double)tickamount/(double)CLOCKS_PER_SEC);
  40c210:	48 89 f8             	mov    %rdi,%rax
  40c213:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40c217:	48 d1 e8             	shr    %rax
  40c21a:	83 e7 01             	and    $0x1,%edi
  40c21d:	48 09 f8             	or     %rdi,%rax
  40c220:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40c225:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  40c229:	f2 0f 5e 05 2f 21 00 	divsd  0x212f(%rip),%xmm0        # 40e360 <jtable.3055+0x15d0>
  40c230:	00 

#ifdef WIN31TIMER
/* Using 840 nanosecond ticks */
return((double)tickamount/(double)1000);
#endif
}
  40c231:	c3                   	retq   
  40c232:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40c239:	00 00 00 
  40c23c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000040c240 <hardware>:
**************
** Runs the system command "uname -s -r"
** Reads /proc/cpuinfo if on a linux system
** Writes output
*/
void hardware(const int write_to_file, FILE *global_ofile) {
  40c240:	41 57                	push   %r15
  40c242:	41 56                	push   %r14
  40c244:	41 55                	push   %r13
  40c246:	41 54                	push   %r12
  40c248:	55                   	push   %rbp
  40c249:	53                   	push   %rbx
  40c24a:	48 81 ec 48 1c 00 00 	sub    $0x1c48,%rsp
  40c251:	89 7c 24 0c          	mov    %edi,0xc(%rsp)
** The pointer result must point to a pre-allocated array of at least BUF_SIZ
*/
static void runCommand (const char *command, char *result) {
  FILE * pipe;

  pipe = popen(command, "r");
  40c255:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
**************
** Runs the system command "uname -s -r"
** Reads /proc/cpuinfo if on a linux system
** Writes output
*/
void hardware(const int write_to_file, FILE *global_ofile) {
  40c25a:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  40c25f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40c266:	00 00 
  40c268:	48 89 84 24 38 1c 00 	mov    %rax,0x1c38(%rsp)
  40c26f:	00 
  40c270:	31 c0                	xor    %eax,%eax
** The pointer result must point to a pre-allocated array of at least BUF_SIZ
*/
static void runCommand (const char *command, char *result) {
  FILE * pipe;

  pipe = popen(command, "r");
  40c272:	be 05 e0 40 00       	mov    $0x40e005,%esi
void hardware(const int write_to_file, FILE *global_ofile) {
  char buffer[BUF_SIZ];
  char os[BUF_SIZ];
  char model[BUF_SIZ];
  char cache[BUF_SIZ];
  char os_command[] = "uname -s -r";
  40c277:	48 b8 75 6e 61 6d 65 	movabs $0x732d20656d616e75,%rax
  40c27e:	20 2d 73 
  40c281:	c7 44 24 28 20 2d 72 	movl   $0x722d20,0x28(%rsp)
  40c288:	00 
  40c289:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
** The pointer result must point to a pre-allocated array of at least BUF_SIZ
*/
static void runCommand (const char *command, char *result) {
  FILE * pipe;

  pipe = popen(command, "r");
  40c28e:	e8 9d 4d ff ff       	callq  401030 <popen@plt>
  if(pipe == NULL) {
  40c293:	48 85 c0             	test   %rax,%rax
  40c296:	0f 84 a8 07 00 00    	je     40ca44 <hardware+0x804>
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
  40c29c:	4c 8d 6c 24 30       	lea    0x30(%rsp),%r13
  40c2a1:	48 89 c2             	mov    %rax,%rdx
  40c2a4:	be 00 04 00 00       	mov    $0x400,%esi
  40c2a9:	48 89 c3             	mov    %rax,%rbx
  40c2ac:	4c 89 ef             	mov    %r13,%rdi
  40c2af:	e8 ec 4c ff ff       	callq  400fa0 <fgets@plt>
    /* command failed */
    result[0] = '\0';
  } else {
    if(NULL == fgets(result, BUF_SIZ, pipe)){
  40c2b4:	48 85 c0             	test   %rax,%rax
  40c2b7:	0f 84 96 07 00 00    	je     40ca53 <hardware+0x813>
      /* command failed */
      result[0] = '\0';
    }
    pclose(pipe);
  40c2bd:	48 89 df             	mov    %rbx,%rdi
  40c2c0:	e8 6b 4c ff ff       	callq  400f30 <pclose@plt>
** removeNewLine **
*******************
** Removes a trailing newline character if present
*/
static void removeNewLine(char * s) {
  if(strlen(s)>0 && s[strlen(s)-1] == '\n') {
  40c2c5:	80 7c 24 30 00       	cmpb   $0x0,0x30(%rsp)
  40c2ca:	0f 85 20 05 00 00    	jne    40c7f0 <hardware+0x5b0>
#ifdef NO_UNAME
  os[0] = '\0';
#else
  runCommand(os_command, os);
#endif
  if(NULL != strstr(os, "Linux")) {
  40c2d0:	be 68 e3 40 00       	mov    $0x40e368,%esi
  40c2d5:	4c 89 ef             	mov    %r13,%rdi
  40c2d8:	e8 c3 4d ff ff       	callq  4010a0 <strstr@plt>
  40c2dd:	48 85 c0             	test   %rax,%rax
  40c2e0:	0f 84 62 06 00 00    	je     40c948 <hardware+0x708>
  char cpu_MHz[BUF_SIZ];
  int i;
  float f;

  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  40c2e6:	be 05 e0 40 00       	mov    $0x40e005,%esi
  40c2eb:	bf 6e e3 40 00       	mov    $0x40e36e,%edi
  char model_name[BUF_SIZ];
  char cpu_MHz[BUF_SIZ];
  int i;
  float f;

  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  40c2f0:	c6 84 24 30 08 00 00 	movb   $0x0,0x830(%rsp)
  40c2f7:	00 
  40c2f8:	c6 84 24 30 04 00 00 	movb   $0x0,0x430(%rsp)
  40c2ff:	00 
  40c300:	c6 84 24 30 18 00 00 	movb   $0x0,0x1830(%rsp)
  40c307:	00 
  40c308:	c6 84 24 30 14 00 00 	movb   $0x0,0x1430(%rsp)
  40c30f:	00 
  40c310:	c6 84 24 30 10 00 00 	movb   $0x0,0x1030(%rsp)
  40c317:	00 
  info = fopen("/proc/cpuinfo", "r");
  40c318:	e8 23 4d ff ff       	callq  401040 <fopen@plt>
  if(info != NULL) {
  40c31d:	48 85 c0             	test   %rax,%rax
  char cpu_MHz[BUF_SIZ];
  int i;
  float f;

  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  40c320:	48 89 c5             	mov    %rax,%rbp
  if(info != NULL) {
  40c323:	0f 84 2f 06 00 00    	je     40c958 <hardware+0x718>
  40c329:	4c 8d bc 24 30 0c 00 	lea    0xc30(%rsp),%r15
  40c330:	00 
  40c331:	48 8d 84 24 30 08 00 	lea    0x830(%rsp),%rax
  40c338:	00 
  40c339:	48 8d 9c 24 30 18 00 	lea    0x1830(%rsp),%rbx
  40c340:	00 
  40c341:	45 31 e4             	xor    %r12d,%r12d
  40c344:	48 89 04 24          	mov    %rax,(%rsp)
          strcpy(model_name, cp);
        }
        removeNewLine(model_name);
      } else if(! strncmp(buffer, "cpu MHz", 7)) {
        cp+=strlen("cpu MHz");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c348:	49 8d 47 07          	lea    0x7(%r15),%rax
          strcpy(cpu_MHz, cp);
        }
        removeNewLine(cpu_MHz);
      } else if(! strncmp(buffer, "cache size", 10)) {
        cp+=strlen("cache size");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c34c:	4d 8d 77 0a          	lea    0xa(%r15),%r14
          strcpy(model_name, cp);
        }
        removeNewLine(model_name);
      } else if(! strncmp(buffer, "cpu MHz", 7)) {
        cp+=strlen("cpu MHz");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c350:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  40c355:	0f 1f 00             	nopl   (%rax)
  40c358:	48 89 ea             	mov    %rbp,%rdx
  40c35b:	be 00 04 00 00       	mov    $0x400,%esi
  40c360:	4c 89 ff             	mov    %r15,%rdi
  40c363:	e8 38 4c ff ff       	callq  400fa0 <fgets@plt>

  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  if(info != NULL) {
    /* command did not fail */
    while(NULL != fgets(buffer, BUF_SIZ, info)){
  40c368:	48 85 c0             	test   %rax,%rax
  40c36b:	0f 84 5f 02 00 00    	je     40c5d0 <hardware+0x390>
      buffer_end = buffer + strlen(buffer);
  40c371:	4c 89 fa             	mov    %r15,%rdx
  40c374:	8b 0a                	mov    (%rdx),%ecx
  40c376:	48 83 c2 04          	add    $0x4,%rdx
  40c37a:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40c380:	f7 d1                	not    %ecx
  40c382:	21 c8                	and    %ecx,%eax
  40c384:	25 80 80 80 80       	and    $0x80808080,%eax
  40c389:	74 e9                	je     40c374 <hardware+0x134>
  40c38b:	89 c1                	mov    %eax,%ecx
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
  40c38d:	4c 89 fe             	mov    %r15,%rsi
  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  if(info != NULL) {
    /* command did not fail */
    while(NULL != fgets(buffer, BUF_SIZ, info)){
      buffer_end = buffer + strlen(buffer);
  40c390:	c1 e9 10             	shr    $0x10,%ecx
  40c393:	a9 80 80 00 00       	test   $0x8080,%eax
  40c398:	0f 44 c1             	cmove  %ecx,%eax
  40c39b:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40c39f:	89 c7                	mov    %eax,%edi
  40c3a1:	48 0f 44 d1          	cmove  %rcx,%rdx
  40c3a5:	40 00 c7             	add    %al,%dil
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
  40c3a8:	b9 09 00 00 00       	mov    $0x9,%ecx
  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  if(info != NULL) {
    /* command did not fail */
    while(NULL != fgets(buffer, BUF_SIZ, info)){
      buffer_end = buffer + strlen(buffer);
  40c3ad:	48 83 da 03          	sbb    $0x3,%rdx
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
  40c3b1:	bf 7c e3 40 00       	mov    $0x40e37c,%edi
  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  if(info != NULL) {
    /* command did not fail */
    while(NULL != fgets(buffer, BUF_SIZ, info)){
      buffer_end = buffer + strlen(buffer);
  40c3b6:	4c 29 fa             	sub    %r15,%rdx
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
  40c3b9:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
  40c3bb:	75 0b                	jne    40c3c8 <hardware+0x188>
        cpus++;
  40c3bd:	41 83 c4 01          	add    $0x1,%r12d
  40c3c1:	eb 95                	jmp    40c358 <hardware+0x118>
  40c3c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      } else if(! strncmp(buffer, "vendor_id", 9)) {
  40c3c8:	bf 86 e3 40 00       	mov    $0x40e386,%edi
  40c3cd:	b9 09 00 00 00       	mov    $0x9,%ecx
  40c3d2:	4c 89 fe             	mov    %r15,%rsi
  vendor_id[0] = model_name[0] = cpu_MHz[0] = model[0] = cache[0] = '\0';
  info = fopen("/proc/cpuinfo", "r");
  if(info != NULL) {
    /* command did not fail */
    while(NULL != fgets(buffer, BUF_SIZ, info)){
      buffer_end = buffer + strlen(buffer);
  40c3d5:	4c 01 fa             	add    %r15,%rdx
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
        cpus++;
      } else if(! strncmp(buffer, "vendor_id", 9)) {
  40c3d8:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
  40c3da:	0f 85 90 00 00 00    	jne    40c470 <hardware+0x230>
        cp+=strlen("vendor_id");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c3e0:	49 8d 77 09          	lea    0x9(%r15),%rsi
  40c3e4:	48 39 f2             	cmp    %rsi,%rdx
  40c3e7:	76 29                	jbe    40c412 <hardware+0x1d2>
  40c3e9:	0f b6 84 24 39 0c 00 	movzbl 0xc39(%rsp),%eax
  40c3f0:	00 
  40c3f1:	3c 3a                	cmp    $0x3a,%al
  40c3f3:	0f 86 17 01 00 00    	jbe    40c510 <hardware+0x2d0>
  40c3f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
#endif

__fortify_function char *
__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
  40c400:	48 8d bc 24 30 10 00 	lea    0x1030(%rsp),%rdi
  40c407:	00 
  40c408:	ba 00 04 00 00       	mov    $0x400,%edx
  40c40d:	e8 ee 4b ff ff       	callq  401000 <__strcpy_chk@plt>
** removeNewLine **
*******************
** Removes a trailing newline character if present
*/
static void removeNewLine(char * s) {
  if(strlen(s)>0 && s[strlen(s)-1] == '\n') {
  40c412:	80 bc 24 30 10 00 00 	cmpb   $0x0,0x1030(%rsp)
  40c419:	00 
  40c41a:	0f 84 38 ff ff ff    	je     40c358 <hardware+0x118>
  40c420:	48 8d 94 24 30 10 00 	lea    0x1030(%rsp),%rdx
  40c427:	00 
  40c428:	8b 0a                	mov    (%rdx),%ecx
  40c42a:	48 83 c2 04          	add    $0x4,%rdx
  40c42e:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40c434:	f7 d1                	not    %ecx
  40c436:	21 c8                	and    %ecx,%eax
  40c438:	25 80 80 80 80       	and    $0x80808080,%eax
  40c43d:	74 e9                	je     40c428 <hardware+0x1e8>
  40c43f:	89 c1                	mov    %eax,%ecx
  40c441:	c1 e9 10             	shr    $0x10,%ecx
  40c444:	a9 80 80 00 00       	test   $0x8080,%eax
  40c449:	0f 44 c1             	cmove  %ecx,%eax
  40c44c:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40c450:	89 c7                	mov    %eax,%edi
  40c452:	48 0f 44 d1          	cmove  %rcx,%rdx
  40c456:	40 00 c7             	add    %al,%dil
  40c459:	48 83 da 03          	sbb    $0x3,%rdx
  40c45d:	80 7a ff 0a          	cmpb   $0xa,-0x1(%rdx)
  40c461:	0f 85 f1 fe ff ff    	jne    40c358 <hardware+0x118>
    s[strlen(s)-1] = '\0';
  40c467:	c6 42 ff 00          	movb   $0x0,-0x1(%rdx)
  40c46b:	e9 e8 fe ff ff       	jmpq   40c358 <hardware+0x118>
          cp++;
        if(cp<buffer_end) {
          strcpy(vendor_id, cp);
        }
        removeNewLine(vendor_id);
      } else if(! strncmp(buffer, "model name", 10)) {
  40c470:	bf 90 e3 40 00       	mov    $0x40e390,%edi
  40c475:	b9 0a 00 00 00       	mov    $0xa,%ecx
  40c47a:	4c 89 fe             	mov    %r15,%rsi
  40c47d:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
  40c47f:	0f 85 c3 00 00 00    	jne    40c548 <hardware+0x308>
        cp+=strlen("model name");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c485:	4c 39 f2             	cmp    %r14,%rdx
  40c488:	76 4e                	jbe    40c4d8 <hardware+0x298>
  40c48a:	0f b6 84 24 3a 0c 00 	movzbl 0xc3a(%rsp),%eax
  40c491:	00 
  40c492:	3c 3a                	cmp    $0x3a,%al
  40c494:	0f 87 16 04 00 00    	ja     40c8b0 <hardware+0x670>
  40c49a:	48 b9 00 02 00 00 01 	movabs $0x400000100000200,%rcx
  40c4a1:	00 00 04 
  40c4a4:	4c 89 f6             	mov    %r14,%rsi
  40c4a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c4ae:	00 00 
  40c4b0:	48 0f a3 c1          	bt     %rax,%rcx
  40c4b4:	73 10                	jae    40c4c6 <hardware+0x286>
          cp++;
  40c4b6:	48 83 c6 01          	add    $0x1,%rsi
          strcpy(vendor_id, cp);
        }
        removeNewLine(vendor_id);
      } else if(! strncmp(buffer, "model name", 10)) {
        cp+=strlen("model name");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c4ba:	48 39 f2             	cmp    %rsi,%rdx
  40c4bd:	74 19                	je     40c4d8 <hardware+0x298>
  40c4bf:	0f b6 06             	movzbl (%rsi),%eax
  40c4c2:	3c 3a                	cmp    $0x3a,%al
  40c4c4:	76 ea                	jbe    40c4b0 <hardware+0x270>
  40c4c6:	48 8d bc 24 30 14 00 	lea    0x1430(%rsp),%rdi
  40c4cd:	00 
  40c4ce:	ba 00 04 00 00       	mov    $0x400,%edx
  40c4d3:	e8 28 4b ff ff       	callq  401000 <__strcpy_chk@plt>
** removeNewLine **
*******************
** Removes a trailing newline character if present
*/
static void removeNewLine(char * s) {
  if(strlen(s)>0 && s[strlen(s)-1] == '\n') {
  40c4d8:	80 bc 24 30 14 00 00 	cmpb   $0x0,0x1430(%rsp)
  40c4df:	00 
  40c4e0:	0f 84 72 fe ff ff    	je     40c358 <hardware+0x118>
  40c4e6:	48 8d 94 24 30 14 00 	lea    0x1430(%rsp),%rdx
  40c4ed:	00 
  40c4ee:	8b 0a                	mov    (%rdx),%ecx
  40c4f0:	48 83 c2 04          	add    $0x4,%rdx
  40c4f4:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40c4fa:	f7 d1                	not    %ecx
  40c4fc:	21 c8                	and    %ecx,%eax
  40c4fe:	25 80 80 80 80       	and    $0x80808080,%eax
  40c503:	74 e9                	je     40c4ee <hardware+0x2ae>
  40c505:	e9 35 ff ff ff       	jmpq   40c43f <hardware+0x1ff>
  40c50a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
        cpus++;
      } else if(! strncmp(buffer, "vendor_id", 9)) {
        cp+=strlen("vendor_id");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c510:	48 b9 00 02 00 00 01 	movabs $0x400000100000200,%rcx
  40c517:	00 00 04 
  40c51a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  40c520:	48 0f a3 c1          	bt     %rax,%rcx
  40c524:	0f 83 d6 fe ff ff    	jae    40c400 <hardware+0x1c0>
          cp++;
  40c52a:	48 83 c6 01          	add    $0x1,%rsi
      cp = buffer;
      if(! strncmp(buffer, "processor", 9)) {
        cpus++;
      } else if(! strncmp(buffer, "vendor_id", 9)) {
        cp+=strlen("vendor_id");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c52e:	48 39 f2             	cmp    %rsi,%rdx
  40c531:	0f 84 db fe ff ff    	je     40c412 <hardware+0x1d2>
  40c537:	0f b6 06             	movzbl (%rsi),%eax
  40c53a:	3c 3a                	cmp    $0x3a,%al
  40c53c:	0f 87 be fe ff ff    	ja     40c400 <hardware+0x1c0>
  40c542:	eb dc                	jmp    40c520 <hardware+0x2e0>
  40c544:	0f 1f 40 00          	nopl   0x0(%rax)
          cp++;
        if(cp<buffer_end) {
          strcpy(model_name, cp);
        }
        removeNewLine(model_name);
      } else if(! strncmp(buffer, "cpu MHz", 7)) {
  40c548:	bf 9b e3 40 00       	mov    $0x40e39b,%edi
  40c54d:	b9 07 00 00 00       	mov    $0x7,%ecx
  40c552:	4c 89 fe             	mov    %r15,%rsi
  40c555:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
  40c557:	0f 85 e3 02 00 00    	jne    40c840 <hardware+0x600>
        cp+=strlen("cpu MHz");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c55d:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40c562:	48 39 f2             	cmp    %rsi,%rdx
  40c565:	76 3c                	jbe    40c5a3 <hardware+0x363>
  40c567:	0f b6 84 24 37 0c 00 	movzbl 0xc37(%rsp),%eax
  40c56e:	00 
  40c56f:	3c 3a                	cmp    $0x3a,%al
  40c571:	77 23                	ja     40c596 <hardware+0x356>
  40c573:	48 b9 00 02 00 00 01 	movabs $0x400000100000200,%rcx
  40c57a:	00 00 04 
  40c57d:	0f 1f 00             	nopl   (%rax)
  40c580:	48 0f a3 c1          	bt     %rax,%rcx
  40c584:	73 10                	jae    40c596 <hardware+0x356>
          cp++;
  40c586:	48 83 c6 01          	add    $0x1,%rsi
          strcpy(model_name, cp);
        }
        removeNewLine(model_name);
      } else if(! strncmp(buffer, "cpu MHz", 7)) {
        cp+=strlen("cpu MHz");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c58a:	48 39 f2             	cmp    %rsi,%rdx
  40c58d:	74 14                	je     40c5a3 <hardware+0x363>
  40c58f:	0f b6 06             	movzbl (%rsi),%eax
  40c592:	3c 3a                	cmp    $0x3a,%al
  40c594:	76 ea                	jbe    40c580 <hardware+0x340>
  40c596:	ba 00 04 00 00       	mov    $0x400,%edx
  40c59b:	48 89 df             	mov    %rbx,%rdi
  40c59e:	e8 5d 4a ff ff       	callq  401000 <__strcpy_chk@plt>
** removeNewLine **
*******************
** Removes a trailing newline character if present
*/
static void removeNewLine(char * s) {
  if(strlen(s)>0 && s[strlen(s)-1] == '\n') {
  40c5a3:	80 bc 24 30 18 00 00 	cmpb   $0x0,0x1830(%rsp)
  40c5aa:	00 
  40c5ab:	0f 84 a7 fd ff ff    	je     40c358 <hardware+0x118>
  40c5b1:	48 89 da             	mov    %rbx,%rdx
  40c5b4:	8b 0a                	mov    (%rdx),%ecx
  40c5b6:	48 83 c2 04          	add    $0x4,%rdx
  40c5ba:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40c5c0:	f7 d1                	not    %ecx
  40c5c2:	21 c8                	and    %ecx,%eax
  40c5c4:	25 80 80 80 80       	and    $0x80808080,%eax
  40c5c9:	74 e9                	je     40c5b4 <hardware+0x374>
  40c5cb:	e9 6f fe ff ff       	jmpq   40c43f <hardware+0x1ff>
          strcpy(cache, cp);
        }
        removeNewLine(cache);
      }
    }
    if(cpus>1) {
  40c5d0:	41 83 fc 01          	cmp    $0x1,%r12d
  40c5d4:	0f 8e f1 02 00 00    	jle    40c8cb <hardware+0x68b>
      if (cpus==2) {
  40c5da:	41 83 fc 02          	cmp    $0x2,%r12d
  40c5de:	0f 84 d4 02 00 00    	je     40c8b8 <hardware+0x678>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  40c5e4:	4c 8d b4 24 30 04 00 	lea    0x430(%rsp),%r14
  40c5eb:	00 
  40c5ec:	45 89 e0             	mov    %r12d,%r8d
  40c5ef:	b9 ae e3 40 00       	mov    $0x40e3ae,%ecx
  40c5f4:	ba 00 04 00 00       	mov    $0x400,%edx
  40c5f9:	be 01 00 00 00       	mov    $0x1,%esi
  40c5fe:	31 c0                	xor    %eax,%eax
  40c600:	4c 89 f7             	mov    %r14,%rdi
  40c603:	e8 a8 4a ff ff       	callq  4010b0 <__sprintf_chk@plt>
        strcpy(model, "Dual");
      } else {
        sprintf(model, "%d CPU", cpus);
      }
    }
    cp = model + strlen(model);
  40c608:	4c 89 f0             	mov    %r14,%rax
  40c60b:	8b 08                	mov    (%rax),%ecx
  40c60d:	48 83 c0 04          	add    $0x4,%rax
  40c611:	8d 91 ff fe fe fe    	lea    -0x1010101(%rcx),%edx
  40c617:	f7 d1                	not    %ecx
  40c619:	21 ca                	and    %ecx,%edx
  40c61b:	81 e2 80 80 80 80    	and    $0x80808080,%edx
  40c621:	74 e8                	je     40c60b <hardware+0x3cb>
  40c623:	89 d1                	mov    %edx,%ecx
  40c625:	c1 e9 10             	shr    $0x10,%ecx
  40c628:	f7 c2 80 80 00 00    	test   $0x8080,%edx
  40c62e:	0f 44 d1             	cmove  %ecx,%edx
  40c631:	48 8d 48 02          	lea    0x2(%rax),%rcx
  40c635:	89 d7                	mov    %edx,%edi
  40c637:	48 0f 44 c1          	cmove  %rcx,%rax
  40c63b:	40 00 d7             	add    %dl,%dil
  40c63e:	48 83 d8 03          	sbb    $0x3,%rax
    if(vendor_id[0] != '\0'){
  40c642:	80 bc 24 30 10 00 00 	cmpb   $0x0,0x1030(%rsp)
  40c649:	00 
  40c64a:	0f 85 88 02 00 00    	jne    40c8d8 <hardware+0x698>
        *cp++ = ' ';
      }
      strcpy(cp, vendor_id);
      cp += strlen(vendor_id);
    }
    if(model_name[0] != '\0'){
  40c650:	80 bc 24 30 14 00 00 	cmpb   $0x0,0x1430(%rsp)
  40c657:	00 
  40c658:	74 66                	je     40c6c0 <hardware+0x480>
      if(cp != model){
  40c65a:	4c 39 f0             	cmp    %r14,%rax
  40c65d:	0f 84 0a 04 00 00    	je     40ca6d <hardware+0x82d>
        *cp++ = ' ';
  40c663:	4c 8d 40 01          	lea    0x1(%rax),%r8
  40c667:	c6 00 20             	movb   $0x20,(%rax)
  40c66a:	4c 8d a4 24 30 14 00 	lea    0x1430(%rsp),%r12
  40c671:	00 
  40c672:	4c 89 c7             	mov    %r8,%rdi
  40c675:	4c 89 e6             	mov    %r12,%rsi
  40c678:	e8 f3 47 ff ff       	callq  400e70 <strcpy@plt>
  40c67d:	49 89 c0             	mov    %rax,%r8
      }
      strcpy(cp, model_name);
      cp += strlen(model_name);
  40c680:	4c 89 e0             	mov    %r12,%rax
  40c683:	8b 08                	mov    (%rax),%ecx
  40c685:	48 83 c0 04          	add    $0x4,%rax
  40c689:	8d 91 ff fe fe fe    	lea    -0x1010101(%rcx),%edx
  40c68f:	f7 d1                	not    %ecx
  40c691:	21 ca                	and    %ecx,%edx
  40c693:	81 e2 80 80 80 80    	and    $0x80808080,%edx
  40c699:	74 e8                	je     40c683 <hardware+0x443>
  40c69b:	89 d1                	mov    %edx,%ecx
  40c69d:	c1 e9 10             	shr    $0x10,%ecx
  40c6a0:	f7 c2 80 80 00 00    	test   $0x8080,%edx
  40c6a6:	0f 44 d1             	cmove  %ecx,%edx
  40c6a9:	48 8d 48 02          	lea    0x2(%rax),%rcx
  40c6ad:	89 d7                	mov    %edx,%edi
  40c6af:	48 0f 44 c1          	cmove  %rcx,%rax
  40c6b3:	40 00 d7             	add    %dl,%dil
  40c6b6:	48 83 d8 03          	sbb    $0x3,%rax
  40c6ba:	4c 29 e0             	sub    %r12,%rax
  40c6bd:	4c 01 c0             	add    %r8,%rax
    }
    if(cpu_MHz[0] != '\0'){
  40c6c0:	80 bc 24 30 18 00 00 	cmpb   $0x0,0x1830(%rsp)
  40c6c7:	00 
  40c6c8:	74 4f                	je     40c719 <hardware+0x4d9>
      if(cp != model){
  40c6ca:	4c 39 f0             	cmp    %r14,%rax
  40c6cd:	0f 84 92 03 00 00    	je     40ca65 <hardware+0x825>
        *cp++ = ' ';
  40c6d3:	4c 8d 60 01          	lea    0x1(%rax),%r12
  40c6d7:	c6 00 20             	movb   $0x20,(%rax)
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline double
__NTH (atof (const char *__nptr))
{
  return strtod (__nptr, (char **) NULL);
  40c6da:	31 f6                	xor    %esi,%esi
  40c6dc:	48 89 df             	mov    %rbx,%rdi
  40c6df:	e8 cc 47 ff ff       	callq  400eb0 <strtod@plt>
  40c6e4:	f2 0f 5a c0          	cvtsd2ss %xmm0,%xmm0
  40c6e8:	f3 0f 58 05 1c 1d 00 	addss  0x1d1c(%rip),%xmm0        # 40e40c <jtable.3055+0x167c>
  40c6ef:	00 
  40c6f0:	be 01 00 00 00       	mov    $0x1,%esi
  40c6f5:	48 89 df             	mov    %rbx,%rdi
  40c6f8:	b9 b5 e3 40 00       	mov    $0x40e3b5,%ecx
  40c6fd:	ba 00 04 00 00       	mov    $0x400,%edx
  40c702:	31 c0                	xor    %eax,%eax
  40c704:	f3 44 0f 2c c0       	cvttss2si %xmm0,%r8d
  40c709:	e8 a2 49 ff ff       	callq  4010b0 <__sprintf_chk@plt>
  40c70e:	48 89 de             	mov    %rbx,%rsi
  40c711:	4c 89 e7             	mov    %r12,%rdi
  40c714:	e8 57 47 ff ff       	callq  400e70 <strcpy@plt>
      i = (int)(f+0.5f);
      sprintf(cpu_MHz, "%dMHz", i);
      strcpy(cp, cpu_MHz);
      cp += strlen(cpu_MHz);
    }
    fclose(info);
  40c719:	48 89 ef             	mov    %rbp,%rdi
  40c71c:	e8 bf 47 ff ff       	callq  400ee0 <fclose@plt>
  40c721:	4d 89 f0             	mov    %r14,%r8
  40c724:	b9 bb e3 40 00       	mov    $0x40e3bb,%ecx
  40c729:	ba 00 04 00 00       	mov    $0x400,%edx
  40c72e:	be 01 00 00 00       	mov    $0x1,%esi
  40c733:	48 89 df             	mov    %rbx,%rdi
  40c736:	31 c0                	xor    %eax,%eax
  40c738:	e8 73 49 ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c73d:	31 c0                	xor    %eax,%eax
  40c73f:	48 89 da             	mov    %rbx,%rdx
  40c742:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40c747:	bf 01 00 00 00       	mov    $0x1,%edi
  40c74c:	e8 bf 48 ff ff       	callq  401010 <__printf_chk@plt>
** return at the end of the buffer.
*/
static void output_string(const char *buffer, const int write_to_file,
                          FILE *global_ofile){
  printf("%s",buffer);
  if(write_to_file!=0)
  40c751:	8b 44 24 0c          	mov    0xc(%rsp),%eax
  40c755:	85 c0                	test   %eax,%eax
  40c757:	0f 85 23 02 00 00    	jne    40c980 <hardware+0x740>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  40c75d:	4c 8b 04 24          	mov    (%rsp),%r8
  40c761:	b9 d5 e3 40 00       	mov    $0x40e3d5,%ecx
  40c766:	ba 00 04 00 00       	mov    $0x400,%edx
  40c76b:	be 01 00 00 00       	mov    $0x1,%esi
  40c770:	48 89 df             	mov    %rbx,%rdi
  40c773:	31 c0                	xor    %eax,%eax
  40c775:	e8 36 49 ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c77a:	48 89 da             	mov    %rbx,%rdx
  40c77d:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40c782:	bf 01 00 00 00       	mov    $0x1,%edi
  40c787:	31 c0                	xor    %eax,%eax
  40c789:	e8 82 48 ff ff       	callq  401010 <__printf_chk@plt>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  40c78e:	ba 00 04 00 00       	mov    $0x400,%edx
  40c793:	be 01 00 00 00       	mov    $0x1,%esi
  40c798:	48 89 df             	mov    %rbx,%rdi
  40c79b:	4d 89 e8             	mov    %r13,%r8
  40c79e:	b9 ef e3 40 00       	mov    $0x40e3ef,%ecx
  40c7a3:	31 c0                	xor    %eax,%eax
  40c7a5:	e8 06 49 ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c7aa:	48 89 da             	mov    %rbx,%rdx
  40c7ad:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40c7b2:	bf 01 00 00 00       	mov    $0x1,%edi
  40c7b7:	31 c0                	xor    %eax,%eax
  40c7b9:	e8 52 48 ff ff       	callq  401010 <__printf_chk@plt>
  output_string(buffer, write_to_file, global_ofile);
  sprintf(buffer, "L2 Cache            : %s\n", cache);
  output_string(buffer, write_to_file, global_ofile);
  sprintf(buffer, "OS                  : %s\n", os);
  output_string(buffer, write_to_file, global_ofile);
}
  40c7be:	48 8b 84 24 38 1c 00 	mov    0x1c38(%rsp),%rax
  40c7c5:	00 
  40c7c6:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40c7cd:	00 00 
  40c7cf:	0f 85 a0 02 00 00    	jne    40ca75 <hardware+0x835>
  40c7d5:	48 81 c4 48 1c 00 00 	add    $0x1c48,%rsp
  40c7dc:	5b                   	pop    %rbx
  40c7dd:	5d                   	pop    %rbp
  40c7de:	41 5c                	pop    %r12
  40c7e0:	41 5d                	pop    %r13
  40c7e2:	41 5e                	pop    %r14
  40c7e4:	41 5f                	pop    %r15
  40c7e6:	c3                   	retq   
  40c7e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40c7ee:	00 00 
** removeNewLine **
*******************
** Removes a trailing newline character if present
*/
static void removeNewLine(char * s) {
  if(strlen(s)>0 && s[strlen(s)-1] == '\n') {
  40c7f0:	4c 89 ea             	mov    %r13,%rdx
  40c7f3:	8b 0a                	mov    (%rdx),%ecx
  40c7f5:	48 83 c2 04          	add    $0x4,%rdx
  40c7f9:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40c7ff:	f7 d1                	not    %ecx
  40c801:	21 c8                	and    %ecx,%eax
  40c803:	25 80 80 80 80       	and    $0x80808080,%eax
  40c808:	74 e9                	je     40c7f3 <hardware+0x5b3>
  40c80a:	89 c1                	mov    %eax,%ecx
  40c80c:	c1 e9 10             	shr    $0x10,%ecx
  40c80f:	a9 80 80 00 00       	test   $0x8080,%eax
  40c814:	0f 44 c1             	cmove  %ecx,%eax
  40c817:	48 8d 4a 02          	lea    0x2(%rdx),%rcx
  40c81b:	89 c3                	mov    %eax,%ebx
  40c81d:	48 0f 44 d1          	cmove  %rcx,%rdx
  40c821:	00 c3                	add    %al,%bl
  40c823:	48 83 da 03          	sbb    $0x3,%rdx
  40c827:	80 7a ff 0a          	cmpb   $0xa,-0x1(%rdx)
  40c82b:	0f 85 9f fa ff ff    	jne    40c2d0 <hardware+0x90>
    s[strlen(s)-1] = '\0';
  40c831:	c6 42 ff 00          	movb   $0x0,-0x1(%rdx)
  40c835:	e9 96 fa ff ff       	jmpq   40c2d0 <hardware+0x90>
  40c83a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
          cp++;
        if(cp<buffer_end) {
          strcpy(cpu_MHz, cp);
        }
        removeNewLine(cpu_MHz);
      } else if(! strncmp(buffer, "cache size", 10)) {
  40c840:	bf a3 e3 40 00       	mov    $0x40e3a3,%edi
  40c845:	b9 0a 00 00 00       	mov    $0xa,%ecx
  40c84a:	4c 89 fe             	mov    %r15,%rsi
  40c84d:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
  40c84f:	0f 85 03 fb ff ff    	jne    40c358 <hardware+0x118>
        cp+=strlen("cache size");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c855:	4c 39 f2             	cmp    %r14,%rdx
  40c858:	76 24                	jbe    40c87e <hardware+0x63e>
  40c85a:	0f b6 84 24 3a 0c 00 	movzbl 0xc3a(%rsp),%eax
  40c861:	00 
  40c862:	3c 3a                	cmp    $0x3a,%al
  40c864:	0f 86 a2 01 00 00    	jbe    40ca0c <hardware+0x7cc>
  40c86a:	4c 89 f6             	mov    %r14,%rsi
  40c86d:	0f 1f 00             	nopl   (%rax)
  40c870:	48 8b 3c 24          	mov    (%rsp),%rdi
  40c874:	ba 00 04 00 00       	mov    $0x400,%edx
  40c879:	e8 82 47 ff ff       	callq  401000 <__strcpy_chk@plt>
** removeNewLine **
*******************
** Removes a trailing newline character if present
*/
static void removeNewLine(char * s) {
  if(strlen(s)>0 && s[strlen(s)-1] == '\n') {
  40c87e:	80 bc 24 30 08 00 00 	cmpb   $0x0,0x830(%rsp)
  40c885:	00 
  40c886:	0f 84 cc fa ff ff    	je     40c358 <hardware+0x118>
  40c88c:	48 8b 14 24          	mov    (%rsp),%rdx
  40c890:	8b 0a                	mov    (%rdx),%ecx
  40c892:	48 83 c2 04          	add    $0x4,%rdx
  40c896:	8d 81 ff fe fe fe    	lea    -0x1010101(%rcx),%eax
  40c89c:	f7 d1                	not    %ecx
  40c89e:	21 c8                	and    %ecx,%eax
  40c8a0:	25 80 80 80 80       	and    $0x80808080,%eax
  40c8a5:	74 e9                	je     40c890 <hardware+0x650>
  40c8a7:	e9 93 fb ff ff       	jmpq   40c43f <hardware+0x1ff>
  40c8ac:	0f 1f 40 00          	nopl   0x0(%rax)
          strcpy(vendor_id, cp);
        }
        removeNewLine(vendor_id);
      } else if(! strncmp(buffer, "model name", 10)) {
        cp+=strlen("model name");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40c8b0:	4c 89 f6             	mov    %r14,%rsi
  40c8b3:	e9 0e fc ff ff       	jmpq   40c4c6 <hardware+0x286>
  40c8b8:	c7 84 24 30 04 00 00 	movl   $0x6c617544,0x430(%rsp)
  40c8bf:	44 75 61 6c 
  40c8c3:	c6 84 24 34 04 00 00 	movb   $0x0,0x434(%rsp)
  40c8ca:	00 
  40c8cb:	4c 8d b4 24 30 04 00 	lea    0x430(%rsp),%r14
  40c8d2:	00 
  40c8d3:	e9 30 fd ff ff       	jmpq   40c608 <hardware+0x3c8>
        sprintf(model, "%d CPU", cpus);
      }
    }
    cp = model + strlen(model);
    if(vendor_id[0] != '\0'){
      if(cp != model){
  40c8d8:	4c 39 f0             	cmp    %r14,%rax
  40c8db:	0f 84 7c 01 00 00    	je     40ca5d <hardware+0x81d>
        *cp++ = ' ';
  40c8e1:	4c 8d 40 01          	lea    0x1(%rax),%r8
  40c8e5:	c6 00 20             	movb   $0x20,(%rax)
  40c8e8:	4c 8d a4 24 30 10 00 	lea    0x1030(%rsp),%r12
  40c8ef:	00 
  40c8f0:	4c 89 c7             	mov    %r8,%rdi
  40c8f3:	4c 89 e6             	mov    %r12,%rsi
  40c8f6:	e8 75 45 ff ff       	callq  400e70 <strcpy@plt>
  40c8fb:	49 89 c0             	mov    %rax,%r8
      }
      strcpy(cp, vendor_id);
      cp += strlen(vendor_id);
  40c8fe:	4c 89 e0             	mov    %r12,%rax
  40c901:	8b 08                	mov    (%rax),%ecx
  40c903:	48 83 c0 04          	add    $0x4,%rax
  40c907:	8d 91 ff fe fe fe    	lea    -0x1010101(%rcx),%edx
  40c90d:	f7 d1                	not    %ecx
  40c90f:	21 ca                	and    %ecx,%edx
  40c911:	81 e2 80 80 80 80    	and    $0x80808080,%edx
  40c917:	74 e8                	je     40c901 <hardware+0x6c1>
  40c919:	89 d1                	mov    %edx,%ecx
  40c91b:	c1 e9 10             	shr    $0x10,%ecx
  40c91e:	f7 c2 80 80 00 00    	test   $0x8080,%edx
  40c924:	0f 44 d1             	cmove  %ecx,%edx
  40c927:	48 8d 48 02          	lea    0x2(%rax),%rcx
  40c92b:	89 d7                	mov    %edx,%edi
  40c92d:	48 0f 44 c1          	cmove  %rcx,%rax
  40c931:	40 00 d7             	add    %dl,%dil
  40c934:	48 83 d8 03          	sbb    $0x3,%rax
  40c938:	4c 29 e0             	sub    %r12,%rax
  40c93b:	4c 01 c0             	add    %r8,%rax
  40c93e:	e9 0d fd ff ff       	jmpq   40c650 <hardware+0x410>
  40c943:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  runCommand(os_command, os);
#endif
  if(NULL != strstr(os, "Linux")) {
    readProcCpuInfo (model, cache);
  } else {
    model[0] = '\0';
  40c948:	c6 84 24 30 04 00 00 	movb   $0x0,0x430(%rsp)
  40c94f:	00 
    cache[0] = '\0';
  40c950:	c6 84 24 30 08 00 00 	movb   $0x0,0x830(%rsp)
  40c957:	00 
  40c958:	48 8d 84 24 30 08 00 	lea    0x830(%rsp),%rax
  40c95f:	00 
  40c960:	48 8d 9c 24 30 18 00 	lea    0x1830(%rsp),%rbx
  40c967:	00 
  40c968:	4c 8d b4 24 30 04 00 	lea    0x430(%rsp),%r14
  40c96f:	00 
  40c970:	48 89 04 24          	mov    %rax,(%rsp)
  40c974:	e9 a8 fd ff ff       	jmpq   40c721 <hardware+0x4e1>
  40c979:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40c980:	4c 8b 74 24 10       	mov    0x10(%rsp),%r14
  40c985:	48 89 df             	mov    %rbx,%rdi
  40c988:	4c 89 f6             	mov    %r14,%rsi
  40c98b:	e8 b0 45 ff ff       	callq  400f40 <fputs@plt>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  40c990:	4c 8b 04 24          	mov    (%rsp),%r8
  40c994:	b9 d5 e3 40 00       	mov    $0x40e3d5,%ecx
  40c999:	48 89 df             	mov    %rbx,%rdi
  40c99c:	ba 00 04 00 00       	mov    $0x400,%edx
  40c9a1:	be 01 00 00 00       	mov    $0x1,%esi
  40c9a6:	31 c0                	xor    %eax,%eax
  40c9a8:	e8 03 47 ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c9ad:	48 89 da             	mov    %rbx,%rdx
  40c9b0:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40c9b5:	bf 01 00 00 00       	mov    $0x1,%edi
  40c9ba:	31 c0                	xor    %eax,%eax
  40c9bc:	e8 4f 46 ff ff       	callq  401010 <__printf_chk@plt>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40c9c1:	4c 89 f6             	mov    %r14,%rsi
  40c9c4:	48 89 df             	mov    %rbx,%rdi
  40c9c7:	e8 74 45 ff ff       	callq  400f40 <fputs@plt>

#ifdef __va_arg_pack
__fortify_function int
__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
  40c9cc:	4d 89 e8             	mov    %r13,%r8
  40c9cf:	b9 ef e3 40 00       	mov    $0x40e3ef,%ecx
  40c9d4:	48 89 df             	mov    %rbx,%rdi
  40c9d7:	ba 00 04 00 00       	mov    $0x400,%edx
  40c9dc:	be 01 00 00 00       	mov    $0x1,%esi
  40c9e1:	31 c0                	xor    %eax,%eax
  40c9e3:	e8 c8 46 ff ff       	callq  4010b0 <__sprintf_chk@plt>
}

__fortify_function int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
  40c9e8:	48 89 da             	mov    %rbx,%rdx
  40c9eb:	be bc cd 40 00       	mov    $0x40cdbc,%esi
  40c9f0:	bf 01 00 00 00       	mov    $0x1,%edi
  40c9f5:	31 c0                	xor    %eax,%eax
  40c9f7:	e8 14 46 ff ff       	callq  401010 <__printf_chk@plt>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40c9fc:	4c 89 f6             	mov    %r14,%rsi
  40c9ff:	48 89 df             	mov    %rbx,%rdi
  40ca02:	e8 39 45 ff ff       	callq  400f40 <fputs@plt>
  output_string(buffer, write_to_file, global_ofile);
  sprintf(buffer, "L2 Cache            : %s\n", cache);
  output_string(buffer, write_to_file, global_ofile);
  sprintf(buffer, "OS                  : %s\n", os);
  output_string(buffer, write_to_file, global_ofile);
}
  40ca07:	e9 b2 fd ff ff       	jmpq   40c7be <hardware+0x57e>
          strcpy(cpu_MHz, cp);
        }
        removeNewLine(cpu_MHz);
      } else if(! strncmp(buffer, "cache size", 10)) {
        cp+=strlen("cache size");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40ca0c:	48 b9 00 02 00 00 01 	movabs $0x400000100000200,%rcx
  40ca13:	00 00 04 
  40ca16:	4c 89 f6             	mov    %r14,%rsi
  40ca19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  40ca20:	48 0f a3 c1          	bt     %rax,%rcx
  40ca24:	0f 83 46 fe ff ff    	jae    40c870 <hardware+0x630>
          cp++;
  40ca2a:	48 83 c6 01          	add    $0x1,%rsi
          strcpy(cpu_MHz, cp);
        }
        removeNewLine(cpu_MHz);
      } else if(! strncmp(buffer, "cache size", 10)) {
        cp+=strlen("cache size");
        while(cp < buffer_end && ( *cp == ' ' || *cp == ':'|| *cp == '\t'))
  40ca2e:	48 39 f2             	cmp    %rsi,%rdx
  40ca31:	0f 84 47 fe ff ff    	je     40c87e <hardware+0x63e>
  40ca37:	0f b6 06             	movzbl (%rsi),%eax
  40ca3a:	3c 3a                	cmp    $0x3a,%al
  40ca3c:	0f 87 2e fe ff ff    	ja     40c870 <hardware+0x630>
  40ca42:	eb dc                	jmp    40ca20 <hardware+0x7e0>
  FILE * pipe;

  pipe = popen(command, "r");
  if(pipe == NULL) {
    /* command failed */
    result[0] = '\0';
  40ca44:	c6 44 24 30 00       	movb   $0x0,0x30(%rsp)
  40ca49:	4c 8d 6c 24 30       	lea    0x30(%rsp),%r13
  40ca4e:	e9 7d f8 ff ff       	jmpq   40c2d0 <hardware+0x90>
  } else {
    if(NULL == fgets(result, BUF_SIZ, pipe)){
      /* command failed */
      result[0] = '\0';
  40ca53:	c6 44 24 30 00       	movb   $0x0,0x30(%rsp)
  40ca58:	e9 60 f8 ff ff       	jmpq   40c2bd <hardware+0x7d>
        sprintf(model, "%d CPU", cpus);
      }
    }
    cp = model + strlen(model);
    if(vendor_id[0] != '\0'){
      if(cp != model){
  40ca5d:	4d 89 f0             	mov    %r14,%r8
  40ca60:	e9 83 fe ff ff       	jmpq   40c8e8 <hardware+0x6a8>
      }
      strcpy(cp, model_name);
      cp += strlen(model_name);
    }
    if(cpu_MHz[0] != '\0'){
      if(cp != model){
  40ca65:	4d 89 f4             	mov    %r14,%r12
  40ca68:	e9 6d fc ff ff       	jmpq   40c6da <hardware+0x49a>
      }
      strcpy(cp, vendor_id);
      cp += strlen(vendor_id);
    }
    if(model_name[0] != '\0'){
      if(cp != model){
  40ca6d:	4d 89 f0             	mov    %r14,%r8
  40ca70:	e9 f5 fb ff ff       	jmpq   40c66a <hardware+0x42a>
  output_string(buffer, write_to_file, global_ofile);
  sprintf(buffer, "L2 Cache            : %s\n", cache);
  output_string(buffer, write_to_file, global_ofile);
  sprintf(buffer, "OS                  : %s\n", os);
  output_string(buffer, write_to_file, global_ofile);
}
  40ca75:	e8 86 44 ff ff       	callq  400f00 <__stack_chk_fail@plt>
  40ca7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000040ca80 <__libc_csu_init>:
  40ca80:	41 57                	push   %r15
  40ca82:	41 56                	push   %r14
  40ca84:	41 89 ff             	mov    %edi,%r15d
  40ca87:	41 55                	push   %r13
  40ca89:	41 54                	push   %r12
  40ca8b:	4c 8d 25 6e 33 20 00 	lea    0x20336e(%rip),%r12        # 60fe00 <__frame_dummy_init_array_entry>
  40ca92:	55                   	push   %rbp
  40ca93:	48 8d 2d 6e 33 20 00 	lea    0x20336e(%rip),%rbp        # 60fe08 <__init_array_end>
  40ca9a:	53                   	push   %rbx
  40ca9b:	49 89 f6             	mov    %rsi,%r14
  40ca9e:	49 89 d5             	mov    %rdx,%r13
  40caa1:	4c 29 e5             	sub    %r12,%rbp
  40caa4:	48 83 ec 08          	sub    $0x8,%rsp
  40caa8:	48 c1 fd 03          	sar    $0x3,%rbp
  40caac:	e8 3f 43 ff ff       	callq  400df0 <_init>
  40cab1:	48 85 ed             	test   %rbp,%rbp
  40cab4:	74 20                	je     40cad6 <__libc_csu_init+0x56>
  40cab6:	31 db                	xor    %ebx,%ebx
  40cab8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40cabf:	00 
  40cac0:	4c 89 ea             	mov    %r13,%rdx
  40cac3:	4c 89 f6             	mov    %r14,%rsi
  40cac6:	44 89 ff             	mov    %r15d,%edi
  40cac9:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  40cacd:	48 83 c3 01          	add    $0x1,%rbx
  40cad1:	48 39 eb             	cmp    %rbp,%rbx
  40cad4:	75 ea                	jne    40cac0 <__libc_csu_init+0x40>
  40cad6:	48 83 c4 08          	add    $0x8,%rsp
  40cada:	5b                   	pop    %rbx
  40cadb:	5d                   	pop    %rbp
  40cadc:	41 5c                	pop    %r12
  40cade:	41 5d                	pop    %r13
  40cae0:	41 5e                	pop    %r14
  40cae2:	41 5f                	pop    %r15
  40cae4:	c3                   	retq   
  40cae5:	90                   	nop
  40cae6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40caed:	00 00 00 

000000000040caf0 <__libc_csu_fini>:
  40caf0:	f3 c3                	repz retq 

Disassembly of section .fini:

000000000040caf4 <_fini>:
  40caf4:	48 83 ec 08          	sub    $0x8,%rsp
  40caf8:	48 83 c4 08          	add    $0x8,%rsp
  40cafc:	c3                   	retq   
